class Benchmarks { benchmarks output clock }

  class method output: output clock: clock 
    self benchmarks: [ Benchmark emptyLoop,
                       Benchmark factorial,
                       Benchmark sumFloats,
                       Benchmark ackermann,
                       Benchmark fibonacci ]
         output: output
         clock: clock

  method run
    benchmarks do: { |benchmark|
       benchmark
       ; runWith: clock
       ; reportTo: output
    }

end

class Benchmark
  { name block userTime systemTime realTime }

    class method Benchmark new: name is: block
        self name: name
             block: block
             userTime: false
             systemTime: false
             realTime: false


   method runWith: clock
    let info0 = clock timeInfo
    let info1 = clock timeInfo
    block value
    let info2 = clock timeInfo
    let delta = (info2 - info1) - (info1 - info0),
    userTime := delta userTime
    systemTime := delta systemTime
    realTime := delta realTime

   method reportTo: output
      output
      ; print: name
      ; print: ": "
      ; print: userTime toString
      ; print: ", "
      ; print: systemTime toString
      ; print: ", "
      ; print: realTime toString
      ; newline

   class method sumFloats
      let array = []
      1 to: 150_000 do: { array push: _ toFloat }
      Benchmark new: "SumFloats" is:
      {
        array inject: 0.0 into: { |sum each | sum + each }
      }

   class method factorial
      Benchmark new: "Factorial" is: {
         let res = 0
         2000 times: { res = Factorial of: 20 }
         res
      }

   class method emptyLoop
      Benchmark new: "EmptyLoop" is: {
        600000 times: {}
      }

   class method ackermann
      Benchmark new: "Ackermann" is: {
         50 times: { Ackermann m: 3 n: 2 }
      }

   class method fibonacci
      Benchmark new: "Fibonacci" is: {
         Fibonacci of: 21
      }

end

class Fibonacci {}

   class method of: n
      n < 2
        ifTrue: { return 1 },
     (Fibonacci of: n - 1) + (Fibonacci of: n - 2)

end

class Factorial {}

   class method Factorial of: n
      n < 2
        ifTrue: { return n },
      n * (Factorial of: n - 1)

end

class Ackermann {}

   class method Ackermann m:m n:n
      m == 0
        ifTrue: { return n + 1 },
      n == 0
        ifTrue: { return Ackermann m: m - 1 n: 1 },
     Ackermann m: m - 1 n: (Ackermann m: m n: n - 1)

end
