extend Array
    method + x
       x addArray: self
    method - x
       x subArray: self
    method * x
       x mulArray: self
    method / x
       x divArray: self

    method norm
       (self inject: 0.0 into: { |abs elt| abs + (elt square) }) sqrt

    method normalized
       let reciprocal = 1.0 / (self norm).
       self * reciprocal

    method scalarProjectionOn: other
        (self dot: other) / other norm

    method vectorProjectionOn: other
        ((self dot: other) / (other dot: other)) * other

    method do: block
        self inject: False into: { |dummy elt| block value: elt }.
        self

    method collect: block
        self inject: [] into: { |res elt| res push: (block value: elt) }

    method sum
        self inject: 0 into: { |res elt| res + elt }

    method sum: block
        self inject: 0 into: { |res elt| res + (block value: elt) }

    method addInteger: x
       self collect: { |elt| elt addInteger: x }
    method addFloat: x
       self collect: { |elt| elt addFloat: x }

    method divFloat: x
       self collect: { |elt| elt divFloat: x }
    method divInteger: x
       self collect: { |elt| elt divInteger: x }

    method mulInteger: x
       self collect: { |elt| elt mulInteger: x }
    method mulFloat: x
       self collect: { |elt| elt mulFloat: x }

    method subInteger: x
       self collect: { |elt| elt subInteger: x }
    method subFloat: x
       self collect: { |elt| elt subFloat: x }
end

extend Boolean
    method and: other::Boolean
        self
           ifTrue: { other }
           ifFalse: { False }

    method or: other::Boolean
        self
           ifTrue: { True }
           ifFalse: { other }

    method not
        self
           ifTrue: { False }
           ifFalse: { True }

    method ifTrue: block
        self
           ifTrue: block
           ifFalse: { False }

    method ifFalse: block
        self
           -- FIXME: returning True in the first leg seems strange, but breaks a couple
           -- of tests. Should either explain the rational or return False.
           ifTrue: { True }
           ifFalse: block

    method toString
        self
           ifTrue: { "True" }
           ifFalse: { "False" }
end

extend Float
    method asFloat
        self

    method + x
        x addFloat: self
    method - x
        x subFloat: self
    method * x
        x mulFloat: self
    method / x
        x divFloat: self

    method square
        self mulFloat: self

    method == x
        x equalFloat: self
    method < x
        x greaterThanFloat: self
    method > x
        x lessThanFloat: self
    method <= x
        x greaterThanOrEqualFloat: self
    method >= x
        x lessThanOrEqualFloat: self

    method addInteger: x
        self addFloat: x asFloat
    method subInteger: x
        self subFloat: x asFloat
    method mulInteger: x
        self mulFloat: x asFloat
    method divInteger: x
        self divFloat: x asFloat

    method addArray: x
        x collect: { |elt| elt addFloat: self }
    method mulArray: x
        x collect: { |elt| elt mulFloat: self }
    method subArray: x
        -- FIXME: Should the arith protocol include reverses mul and sub?
        x collect: { |elt| elt - self }
    method divArray: x
        x collect: { |elt| elt / self }

    method equalInteger: x
        self equalFloat: x asFloat
    method lessThanInteger: x
        self lessThanFloat: x asFloat
    method greaterThanInteger: x
        self greaterThanFloat: x asFloat
    method lessThanOrEqualInteger: x
        self lessThanOrEqualFloat: x asFloat
    method greaterThanOrEqualInteger: x
        self greaterThanOrEqualFloat: x asFloat

    method atLeast: min atMost: max
        let min = min asFloat.
        (self lessThanFloat: min)
            ifTrue: { return min }.
        let max = max asFloat.
        (self greaterThanFloat: max)
            ifTrue: { return max }.
        self
end

extend Integer
    method asInteger
        self

    method + x
        x addInteger: self
    method - x
        x subInteger: self
    method * x
        x mulInteger: self
    method / x
        x divInteger: self

    method square
        self mulInteger: self

    method == x
        x equalInteger: self
    method < x
        x greaterThanInteger: self
    method > x
        x lessThanInteger: self
    method <= x
        x greaterThanOrEqualInteger: self
    method >= x
        x lessThanOrEqualInteger: self

    method addFloat: x
        self asFloat addFloat: x
    method subFloat: x
        self asFloat subFloat: x
    method mulFloat: x
        self asFloat mulFloat: x
    method divFloat: x
        self asFloat divFloat: x

    method addArray: x
        x collect: { |elt| elt addInteger: self }
    method mulArray: x
        x collect: { |elt| elt mulInteger: self }
    method subArray: x
        x collect: { |elt| elt - self }
    method divArray: x
        x collect: { |elt| elt / self }

    method equalFloat: x
        self asFloat equalFloat: x
    method greaterThanFloat: x
        self asFloat greaterThanFloat: x
    method greaterThanOrEqualFloat: x
        self asFloat greaterThanOrEqualFloat: x
    method lessThanFloat: x
        self asFloat lessThanFloat: x
    method lessThanOrEqualFloat: x
        self asFloat lessThanOrEqualFloat: x
end

extend Time
    method + x
        x addTime: self
    method - x
        x subTime: self
end
