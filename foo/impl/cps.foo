import lib.assert.Assert
import .parser.Parser


interface Log
    direct method newline
        Output debug newline!
    direct method print: what
        Output debug print: what!
    direct method println: what
        Output debug println: what!
end


interface CpsValue
    -- Valid value to flow through CPS in evaluator
    -- or as a constant.
    required method printName
    required method type
    required method hostValue
end


class CpsSelector { name }
    is Object
    is CpsValue

    method < other
        name < other name!

    method toString
        "#<CpsSelector {name}>"!

    method displayOn: stream
        stream writeString: "#<CpsSelector {name}>"!

    method printName
        "#{name}"!

    method hostValue
        Selector intern: name!

    method type
        self classDefinitionImpl!
end


class Namespace { _dictionary _sealed }
    -- For interning selectors
    direct method empty
        self _dictionary: Dictionary new
             _sealed: False!


    direct method standard
        StandardNamespace copy!


    method intern: name
        _dictionary
            at: name
            ifNonePut: { _sealed
                             ifTrue: { Error raise: "Cannot intern {name displayString} in a sealed namespace!" }.
                         CpsSelector name: name }!


    method seal
        _sealed = True.
        self!


    method copy
        Namespace _dictionary: _dictionary copy
                  _sealed: False!
end


define StandardNamespace
    let namespace = Namespace empty.
    [
         "+",
         "//",
         "-",
         "*",
         "addInteger:",
         "subInteger:",
         "mulInteger:",
         "truncateInteger:",
         "ifFalse:",
         "ifTrue:",
         "ifTrue:ifFalse:",
         "new",
         "opaqueIdentity",
         "typecheck:",
         "whileFalse:",
         "whileTrue:"
    ]
    do: { |each|
          namespace intern: each }.
    namespace seal!


extend String
    -- This is _a_ solution to allowing users to
    -- intern without special objects: they cannot
    -- intern new things!
    method intern
        StandardNamespace intern: self!
end


interface MethodDefinition
    is Object
    is CpsValue

    method name
        -- FIXME: why is this needed? some errors provoke it in turn
        self selector name!


    method < other
        self name < other name!


    method returnType
        False!


    method inlineIn: _ in: _ with: _
        False!


    method printName
        "{self home name}#{self selector name}"!


    method toString
        "#<{self classOf name} {self home name}#{self name}>"!


    method displayString
        self toString!


    method visitBy: visitor
        visitor visitMethodDefinition: self!


    method hostValue
        self!


    method type
        MethodClassDefinition!


    method isStandard
        True!


    method dependencies
        self impl dependencies!

end


class UserMethod { selector home cps }
    is MethodDefinition

    direct method selector: selector
        self selector: selector
             home: False
             cps: False!


    direct method selector: selector cps: cps
        self selector: selector
             home: False
             cps: cps!


    method impl
        cps!


    method home: new
        (home is False)
            ifFalse: { Error raise: "{self} already has a home: {home}" }.
        home = new!


    method cps: new
        (cps is False)
            ifFalse: { Error raise: "{self} already has a cps: {cps}" }.
        cps = new!


    method displayOn: stream
        stream writeString: "#<UserMethod {selector name}>"!


    method isStandard
        False!


    method apply: args
        cps is False
            ifTrue: { Error raise: "{self} has no body, cannot apply!" }.
        cps apply: args!


    method inlineIn: aCont in: graph with: worklist
        cps is False
            ifTrue: { return False }.
        (graph allowInline: cps)
            ifFalse: { return False }.
        let cc = aCont target target.
        aCont target: (CpsCopier copy: cps entry to: graph).
        aCont prependArgs: [cc].
        worklist push: aCont!

end


class BuiltinMethod { home impl }
    is MethodDefinition

    direct method new: impl
        self home: False
             impl: impl!


    method selector
        impl selector!


    method apply: args
        impl apply: args in: home!


    method returnType
        impl returnType!


    method inlineIn: aCont in: graph with: worklist
        impl inlineIn: aCont in: graph with: worklist!


    method home: new
        (home is False)
            ifFalse: { Error raise: "BuiltinMethod {self selector name} already has a home: {home}" }.
        home = new!
end


interface BuiltinMethodImpl
    is Object

    method displayString
        "#<BuiltinMethodImpl {self selector name}>"!

    method returnType
        False!

    method dependencies
        []!

    method emitOn: backend
        backend emitBuiltin: self!
end


class OpaqueIdentityImpl {}
    -- Very useful for compiler testing: never inlined!
    is BuiltinMethodImpl

    direct method for: _
        OpaqueIdentityInstance!


    method selector
        "opaqueIdentity" intern!


    method inlineIn: _aCont in: _aGraph with: _worklist
        False!


    method apply: args in: _classDefinition
        args first!


    method emitOn: backend
        backend emitOpaqueIdentity: self!
end


define OpaqueIdentityInstance
    OpaqueIdentityImpl new!


class ConstructorImpl { classDefinition }
    is BuiltinMethodImpl

    direct method for: classDefinition
        self classDefinition: classDefinition!


    method returnType
        classDefinition!


    method selector
        "new" intern!


    method inlineIn: continuation in: graph with: worklist
        continuation removeArgs.
        continuation addArgs: [graph ensureOperation: MAKE_INSTANCE
                                     args: [graph ensureConstant: classDefinition,
                                            graph ensureConstant: (Instance class: IntegerClassDefinition
                                                                            datum: 0)]].
        continuation target: continuation target :: Application target!


    method apply: args in: _classDefinition
        -- Log println: "\nNEW: {args}".
        Instance class: args first
                 datum: args second!


    method emitOn: backend
        backend emitConstructor: self!
end


class TypecheckImpl { type }
    is BuiltinMethodImpl

    direct method for: type
        self type: type!


    method dependencies
        [BooleanClassDefinition, type]!


    method selector
        "typecheck:" intern!


    method apply: args in: _
        let value = args second.
        value type is type
            ifFalse: { Error raise: "CPS type error! Wanted: {type}, got: {value} ({value type})" }.
        value!


    method returnType
        type!


    method inlineIn: aContinuation in: graph with: worklist
        (aContinuation args size is 2) assert: "TypecheckImpl#inlineIn:in:with".
        let apply = aContinuation target.
        let value = aContinuation args at: 2.
        let valueType = value type.
        let cc = apply target.

        -- If value has the correct type, we can eliminate
        -- the typecheck entirely.
        --
        -- Otherwise we propagate the type to cc.
        valueType is type
            ifTrue: { aContinuation removeArgs.
                      aContinuation addArgs: [value].
                      aContinuation target: cc }
            ifFalse: { (cc uses isOnly: apply)
                           => { cc propagateTypes: [type] } }.
        (Continuation includes: cc)
            ifTrue: { worklist pushAll: cc params first uses }!


    method emitOn: backend
        --
        backend emitTypecheck: self!
end


interface InlineMethodImpl
    is BuiltinMethodImpl


    method apply: args in: classDefinition
        let pattern = self inliner apply: args.
        let newRecv = pattern first.
        let newSelector = pattern second.
        (newRecv type :: ClassDefinition findMethod: newSelector)
            apply: ([newRecv]
                        append: (pattern
                                     from: 3
                                     to: pattern size))!


    method inlineIn: aContinuation in: graph with: worklist
        let apply = aContinuation target.
        let args = aContinuation args.
        let pattern = self inliner apply: args.
        let newRecv = pattern first.
        let newSelector = pattern second.
        let newMethod = graph ensureFindMethod: newSelector
                              for: newRecv.
        let newApply = graph application: newMethod
                             target: apply target.
        aContinuation target: newApply.
        aContinuation removeArgs.
        aContinuation addArgs: [newRecv].
        aContinuation addArgs: (pattern from: 3 to: pattern size).
        -- CLASS_OF is new
        worklist push: newMethod args first.
        -- FIND_METHOD is new
        worklist push: newMethod.
        -- APPLY is new
        worklist push: newApply.
        -- Continuation has changed.
        worklist push: aContinuation!
end


class IntegerPlusImpl {}
    is InlineMethodImpl

    method selector
        "+" intern!

    method inliner
        { |a b| [b, "addInteger:" intern, a] }!
end


class IntegerMulImpl {}
    is InlineMethodImpl

    method selector
        "*" intern!

    method inliner
        { |a b| [b, "mulInteger:" intern, a] }!
end


class IntegerMinusImpl {}
    is InlineMethodImpl

    method selector
        "-" intern!

    method inliner
        { |a b| [b, "subInteger:" intern, a] }!
end


class IntegerTruncateImpl {}
    is InlineMethodImpl

    method selector
        "//" intern!

    method inliner
        { |a b| [b, "truncateInteger:" intern, a] }!
end


interface PrimitiveInlineMethodImpl
    is BuiltinMethodImpl

    method apply: args in: _classDefinition
        let pattern = self primitiveInliner apply: args.
        self evalPattern: pattern!

    method inlineIn: aContinuation in: graph with: worklist
        let apply = aContinuation target.
        let pattern = self primitiveInliner apply: aContinuation args.
        let primop = self buildPattern: pattern in: graph with: worklist.
        -- Log println: "XXX: inline: {primop printName}".
        let cc = apply target.
        aContinuation removeArgs.
        aContinuation addArgs: [primop].
        aContinuation target: cc.
        cc propagateTypes: [primop type].
        worklist push: aContinuation!

    method evalPattern: pattern
        (Array includes: pattern)
            ifTrue: { let op = pattern first.
                      let args = pattern rest collect: { |each| self evalPattern: each }.
                      return op apply: args }
            ifFalse: { pattern }!

    method buildPattern: pattern in: graph with: worklist
        (Expression includes: pattern)
            ifTrue: { return pattern }.
        (Array includes: pattern)
            ifTrue: { let op = graph ensureOperation: pattern first
                                     args: (pattern rest
                                                collect: { |each|
                                                           self buildPattern: each
                                                                in: graph
                                                                with: worklist }).
                      worklist push: op.
                      return op }.
        -- Eg. "inline reference" to IntegerClassDefinition.
        (CpsValue includes: pattern)
            ifFalse: { Error raise: "Unexpected value in buildPattern: {pattern}" }.
        graph ensureConstant: pattern!
end


class IntegerAddIntegerImpl {}
    is PrimitiveInlineMethodImpl

    method selector
        "addInteger:" intern!


    method primitiveInliner
        { |a b|
          [MAKE_INSTANCE, IntegerClassDefinition,
           [ADDI, [DATUM_OF, a], [DATUM_OF, b]]] }!
end


class IntegerMulIntegerImpl {}
    is PrimitiveInlineMethodImpl

    method selector
        "mulInteger:" intern!


    method primitiveInliner
        { |a b|
          [MAKE_INSTANCE, IntegerClassDefinition,
           [IMUL, [DATUM_OF, a], [DATUM_OF, b]]] }!
end


class IntegerSubIntegerImpl {}
    is PrimitiveInlineMethodImpl

    method selector
        "subInteger:" intern!


    method primitiveInliner
        { |a b|
          [MAKE_INSTANCE, IntegerClassDefinition,
           [SUBI, [DATUM_OF, b], [DATUM_OF, a]]] }!
end


class IntegerTruncateIntegerImpl {}
    is PrimitiveInlineMethodImpl

    method selector
        "truncateInteger:" intern!


    method primitiveInliner
        { |a b|
          [MAKE_INSTANCE, IntegerClassDefinition,
           [IDIV, [DATUM_OF, b], [DATUM_OF, a]]] }!
end


class IfTrueIfFalseImpl { ifTrue ifFalse }
    is BuiltinMethodImpl

    method selector
        (ifTrue and: ifFalse)
            => { return "ifTrue:ifFalse:" intern }.
        ifTrue
            => { return "ifTrue:" intern }.
        ifFalse
            => { return "ifFalse:" intern }.
        Error raise: "Invalid IfTrueIfFalseImpl!"!

    method inlineIn: aContinuation in: graph with: worklist
        let lastArg = (ifTrue and: ifFalse)
                          ifTrue: { 3 }
                          ifFalse: { 2 }.
        (aContinuation args size is lastArg) assert: "IfTrueIfFalseImpl#inlineIn:in:with".
        let apply = aContinuation target :: Application.
        let args = aContinuation args.
        let cond = args at: 1.
        let thenCont = ifTrue
                           ifTrue: { (args at: 2) }
                           ifFalse: { let ret = graph makeVariable: "$ret".
                                      graph continuation: "$ifTrue"
                                            params: [ret]
                                            target: ret
                                            args: [graph ensureConstant: FalseDefinition] }.
        let elseCont = ifFalse
                           ifTrue: { (args at: lastArg) }
                           ifFalse: { let ret = graph makeVariable: "$ret".
                                      graph continuation: "$ifFalse"
                                            params: [ret]
                                            target: ret
                                            args: [graph ensureConstant: FalseDefinition] }.
        -- Need to change args before replacing target: otherwise old
        -- apply target would become unused and get flushed!
        aContinuation removeArgs.
        aContinuation addArgs: [apply target].
        aContinuation target: (graph select: cond
                                     then: thenCont
                                     else: elseCont).
        -- Log println: "INLINED IF".
        -- Log println: (CpsPrinter printToString: graph).
        False!
end


class WhileLoopImpl { selector while }
    is BuiltinMethodImpl

    direct method while: maybe
        self selector: ("while{maybe}:" intern)
             while: maybe!


    method inlineIn: aContinuation in: graph with: worklist
        (aContinuation args size is 2) assert: "WhileLoopImpl#inlineIn:in:with".
        let ignore1 = graph makeVariable: "$ignore".
        -- valueCont args will be patched with the branch
        let valueCont = graph continuation: "$loopTest"
                              params: [ignore1]
                              target: (aContinuation args at: 1)
                              args: [].
        let bodyCont = graph continuation: "$loopBody"
                             params: []
                             target: (aContinuation args at: 2)
                             args: [valueCont].
        -- Explicit loop exit continuation so we don't need to
        -- pass False as argument to selected continuation each time
        -- through the branch.
        let exitCont = graph continuation: "$loopExit"
                             params: []
                             target: (aContinuation target target)
                             args: [graph ensureConstant: FalseDefinition].
        let cond = graph makeVariable: "$cond".
        let thenElse = while
                           ifTrue: { [bodyCont, exitCont] }
                           ifFalse: { [exitCont, bodyCont] }.
        let branch = graph continuation: "$while{while}"
                           params: [cond]
                           target: (graph select: cond
                                          then: thenElse first
                                          else: thenElse second)
                           args: [].
        valueCont addArgs: [branch].
        let headCont = graph continuation: "$loopHead"
                             params: aContinuation params copy
                             target: valueCont
                             args: [graph ensureConstant: FalseDefinition].
        aContinuation removeArgs.
        aContinuation replaceUsesWith: headCont in: worklist.
        aContinuation target: INVALID_TARGET.
        aContinuation removeParams.
        worklist push: headCont.
        worklist push: valueCont.
        worklist push: bodyCont.
        worklist push: exitCont!
end


class MethodDictionary { home methods }
    is Object

    direct method new
        self home: False
             methods: Dictionary new!


    method displayString
        "#<MethodDictionary {home name}>"!


    method home: new
        home is False
            ifTrue: { home = new }
            ifFalse: { Error raise: "{self displayString} already has a home!" }!


    method size
        methods size!


    method at: selector
        methods at: selector!


    method at: selector ifNone: block
        methods at: selector ifNone: block!


    method put: aMethod at: selector
        methods put: aMethod at: selector!


    method reject: testBlock do: doBlock
        methods values sort
            do: { |value|
                  (testBlock value: value)
                      ifFalse: { doBlock value: value } }.
        False!


    method do: block
        methods values sort do: block!


    method do: eachBlock interleaving: betweenBlock
        methods values sort
            do: eachBlock interleaving: betweenBlock!

end


class ClassDefinition { name
                        hostClass
                        printName
                        ownClassDefinition
                        methodDictionary }
    is Object
    is CpsValue


    direct method name: name
        self
            name: name
            hostClass: False
            printName: #toString
            methods: []
            directMethods: []!


    direct method name: name methods: methods
        self
            name: name
            hostClass: False
            printName: #toString
            methods: methods
            directMethods: []!


    direct method name: name methods: methods directMethods: directMethods
        self
            name: name
            hostClass: False
            printName: #toString
            methods: methods
            directMethods: directMethods!


    direct method hostClass: hostClass methods: methods
        self
            name: hostClass name
            hostClass: hostClass
            printName: #toString
            methods: methods
            directMethods: []!


    direct method name: name hostClass: hostClass methods: methods
        self
            name: name
            hostClass: hostClass
            printName: #toString
            methods: methods
            directMethods: []!


    direct method name: name
                  hostClass: hostClass
                  printName: printName
                  methods: methods
                  directMethods: directMethods
        let instanceMethodDictionary = MethodDictionary new.
        let directMethodDictionary = MethodDictionary new.
        let ownClassDefinition = self name: "{name} class"
                                      hostClass: hostClass classOf
                                      printName: #toString
                                      ownClassDefinition: ClassClassDefinition
                                      methodDictionary: directMethodDictionary.
        let classDefinition = self name: name
                                   hostClass: hostClass
                                   printName: printName
                                   ownClassDefinition: ownClassDefinition
                                   methodDictionary: instanceMethodDictionary.

        instanceMethodDictionary home: classDefinition.
        directMethodDictionary home: ownClassDefinition.

        methods
            do: { |each| classDefinition addMethod: each }.
        classDefinition defaultInstanceMethodImpls
            do: { |each|
                  classDefinition addMethod: (BuiltinMethod new: (each for: classDefinition)) }.

        directMethods
            do: { |each| ownClassDefinition addMethod: each }.
        classDefinition defaultDirectMethodImpls
            do: { |each|
                  ownClassDefinition addMethod: (BuiltinMethod new: (each for: classDefinition)) }.

        classDefinition!


    method defaultInstanceMethodImpls
        [OpaqueIdentityImpl]!


    method defaultDirectMethodImpls
        self isPrimitive
            ifTrue: { [OpaqueIdentityImpl,
                       TypecheckImpl] }
            ifFalse: { [ConstructorImpl,
                        OpaqueIdentityImpl,
                        TypecheckImpl] }!


    method ownClassDefinition: new
        ownClassDefinition is False
            ifTrue: { ownClassDefinition = new }
            ifFalse: { Error raise: "{self} ownClassDefinition already set!" }!


    method addMethod: aMethod
        aMethod home: self.
        methodDictionary
            put: aMethod
            at: aMethod selector!


    method isPrimitive
        (hostClass is False) not!


    method printName
        name!


    method type
        ownClassDefinition!


    method hostValue
        hostClass is False
            ifTrue: { Error raise: "No host definition for {self}" }
            ifFalse: { hostClass }!


    method findMethod: name::CpsSelector
        methodDictionary at: name!


    method findMethod: name::CpsSelector ifNone: block
        methodDictionary at: name ifNone: block!


    method displayString
        hostClass is Class
            ifTrue: { "#<Class>" }
            ifFalse: { "#<Class {name}>" }!


    method toString
        name!


    method printName: instance
        printName sendTo: instance!


    method < other
        name < other name!
end


define ClassMethodDictionary
    let new = MethodDictionary new.
    new home: ClassDefinition.
    new!


class Datum { type value }
    is Object
    is CpsValue

    method toString
        -- Instances don't get an explicit marker of
        -- being such.
        "{value displayString}::Datum"!

    method printName
        self toString!

    method displayString
        self toString!

    method hostValue
        value!
end

class Instance { _class::ClassDefinition
                 _datum }
    is Object
    is CpsValue

    direct method class: aClass datum: aDatum
        self _class: aClass
             _datum: aDatum!

    method type
        _class!

    method hostValue
        _datum!

    method printName
        _class isPrimitive
            ifTrue: { _class printName: _datum }
            ifFalse: { "#<Instance {_class name}>" }!

    method displayString
        _class isPrimitive
            ifTrue: { _datum displayString }
            ifFalse: { "#<Instance {_class name}>" }!

    method toString
        self displayString!

    method == other
        (Instance includes: other)
            ifTrue: { _class is other type
                          ifTrue: { _datum == other hostValue } }!
end


define ClassClassDefinition
    let classMethodDictionary = MethodDictionary new.
    let new = (ClassDefinition name: "Class"
                               hostClass: Class
                               printName: #toString
                               ownClassDefinition: False
                               methodDictionary: classMethodDictionary).
    new ownClassDefinition: new.
    classMethodDictionary home: new.
    new defaultDirectMethodImpls
        do: { |each| new addMethod: (BuiltinMethod new: (each for: new)) }.
    new!


define BooleanClassDefinition
    (ClassDefinition
         hostClass: Boolean
         methods: [BuiltinMethod new: (IfTrueIfFalseImpl ifTrue: True ifFalse: True),
                   BuiltinMethod new: (IfTrueIfFalseImpl ifTrue: True ifFalse: False),
                   BuiltinMethod new: (IfTrueIfFalseImpl ifTrue: False ifFalse: True)])!


define FalseDefinition
    (Instance
         class: BooleanClassDefinition
         datum: False)!


define FunctionClassDefinition
    (ClassDefinition
         name: "Function"
         hostClass: Closure
         methods: [BuiltinMethod new: (WhileLoopImpl while: True),
                   BuiltinMethod new: (WhileLoopImpl while: False)])!


define IntegerClassDefinition
    (ClassDefinition
         hostClass: Integer
         methods: [BuiltinMethod new: IntegerPlusImpl new,
                   BuiltinMethod new: IntegerAddIntegerImpl new,
                   BuiltinMethod new: IntegerMinusImpl new,
                   BuiltinMethod new: IntegerSubIntegerImpl new,
                   BuiltinMethod new: IntegerMulImpl new,
                   BuiltinMethod new: IntegerMulIntegerImpl new,
                   BuiltinMethod new: IntegerTruncateImpl new,
                   BuiltinMethod new: IntegerTruncateIntegerImpl new,
                   BuiltinMethod new: OpaqueIdentityImpl new])!


define MethodClassDefinition
    (ClassDefinition
         name: "Method"
         methods: [])!


define SelectorClassDefinition
    (ClassDefinition
         name: "Selector"
         hostClass: CpsSelector
         printName: #printName
         methods: []
         directMethods: [])!


define StandardDefinitions
    [BooleanClassDefinition,
     IntegerClassDefinition]!


-- KLUDGE: Bootstrap evaluator is picky about order of definitions
extend CpsSelector
    method classDefinitionImpl
        SelectorClassDefinition!
end


class Set { dict }
    is Object

    direct method new
        self dict: Dictionary new!


    direct method with: node
        let new = self new.
        new add: node.
        new!


    method add: node
        let old = dict at: node.
        dict put: node at: node.
        old is False!


    method addAll: collection
        collection do: { |each| self add: each }!


    method remove: node
        dict remove: node!


    method collect: block
        dict keys collect: block!


    method includes: node
        ((dict at: node) is False) not!


    method singular
        dict size is 1
            ifTrue: { dict values first }!


    method size
        dict size!


    method isEmpty
        dict isEmpty!


    method isOnly: node
        node is self singular!


    method do: block
        dict values do: block!


    method doSorted: block
        self sorted do: block!


    method sorted
        dict values sort!
end


interface UseTracking
    method isUnused
        self uses isEmpty!


    method addUse: use
        self uses add: use!


    method removeUse: use
        self uses remove: use.
        self debugVerify: "#removeUse"!


    method replaceUsesWith: new
        self uses do: { |each|
                        each replaceUses: self with: new }.
        self flush!


    method replaceUsesWith: new in: worklist
        self uses do: { |each|
                        each replaceUses: self with: new.
                        worklist push: each }.
        self flush!


    method debugVerify: what
        DebugVerify
            ifTrue: { self verify: what }!


    required method uses
    required method replaceUses: expr1 with: expr2
end


class OpMap { list }
    is Object

    direct method new
        self list: List new!


    method kind: kind withArguments: args ifNonePut: block
        kind isFoldable
            ifTrue: { list do: { |each|
                                 each kind is kind
                                     => { (each args == args)
                                              => { return each } } } }.
        let new = block value.
        list push: new.
        new!


    method mergeDuplicates
        -- FIXME: O(N^2) with current OpMap!
        list do: { |each| self tryMerge: each }!


    method tryMerge: operation
        operation isFoldable
            ifFalse: { return False }.
        operation isUnused
            ifTrue: { return False }.
        list do: { |each| self tryMerge: operation with: each }!


    method tryMerge: op1 with: op2
        op1 is op2
            ifTrue: { return False }.
        op2 isUnused
            ifTrue: { return False }.
        op1 kind is op2 kind
            ifTrue: { op1 args == op2 args
                          ifTrue: { -- Doesn't use #replaceUsesWith: because
                                    -- there's no worklist or need for one.
                                    op2 uses do: { |each|
                                                   each replaceUses: op2 with: op1 } } }!


    method reject: block
        Self list: (list reject: block)!


    method select: block
        Self list: (list select: block)!


    method do: block
        list do: block!
end


class Worklist { list dict }
    is Object

    direct method new
        self list: List new
             dict: Dictionary new!


    method push: thing
        dict at: thing
             ifNonePut: { list push: thing.
                          thing }!


    method pushAll: aList
        aList do: { |each| self push: each }!


    method pop
        let thing = list pop.
        dict remove: thing.
        thing!


    method isEmpty
        list isEmpty!
end


define DebugVerify False!


interface Node
    method < other
        self id < other id!
    required method id
end


interface Expression
    is Object
    is UseTracking
    is Node


    method propagateTypes: _
        False!


    method isConstant
        False!


    method isOperation
        False!


    method simplifyIn: _ with: _
        False!


    method type
        False!


    method verify: _
        False!


    method toString
        "#<{self classOf name} {self printName}>"!


    required method printName
end


interface Childless
    method doChildren: _
        False!
end


class Constant { id::Integer
                 value::CpsValue
                 uses::Set }
    is Expression
    is Childless


    direct method id: id value: value
        (CpsValue includes: value)
            ifFalse: { Error raise: "Constant value not CpsValue: {value} :: {value classOf name}" }.
        self id: id
             value: value
             uses: Set new!


    method isConstant
        True!


    method returnType
        value returnType!


    method type
        value type!


    method printName
        value printName!


    method replaceUses: expr1 with: expr2
        Error raise: "Constant#replaceUses:with: is invalid"!


    method visitBy: visitor
        visitor visitConstant: self!


    method visitBy: visitor with: arg
        visitor visitConstant: self with: arg!
end


class Global { id::Integer
               name::String
               uses::Set
               definition }
    is Expression
    is Childless

    direct method id: id name: name
        self id: id
             name: name
             uses: Set new
             definition: False!


    method definition: new::ClassDefinition
        definition = new!


    method type
        definition is False
            ifTrue: { False }
            ifFalse: { definition type }!


    method replaceUses: expr1 with: expr2
        Error raise: "Global#replaceUses:with: is invalid"!


    method printName
        "{name}:Global"!


    method visitBy: visitor
        visitor visitGlobal: self!
end


interface ContinuationTarget
    is Node

    method doChildren: block
        self doSuccessors: block.
        self doValues: block!
end


interface AtomicContinuationTarget
    is ContinuationTarget
end


class InvalidTarget {}
    is Object
    is AtomicContinuationTarget
    is UseTracking

    method id
        0!

    method uses
        Set new!

    method replaceUses: _ with: _
        False!

    method printName
        "INVALID"!

    method doSuccessors: _
        False!

    method doValues: _
        False!

    method flush
        False!
end


define INVALID_TARGET InvalidTarget new!


class Variable { id::Integer
                 name::String
                 type
                 defs::Set
                 uses::Set }
    is Expression
    is Childless
    is AtomicContinuationTarget

    direct method id: id
        self id: id
             name: False
             type: False
             defs: Set new
             uses: Set new!


    direct method id: id name: name
        self id: id
             name: name
             type: False
             defs: Set new
             uses: Set new!


    direct method id: id name: name type: type
        self id: id
             name: name
             type: type
             defs: Set new
             uses: Set new!


    method renameIfSingleUse: new
        uses size <= 1
            => { name = new }.
        self!


    method addDef: def
        defs add: def!


    method addUse: use
        use is self
            ifFalse: { uses add: use }!


    method removeDef: def
        defs remove: def.
        (defs isEmpty and: uses isEmpty not)
            ifTrue: { Error raise: "{self} lost definition {def printName} while still being used by: {self uses collect: #printName}"}!


    method replaceUses: expr1 with: expr2
        Error raise: "Variable#replaceUses:with: is invalid"!


    method type: new
        (type is new)
            ifTrue: { return False }.
        (type is False)
            ifFalse: { Error raise: "Variable already has a type: {self}. Old={type}, New={new}" }.
        type = new!


    method type
        (ClassDefinition includes: type)
            ifTrue: { type }
            ifFalse: { (type is False) assert: "sanity check, type = {type} :: {type className}".
                       False }!


    method printName
        type is False
            ifTrue: { "{name}:{id}" }
            ifFalse: { "{name}::{type name}:{id}" }!


    method toString
        "#<Variable {self printName}>"!


    method visitBy: visitor
        visitor visitVariable: self!

    method visitBy: visitor with: arg
        visitor visitVariable: self with: arg!

    method flush
        self isUnused assert: "Variable must be unused to flush"!
end


interface OperationKind
    direct method isFoldable
        True!


    direct method returnType: _
        False!


    direct method type: _
        False!


    direct method simplify: op in: graph with: worklist
        self simplifyIfConstant: op in: graph with: worklist!


    direct method isConstant: op
        op args allSatisfy: #isConstant!


    direct method simplifyIfConstant: op in: graph with: worklist
        -- General-purpose constant-folding for ops. Must opt-out via
        -- #isFoldable, #isConstant:, or by specializing #simplify:in:with.
        (self isConstant: op)
            ifTrue: { let argVals = op args collect: #value.
                      let value = op kind apply: argVals.
                      let constant = graph ensureConstant: value.
                      op replaceUsesWith: constant in: worklist }!
end


class ADDI {}
    is OperationKind


    direct method name
        "addi"!


    direct method type: _
        IntegerClassDefinition!


    direct method visit: operation by: visitor
        visitor visitAddi: operation!


    direct method apply: args
        Datum type: IntegerClassDefinition
              value: (args first hostValue :: Integer +
                      args second hostValue :: Integer)!
end


class SUBI {}
    is OperationKind


    direct method name
        "subi"!


    direct method type: _
        IntegerClassDefinition!


    direct method visit: operation by: visitor
        visitor visitSubi: operation!


    direct method apply: args
        Datum type: IntegerClassDefinition
              value: (args first hostValue :: Integer -
                      args second hostValue :: Integer)!
end


class IMUL {}
    is OperationKind


    direct method name
        "imul"!


    direct method type: _
        IntegerClassDefinition!


    direct method visit: operation by: visitor
        visitor visitImul: operation!


    direct method apply: args
        Datum type: IntegerClassDefinition
              value: (args first hostValue :: Integer *
                      args second hostValue :: Integer)!
end


class IDIV {}
    is OperationKind


    direct method name
        "idiv"!


    direct method type: _
        IntegerClassDefinition!


    direct method visit: operation by: visitor
        visitor visitIdiv: operation!

    direct method isConstant: op
        -- If the second argument is zero, then this is not constant,
        -- but an error.
        (op args allSatisfy: #isConstant)
            ifTrue: { (op args second value hostValue is 0) not }
            ifFalse: { False }!

    direct method apply: args
        Datum type: IntegerClassDefinition
              value: (args first hostValue :: Integer /
                      args second hostValue :: Integer) :: Integer!
end


extend Object
    method className
        self classOf name!
end


class CLASS_OF {}
    is OperationKind

    direct method name
        "classOf"!


    direct method apply: args
        args first type :: ClassDefinition!


    direct method simplify: operation in: graph with: worklist
        -- This is slightly more powerful than the general-purpose
        -- constant folding.
        let recv = operation args first.
        let type = recv type.
        -- Log println: "\nXXX: CLASS_OF {recv toString} => {type}".
        (ClassDefinition includes: type)
            => { let const = graph ensureConstant: type.
                 operation replaceUsesWith: const in: worklist }!


    direct method visit: operation by: visitor
        visitor visitClassOf: operation!
end


class DATUM_OF {}
    is OperationKind

    direct method name
        "datumOf"!

    direct method apply: args
        Datum type: args first type
              value: args first hostValue!

    direct method simplify: op in: graph with: worklist
        let arg = op args first.
        (Operation includes: arg)
            => { arg kind is MAKE_INSTANCE
                     => { let datum = arg args second.
                          return op replaceUsesWith: datum in: worklist } }.
        self simplifyIfConstant: op in: graph with: worklist!

    direct method visit: operation by: visitor
        visitor visitDatumOf: operation!
end


class IS_EQ {}
    is OperationKind

    direct method name
        "isEq"!

    direct method apply: args
        Datum type: BooleanClassDefinition
              value: (args first hostValue is args second hostValue)!

    direct method type: _
        BooleanClassDefinition!

    direct method visit: operation by: visitor
        visitor visitIsEq: operation!

    direct method simplify: op in: graph with: worklist
        op isConstant
            ifTrue: { return self simplifyIfConstant: op in: graph with: worklist }.
        -- 1. Unknown types involved, cannot simplify.
        Log println: "XXX types of: {op args collect: #toString}".
        let types = op args collect: #type.
        (types allSatisfy: { |each| ClassDefinition includes: each })
            ifFalse: { return False }.
        -- 2. Divergent types, always false.
        types first is types second
          ifFalse: { let const = graph ensureConstant: FalseDefinition.
                     return op replaceUsesWith: const in: worklist }.
        -- 3. Any MAKE_INSTANCEs in arguments can be simplified to
        -- their datums.
        let simplified = False.
        let newArgs = op args collect: { |each|
                                         each isOperation
                                             ifTrue: { each kind is MAKE_INSTANCE
                                                           ifTrue: { simplified = True.
                                                                     each args second }
                                                           ifFalse: { each  }}
                                             ifFalse: { each }}.
        simplified
            ifTrue: { Log println: "SIMPLIFIED IS: {op args collect: #toString} --> {newArgs collect: #toString}".
                      let newOp = graph ensureOperation: IS_EQ args: newArgs.
                      return op replaceUsesWith: newOp in: worklist }!
end


class FIND_METHOD {}
    is OperationKind

    direct method name
        "findMethod"!


    direct method apply: args
        args first findMethod: args second
                   ifNone: { Error raise: "Method not found: {args first}#{args second name}" }!


    direct method visit: operation by: visitor
        visitor visitFindMethod: operation!


    direct method visit: operation by: visitor with: arg
        visitor visitFindMethod: operation with: arg!
end


class INVALID {}
    is OperationKind

    direct method name
        "invalid"!
end


class MAKE_INSTANCE {}
    is OperationKind

    direct method name
        "makeInstance"!


    direct method type: operation
        let classDef = operation args first.
        classDef isConstant
            ifTrue: { classDef value }!


    direct method apply: args
        Instance class: args first
                 datum: args second hostValue!


    direct method visit: operation by: visitor
        visitor visitMakeInstance: operation!
end


class Operation { id::Integer
                  kind
                  args::Array
                  uses::Set }
    is Expression

    direct method id: id kind: kind args: args
        let new = self id: id
                       kind: kind
                       args: args
                       uses: Set new.
        args do: { |each| each addUse: new }.
        new!


    method type
        kind type: self!


    method returnType
        kind returnType: self!


    method isOperation
        True!


    method isFoldable
        kind isFoldable!


    method simplifyIn: graph with: worklist
        kind simplify: self in: graph with: worklist!


    method doChildren: block
        args do: block!


    method verify: what
        (args allSatisfy: { |each| each uses includes: self })
            assert: "{self printName} should use its args: {args collect: #printName}"!


    method printName
        StringOutput
            with: { |out|
                    out
                        ; print: kind name
                        ; print: ":"
                        ; print: id
                        ; print: "(".
                    args
                        do: { |each| out print: each printName }
                        interleaving: { out print: ", " }.
                    out print: ")" }!


    method flush
        self isUnused assert: "Operation must be unused to flush".
        args do: { |each| each removeUse: self }.
        args = [].
        kind = INVALID!


    method replaceUses: expr1 with: expr2
        expr2 addUse: self.
        args = args replace: expr1 with: expr2.
        expr1 removeUse: self.
        self debugVerify: "Operation#replaceUses:"!


    method visitBy: visitor
        visitor visitOperation: self!


    method visitBy: visitor with: arg
        visitor visitOperation: self with: arg!
end


class Continuation { id::Integer
                     name
                     params::Array
                     target
                     args::Array
                     uses::Set }
    is Expression
    is AtomicContinuationTarget

    direct method id: id name: name params: params target: target args: args
        let new = self id: id
                       name: name
                       params: params
                       target: target
                       args: args asArray
                       uses: Set new.
        params do: { |each| each addDef: new }.
        target is False
            ifFalse: {target addUse: new }.
        args do: { |each| each addUse: new }.
        new!


    method verify: what
        (target is INVALID_TARGET)
            ifFalse: { (target uses includes: self)
                           ifFalse: { Error raise: "{self} does not use its target: {target} ({what})" } }.
        let badParams = params reject: { |each| each defs includes: self }.
        badParams isEmpty assert: "Continuation should define its params".
        let badArgs = args reject: { |each| each uses includes: self }.
        badArgs isEmpty assert: "Continuation should use its args".
        self!


    method renameIfSingleUse: new
        uses size <= 1
            => { name = new }.
        self!


    method name: new
        name = new!


    method type
        FunctionClassDefinition!


    method doSuccessors: block
        (AtomicContinuationTarget includes: target)
            ifTrue: { block value: target }
            ifFalse: { target doSuccessors: block }!


    method doValues: block
        (AtomicContinuationTarget includes: target)
            ifFalse: { target doValues: block }.
        args do: block!


    method propagateTypes: types
        params with: types
               do: { |param type| param type: type }!


    method propagateTargetType
        (Constant includes: target)
            => { let value = target value .
                 (MethodDefinition includes: value)
                     => { args last propagateTypes: [value returnType] } }!


    method simplifyIn: _ with: worklist
        { self hasUniqueTarget }
            whileTrue: { self inlineUniqueTargetWith: worklist }.
        -- The above zips up chains of local continuations
        -- nicely, which in turn leaves us with a Select
        -- or Application here, with a good chance of constant
        -- arguments thanks to the inlinining.
        ---
        (Continuation includes: target)
            ifFalse: { target simplifyIn: graph }.
        (args select: #isOperation)
            do: { |each| each simplifyIn: graph }.
        ---
        self!


    method hasUniqueTarget
        (Continuation includes: target)
            ifTrue: { target uses isOnly: self }!


    method inlineUniqueTargetWith: worklist
        self args
            with: target params
            do: { |arg param|
                  param replaceUsesWith: arg in: worklist }.
        self replaceArgsFrom: target.
        target unlinkWith: worklist.
        self debugVerify: "Continuation#inlineUniqueTarget"!


    method replaceUses: expr1 with: expr2
        expr2 addUse: self.
        target is expr1
            ifTrue: { target = expr2 }.
        args replace: expr1 with: expr2.
        expr1 removeUse: self.
        self debugVerify: "Continuation#replaceUses:with:"!



    method replaceArgsFrom: other::Continuation
        -- This is more convenient than #args:, since
        -- we usually want to copy the array!
        args do: { |each| each removeUse: self }.
        args = other args copy.
        args do: { |each| each addUse: self }.
        self debugVerify: "Continuation#replaceArgsFrom:"!


    method removeParams
        params do: { |each| each removeDef: self }.
        params = [].
        self debugVerify: "Continuation#removeParams"!


    method removeArgs
        args do: { |each| each removeUse: self }.
        args = [].
        self debugVerify: "Continuation#removeArgs"!


    method addParams: new
        new do: { |each| each addDef: self }.
        params = params append: new.
        self debugVerify: "Continuation#addParams:"!


    method addArgs: new
        new do: { |each| each addUse: self }.
        args = args append: new.
        self debugVerify: "Continuation#addArgs:"!


    method prependArgs: new
        new do: { |each| each addUse: self }.
        args = new append: args.
        self debugVerify: "Continuation#prependArgs:"!


    method target: new
        -- No copy needed here
        let old = target.
        target removeUse: self.
        target = new.
        target addUse: self.
        old isUnused
            ifTrue: { old flush }.
        self debugVerify: "Continuation#target:"!


    method unlinkWith: worklist
        self removeArgs.
        self replaceUsesWith: target in: worklist.
        self target: INVALID_TARGET.
        -- args and target may use params, so need to remove last!
        self removeParams.
        self debugVerify: "Continuation#unlinkWith:"!


    method flush
        self isUnused assert: "Continuation must be unused to flush".
        self removeArgs.
        self target: INVALID_TARGET.
        -- args and target may use params, so need to remove last!
        self removeParams!


    method printName
        name is False
            ifTrue: { "$cont:{id}" }
            ifFalse: { "{name}:{id}" }!


    method toString
        StringOutput
            with: { |out|
                    out print: "#<Continuation ".
                    self printTo: out.
                    out print: ">" }!


    method displayString
        "#<Continuation {self printName}>"!


    method printTo: output
        self printTo: output pretty: False!


    method prettyPrintTo: output
        self printTo: output pretty: True!


    method printTo: output pretty: pretty
        output
            ; print: self printName
            ; print: "(".
        params
            do: { |each| output print: each printName }
            interleaving: { output print: ", " }.
        output print: ")".
        pretty
            ifTrue: { output println: ":".
                      output print: "    " }
            ifFalse: { output print: " -> " }.
        output
            ; print: target printName
            ; print: "(".
        args
            do: { |arg| output print: arg printName }
            interleaving: { output print: ", " }.
        output print: ")".
        pretty
            ifTrue: { output newline }!


    method visitBy: visitor
        visitor visitContinuation: self!


    method visitBy: visitor with: arg
        visitor visitContinuation: self with: arg!

end


class Application { id::Integer
                    target::AtomicContinuationTarget
                    function
                    uses::Set }
    is Object
    is ContinuationTarget
    is UseTracking

    direct method id: id target: target function: function
        let new = self id: id
                       target: target
                       function: function
                       uses: Set new.
        target addUse: new.
        function
            => { function addUse: new }.
        new!


    method flush
        self isUnused assert: "Application must be unused to flush".
        target removeUse: self.
        target = INVALID_TARGET.
        function removeUse: self.
        function = False!


    method target: new
        target removeUse: self.
        target = new.
        target addUse: self!


    method function: new
        function
            => { function removeUse: self }.
        function = new.
        function addUse: self!


    method doDeps: block
        block value: target.
        block value: function!


    method doValues: block
        block value: function!


    method replaceUses: node1 with: node2
        node1 removeUse: self.
        target is node1
            => { target = node2 }.
        function is node1
            => { function = node2 }.
        node2 addUse: self!


    method printName
        "apply:{id}({target printName}, {function printName})"!


    method simplifyIn: graph with: worklist
        function simplifyIn: graph with: worklist!


    method toString
        self printName!


    method visitBy: visitor
        visitor visitApplication: self!

    method visitBy: visitor with: arg
        visitor visitApplication: self with: arg!

    method doSuccessors: block
        block value: target!
end


class Select { id::Integer
               cond::Expression
               then::AtomicContinuationTarget
               else::AtomicContinuationTarget
               uses::Set }
    is Object
    is ContinuationTarget
    is UseTracking


    method toString
        "#<Select cond: {cond printName} then: {then printName} else: {else printName}>"!


    direct method id: id cond: cond then: then else: else
        let new = self id: id
                       cond: cond
                       then: then
                       else: else
                       uses: Set new.
        cond addUse: new.
        then addUse: new.
        else addUse: new.
        new!


    method printName
        "select:{id}({cond printName}, {then printName}, {else printName})"!


    method replaceUses: node1 with: node2
        node1 removeUse: self.
        cond is node1
            => { cond = node2 }.
        then is node1
            => { then = node2 }.
        else is node1
            => { else = node2 }.
        node2 addUse: self!


    method simplifyIn: graph with: worklist
        uses singular
            => { |use|
                 ((self hasUniqueTarget: then) and: (self hasUniqueTarget: else))
                     ifTrue: { -- Log println: "SIMPLIFY SELECT".
                               -- Log println: (CpsPrinter printToString: graph).
                               self propagateArgsFrom: use to: then in: worklist.
                               self propagateArgsFrom: use to: else in: worklist.
                               use removeArgs
                               -- Log println: "===>".
                               -- Log println: (CpsPrinter printToString: graph)
                               }} !


    method hasUniqueTarget: node
        (Continuation includes: node)
            ifTrue: { node uses isOnly: self }!


    method propagateArgsFrom: cont1 to: cont2 in: worklist
        cont1 args
            with: cont2 params
            do: { |arg param|
                  param replaceUsesWith: arg in: worklist }.
        cont2 removeParams!


    method visitBy: visitor
        visitor visitSelect: self!


    method visitBy: visitor with: arg
        visitor visitSelect: self with: arg!


    method doSuccessors: block
        block value: then.
        block value: else!


    method doValues: block
        block value: cond!
end


class PreOrder { seen block }
    direct method for: entry do: block
        (self seen: Set new block: block)
            traverse: entry!

    method traverse: cont
        (Continuation includes: cont)
            ifFalse: { return False }.
        (seen includes: cont)
            ifTrue: { return False }.
        seen add: cont.
        block value: cont.
        cont doSuccessors: { |each| self traverse: each }!
end


class PostOrder { seen block }
    direct method for: entry do: block
        (self seen: Set new
              block: block)
            traverse: entry!

    method traverse: cont
        (Continuation includes: cont)
            ifFalse: { return False }.
        (seen includes: cont)
            ifTrue: { return False }.
        seen add: cont.
        cont doSuccessors: { |each| self traverse: each }.
        block value: cont!
end


class ReversePostOrder { seen stack }
    direct method for: entry do: block
        let stack = List new.
        (self seen: Set new stack: stack)
            traverse: entry.
        stack reverse do: block!

    method traverse: cont
        (Continuation includes: cont)
            ifFalse: { return False }.
        (seen includes: cont)
            ifTrue: { return False }.
        seen add: cont.
        cont doSuccessors: { |each| self traverse: each }.
        stack push: cont!
end


class CpsGraph { entry::Continuation
                 exit::Variable
                 lastId::Integer
                 operations::OpMap
                 constants::Dictionary
                 globals::Dictionary -- XXX: why here???
                 continuations::List
                 inlined::Dictionary
                 receiver -- False or Variable
                 home     -- False or Method
               }
    is Expression

    direct method forExpr
        -- ID 1 is reserved for graph.
        --
        -- Entry node just binds the exit continuation,
        -- target patched in later.
        let exit = Variable id: 3
                            name: "$return".
        let entry = Continuation id: 2
                                 name: "$entry"
                                 params: [exit]
                                 target: INVALID_TARGET
                                 args: [].
        let graph = self
                        entry: entry
                        exit: exit
                        lastId: 3
                        operations: OpMap new
                        constants: Dictionary new
                        globals: Dictionary new
                        continuations: (List with: entry)
                        inlined: Dictionary new
                        receiver: False
                        home: False.
        exit addUse: exit.
        entry addUse: graph.
        graph!


    direct method forMethod: aMethod
        -- ID 1 is reserved for graph.
        --
        -- Entry node just binds the exit continuation and
        -- receiver, target patched in later.
        let receiver = Variable id: 4
                                name: "$receiver"
                                type: aMethod home.
        let exit = Variable id: 3
                            name: "$return".
        let entry = Continuation id: 2
                                 name: "$entry"
                                 params: [exit, receiver]
                                 target: INVALID_TARGET
                                 args: [].
        let selectors = Dictionary new.
        let graph = self
                        entry: entry
                        exit: exit
                        lastId: 4
                        operations: OpMap new
                        constants: Dictionary new
                        globals: Dictionary new
                        continuations: (List with: entry)
                        inlined: Dictionary new
                        receiver: receiver
                        home: aMethod.
        exit addUse: exit.
        entry addUse: graph.
        graph!


    method name: newName
        name = newName!


    method id
        1!


    method uses
        Set new!


    method allowInline: graph
        -- Allow inlining each graph only once. A primitive measure against
        -- recursive inlining.
        inlined at: graph
                ifNone: { inlined at: graph put: False.
                          True }!


    method displayString
        home is False
            ifTrue: { "#<CpsGraph>" }
            ifFalse: { "#<CpsGraph {home home name}#{home name}>" }!


    method printName
        "graph:1"!


    method replaceUses: expr1 with: expr2
        expr1 removeUse: self.
        exit is expr1
            ifTrue: { exit = expr2 }.
        entry is expr1
            ifTrue: { entry = expr2 }.
        expr2 addUse: self!


    method cleanup
        operations mergeDuplicates.
        continuations do: { |each| each verify: "CpsGrapg#cleanup" }.
        let worklist = Worklist new.
        worklist pushAll: (continuations select: #isUnused).
        worklist pushAll: (operations select: #isUnused).
        { worklist isEmpty }
            whileFalse: { let expr = worklist pop.
                          -- Output debug println: "flushing: {expr printName}".
                          expr doChildren: { |each|
                                                   each removeUse: expr.
                                                   each isUnused
                                                       ifTrue: { worklist push: each }} }.
        continuations = continuations reject: #isUnused.
        operations = operations reject: #isUnused!


    method doNodes: block
        continuations do: block.
        operations do: block!


    method variables
        let vars = Set new.
        continuations do: { |each| vars addAll: each params }.
        vars!


    method entry: target
        entry target: target.
        self cleanup.
        -- Log println: "\nGRAPH:\n{CpsPrinter printToString: self}".
        self!


    method optimize
        CpsOptimizer optimize: self with: LocalOptimizationPolicy.
        self cleanup.
        self!


    method dependencies
        globals values collect: #definition!


    method continuation: name params: params target: target args: args
        let cont = Continuation id: self nextId
                                name: name
                                params: params
                                target: target
                                args: args.
        continuations push: cont.
        cont!


    method makeVariable: name
        Variable
            id: self nextId
            name: name!


    method makeVariable: name type: type
        Variable
            id: self nextId
            name: name
            type: type!


    method ensureConstant: value
        constants
            at: value
            ifNonePut: { Constant
                             id: self nextId
                             value: value }!


    method ensureGlobal: name
        globals
            at: name
            ifNonePut: { Global
                             id: self nextId
                             name: name }!


    method addDefinition: definition
        let global = self ensureGlobal: definition name.
        global definition: definition!


    method ensureOperation: kind args: args
        operations
            kind: kind
            withArguments: args
            ifNonePut: { Operation
                             id: self nextId
                             kind: kind
                             args: args }!

    method application: function target: continuation
        -- FIXME: hashcons
        Application
            id: self nextId
            target: continuation
            function: function!


    method select: cond then: then else: else
        -- FIXME: hashcons
        Select
            id: self nextId
            cond: cond
            then: then
            else: else!


    method classOf: recv
        self ensureOperation: CLASS_OF
             args: [recv]!


    method ensureFindMethod: selector for: recv
        let selector = self ensureConstant: selector::CpsSelector.
        let classOf = self classOf: recv.
        self ensureOperation: FIND_METHOD
             args: [classOf, selector]!


    method nextId
        lastId = lastId + 1!


    method apply: args
        CpsEvaluator eval: self with: args!


    method emitOn: backend
        backend emitCpsGraph: self!
end


class CpsConverter { graph var next classMap namespace }

    direct method makeConverter: graph classDefinitions: defs in: namespace
        -- Add definitions to the graph.
        defs do: { |each| graph addDefinition: each }.
        -- Create a map from host classes to definitions,
        -- used for conversion of literals.
        let classMap = Dictionary new.
        defs
            do: { |each|
                  let hostClass = each hostClass.
                  hostClass is False
                      ifFalse: { classMap put: each at: hostClass } }.
        self graph: graph
             var: False
             next: False
             classMap: classMap
             namespace: namespace!


    direct method convertExpr: syntax with: defs in: namespace
        let graph = CpsGraph forExpr.
        let converter = self makeConverter: graph
                             classDefinitions: defs
                             in: namespace.
        graph entry: (syntax visitBy: converter
                             with: graph exit).
        graph optimize!


    direct method convertMethod: syntax as: aMethod with: defs in: namespace
        let graph = CpsGraph forMethod: aMethod.
        let converter = self makeConverter: graph
                             classDefinitions: defs
                             in: namespace.
        syntax signature parameters
            do: { |each|
                  converter = converter
                      convertMethodParameter: each
                      in: graph }.
        graph entry: (syntax body visitBy: converter
                                  with: graph exit).
        aMethod cps: graph optimize!


    direct method userMethodFor: syntax in: namespace
        UserMethod
            selector: (namespace intern: syntax selector name)!


    direct method convertClass: aClass with: defs in: namespace
        let newClass = ClassDefinition name: aClass name.
        let newDefs = defs append: [newClass].
        -- First we add placeholder methods, so that all methods
        -- can be immediately resolved to each other.
        let userMethods =  aClass instanceMethods
                              collect: { |each|
                                         let m = self userMethodFor: each in: namespace.
                                         newClass addMethod: m.
                                         m }.
        let ownClass = newClass ownClassDefinition.
        let directMethods = aClass directMethods
                                collect: { |each|
                                           let m = self userMethodFor: each in: namespace.
                                           ownClass addMethod: m.
                                           m }.
        -- Then as actually convert all methods.
        aClass instanceMethods
            with: userMethods
            do: { |syntax userMethod|
                  self convertMethod: syntax
                       as: userMethod
                       with: newDefs
                       in: namespace }.
        aClass directMethods
            with: directMethods
            do: { |syntax userMethod|
                  self convertMethod: syntax
                       as: userMethod
                       with: newDefs
                       in: namespace }.
        newClass methodDictionary
            reject: #isStandard
            do: { |each|
                  CpsOptimizer optimize: each cps
                               with: GlobalOptimizationPolicy }.
        ownClass methodDictionary
            reject: #isStandard
            do: { |each|
                  CpsOptimizer optimize: each cps
                               with: GlobalOptimizationPolicy }.
        newClass!



    method convertMethodParameter: syntax in: graph
        let var = syntax type is Any
                      ifTrue: { graph makeVariable: syntax name }
                      ifFalse: { graph makeVariable: syntax name
                                       type: (syntax type visitBy: self)
                                                 definition }.
        graph entry addParams: [var].
        self bindVariable: var!


    method bindVariable: var
        CpsConverter
            graph: graph
            var: var
            next: self
            classMap: classMap
            namespace: namespace!


    method bindVariables: vars
        let converter = self.
        vars do: { |each|
                   converter = converter bindVariable: each }.
        converter!


    method findBinding: name
        var is False
            ifTrue: { return graph ensureGlobal: name }.
        var name == name
            ifTrue: { var }
            ifFalse: { self next findBinding: name }!


    method findLiteralClass: value
        classMap
            at: value classOf
            ifNone: { Error raise: "No class for literal {value}::{value classOf name}. Available classes: {classMap keys collect: #name}" }!


    method literalRef: value target: target
        let classDef = self findLiteralClass: value.
        let instance = Instance
                           class: classDef
                           datum: value.
        let const = graph ensureConstant: instance.
        graph continuation: "$const_ref"
              params: []
              target: target
              args: [const]!


    method visitBlock: syntax with: cc
        let blockReturn = graph makeVariable: "$ret".
        let blockVars = syntax parameters
                            collect: { |each| graph makeVariable: each name }.
        let block = syntax body
                        visitBy: (self bindVariables: blockVars)
                        with: blockReturn.
        block name: "$block".
        block addParams: (blockVars append: [blockReturn]).
        graph continuation: "$makeClosure"
              params: []
              target: cc
              args: [block]!


    method visitLet: syntax with: cc
        let var = graph makeVariable: syntax variable name.
        let body = syntax body
                       visitBy: (self bindVariable: var)
                       with: cc.
        let bind = graph continuation: "$let"
                         params: [var]
                         target: body
                         args: [].
        syntax value visitBy: self
                     with: bind!


    method visitLiteral: syntax with: cc
        self literalRef: syntax value
             target: cc!


    method visitSelector: syntax with: cc
        self literalRef: (namespace intern: syntax name)
             target: cc!


    method visitParens: syntax with: cc
        syntax body visitBy: self with: cc!


    method visitReturn: syntax with: _
        syntax value visitBy: self with: graph exit!


    method visitSelfInstance: _ with: cc
        graph continuation: "$self"
              params: []
              target: cc
              args: [graph receiver]!


    method visitIs: anIs with: cc
        let left = graph makeVariable: "$left".
        let right = graph makeVariable: "$right".
        let isOperation = graph ensureOperation: IS_EQ
                                args: [left, right].
        let isComparison = graph continuation: "$is"
                                 params: []
                                 target: cc
                                 args: [isOperation].
        let bindRight = graph continuation: "$bind_right"
                              params: [right]
                              target: isComparison
                              args: [].
        let valueRight = anIs right visitBy: self with: bindRight.
        let bindLeft = graph continuation: "$bind_left"
                             params: [left]
                             target: valueRight
                             args: [].
        anIs left visitBy: self with: bindLeft!


    method visitSend: syntax with: cc
        let recv = graph makeVariable: "$recv".
        let args = syntax arguments
                       collect: { |a| graph makeVariable: "$arg" }
                       as: Array.
        let selector = namespace intern: syntax selector name.
        let methodFunction = graph ensureFindMethod: selector
                                   for: recv.
        let next = graph continuation: "$send"
                         params: []
                         target: (graph application: methodFunction
                                        target: cc)
                         args: ([recv] append: args).
        syntax arguments reverse
            with: args reverse
            do: { |syntaxArg var|
                  let bind = graph continuation: "$bind_arg"
                                   params: [var]
                                   target: next
                                   args: [].
                  next = syntaxArg visitBy: self with: bind }.
        let recvBind = graph continuation: "$bind_recv"
                             params: [recv]
                             target: next
                             args: [].
        syntax receiver visitBy: self
                        with: recvBind!


    method visitSeq: syntax with: cc
        let then = syntax then visitBy: self with: cc.
        let discard = graph continuation: "$seq"
                            params: [graph makeVariable: "$ignore"]
                            target: then
                            args: [].
        syntax first visitBy: self
                     with: discard!


    method visitValueTypeDeclaration: syntax with: cc
        let value = graph makeVariable: "$value".
        let type = graph makeVariable: "$type".
        let typecheck = graph ensureFindMethod: "typecheck:" intern for: type.
        let checkCont = graph continuation: "$typecheck"
                              params: [type]
                              target: (graph application: typecheck
                                             target: cc)
                              args: [type, value].
        let typeCont = syntax type visitBy: self with: checkCont.
        let bindValue = graph continuation: "$bind"
                              params: [value]
                              target: typeCont
                              args: [].
        syntax value visitBy: self with: bindValue!


    method visitVariable: syntax
        self findBinding: syntax name!


    method visitVariable: syntax with: cc
        let var  =self findBinding: syntax name.
        (Continuation includes: cc)
            => { cc isUnused
                     => { cc params first replaceUsesWith: var.
                          cc removeParams.
                          return cc } }.
        graph continuation: "$var_ref"
              params: []
              target: cc
              args: [var]!
end



class OptimizationPolicy { inlineUserMethods }
    method shouldInline: aMethod
        (BuiltinMethod includes: aMethod)
            ifTrue: { return True }.
        inlineUserMethods!
end


define LocalOptimizationPolicy
    (OptimizationPolicy
         inlineUserMethods: False)!


define GlobalOptimizationPolicy
    (OptimizationPolicy
         inlineUserMethods: True)!


class CpsOptimizer { worklist graph policy }

    direct method optimize: graph with: policy
        let worklist = Worklist new.
        graph doNodes: { |each| worklist push: each }.
        (self worklist: worklist graph: graph policy: policy)
            optimize.
        graph cleanup!


    method optimize
        { worklist isEmpty }
            whileFalse: { let node = worklist pop.
                          -- Was node eliminated while it was on the worklist?
                          node isUnused
                              -- ifTrue: { Log println: "DEAD: {node}" }
                              ifFalse: { node visitBy: self } }!


    method visitContinuation: aCont
        -- Do strictly local simplifications: zipping up chains of
        -- of known continuations into a single one, etc.
        aCont simplifyIn: graph with: worklist.
        -- If target is an operation, let its optimizers kick in. In case
        -- of APPLY the continuation is the user of the arguments, but the
        -- apply is
        let target = aCont target.
        (Application includes: target)
            => { worklist push: target }!


    method visitOperation: anOperation
        anOperation kind simplify: anOperation in: graph with: worklist!


    method visitApplication: anApply
        let func = anApply function.
        let target = anApply target.
        -- Propagate return type for unique uses
        (target uses isOnly: anApply)
            ifTrue: { func returnType
                          => { |returnType|
                               target propagateTypes: [returnType].
                               worklist push: target } }.
        -- Lower constant method functions when possible.
        (Constant includes: func)
            ifTrue: { let value = func value.
                      (policy shouldInline: value)
                          => { anApply uses
                                   do: { |each::Continuation|
                                         value inlineIn: each in: graph with: worklist } } }!


    method visitSelect: aSelect
        aSelect simplifyIn: graph with: worklist!


    method visitTypeInfo: _
        False!


    method visitGlobal: _
        False!


    method visitVariable: _
        False!


    method visitConstant: _
        False!
end


class CpsCopier { graph copied }

    direct method copy: cps to: graph
        cps visitBy: (self graph: graph
                           copied: Dictionary new)!


    method visitAll: seq
        seq collect: { |each| each visitBy: self } as: Array!


    method visitContinuation: aCont
        -- Continuations can be in cycles, so we need to be
        -- careful and put in the copy of the continuation
        -- before copying its children.
        copied
            at: aCont
            ifNone: { let new = graph continuation: aCont name
                                      params: []
                                      target: INVALID_TARGET
                                      args: [].
                       copied put: new at: aCont.
                       new addParams: (self visitAll: aCont params).
                       new target: (aCont target visitBy: self).
                       new addArgs: (self visitAll: aCont args).
                       new }!


    method visitVariable: aVar
        copied
            at: aVar
            ifNonePut: { graph makeVariable: aVar name
                               type: aVar type }!


    method visitOperation: anOp
        copied
            at: anOp
            ifNonePut: { graph ensureOperation: anOp kind
                               args: (self visitAll: anOp args) }!


    method visitConstant: aConstant
        copied
            at: aConstant
            ifNonePut: { graph ensureConstant: aConstant value }!


    method visitSelect: aSelect
        copied
            at: aSelect
            ifNonePut: { graph
                             select: (aSelect cond visitBy: self)
                             then: (aSelect then visitBy: self)
                             else: (aSelect else visitBy: self) }!


    method visitApplication: anApp
        -- Same care as with continuation applies here!
        copied
            at: anApp
            ifNone: { let new = graph application: False
                                      target: INVALID_TARGET.
                       copied put: new at: anApp.
                       new target: (anApp target visitBy: self).
                       new function: (anApp function visitBy: self).
                       new }!

end


class CpsEvaluator { bound values parent }

    direct method new
        self bound: []
             values: []
             parent: False!


    direct method eval: cps
        -- Log println: (CpsPrinter printToString: cps).
        cps entry
            visitBy: (CpsEvaluator new)
            with: [{ |value| return value }]!


    direct method eval: cps with: args
        -- Log println: (CpsPrinter printToString: cps).
        cps entry
            visitBy: (CpsEvaluator new)
            with: ([{ |value| return value }] append: args)!


    method bind: params to: args
        CpsEvaluator
            bound: params
            values: args
            parent: self!


    method visitAll: seq
        seq collect: { |each| each visitBy: self }!


    method visitContinuation: aCont with: args
        let params = aCont params.
        params size is args size
            ifFalse: { Error raise: "Argument count mismatch, wanted: {aCont params collect: #printName}, got {args collect: #toString}" }.
        let eval = self bind: params
                        to: args.
        aCont target
            visitBy: eval
            with: (eval visitAll: aCont args)!


    method visitVariable: aVar with: args
        (self visitVariable: aVar)
            apply: args!


    method visitVariable: var
        let index = bound positionOf: var.
        index is False
            ifTrue: { parent is False
                          ifTrue: { Error raise: "Unbound variable: {var printName}" }.
                      parent visitVariable: var }
            ifFalse: { values at: index }!


    method visitApplication: app with: args
        app target
            visitBy: self
            with: [(app function visitBy: self with: args)]!


    method visitConstant: constant
        constant value :: CpsValue!


    method visitConstant: constant with: args
        constant value apply: args!


    method visitGlobal: aGlobal
        let def = aGlobal definition.
        def is False
            ifTrue: { Error raise: "Undefined global in CpsEvaluator: {aGlobal name}" }
            ifFalse: { def }!


    method visitOperation: anOp
        anOp kind apply: (self visitAll: anOp args)!


    method visitOperation: anOp with: args
        (anOp visitBy: self)
            apply: args!
end


class CpsPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output newline.
        visitor visit: graph entry!


    method visit: other
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitContinuation: aCont
        aCont prettyPrintTo: output.
        aCont args do: { |each| self visit: each }.
        self visit: aCont target!


    method visitConstant: _
        False!


    method visitVariable: _
        False!


    method visitGlobal: _
        False!


    method visitApplication: anApplication
        self visit: anApplication target!


    method visitSelect: aSelect
        self visit: aSelect cond.
        self visit: aSelect then.
        self visit: aSelect else!


    method visitOperation: anOp
        anOp args do: { |each| self visit: each }!
end

class CpsGraphwizOrderPrinter { output }
    direct method printToString: graph in: order
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph in: order to: output
        output writeString: "\nstrict digraph \{\n".
        output writeString: "    \"{graph entry printName}\" [color=red]\n".
        let prev = False.
        order for: graph entry
              do: { |cont|
                    output writeString: "   \"".
                    output writeString: cont printName.
                    output writeString: "\" [shape=box]\n".
                    prev => {
                        output writeString: "    \"".
                        output writeString: prev printName.
                        output writeString: "\" -> \"".
                        output writeString: cont printName.
                        output writeString: "\"\n" }.
                    prev = cont }.
        output writeString: "\}\n"!
end


class CpsGraphwizPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output writeString: "\nstrict digraph \{\n".
        output writeString: "    \"{graph entry printName}\" [color=red]\n".
        visitor visit: graph entry.
        output writeString: "\}\n"!


    method visit: other
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitAll: nodes
        nodes do: { |each| self visit: each }!


    method visitContinuation: aCont
        output writeString: "    \"{aCont printName}\" [shape=box]\n".
        aCont params
            do: { |each|
                  each uses isEmpty
                      ifFalse: { output writeString: "    \"".
                                 output writeString: aCont printName.
                                 output writeString: "\" -> \"".
                                 output writeString: each printName.
                                 output writeString: "\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]\n" } }.
        aCont doValues: { |each|
                          output writeString: "    \"".
                          output writeString: each printName.
                          output writeString: "\" -> \"".
                          output writeString: aCont printName.
                          output writeString: "\" [style=dotted]\n" }.
        aCont doSuccessors: { |each|
                              output writeString: "    \"".
                              output writeString: aCont printName.
                              output writeString: "\" -> \"".
                              output writeString: each printName.
                              output writeString: "\" [arrowhead=vee]\n" }.
        aCont doChildren: { |each|
                            self visit: each }.
        self visitAll: aCont args!


    method visitVariable: aVar
        False!


    method visitConstant: _
        False!


    method visitGlobal: _
        False!


    method visitApplication: _
        False!


    method visitOperation: anOperation
        anOperation uses
            doSorted: { |each| each visitBy: self }.
        anOperation args
            do: { |each|
                  output writeString: "    \"".
                  output writeString: each printName.
                  output writeString: "\" -> \"".
                  output writeString: anOperation printName.
                  output writeString: "\" [style=dotted]\n" }.
        self visitAll: anOperation args!
end


class CBackend { output declared emitted dependencies }

    direct method output: output
        self output: output
             declared: Dictionary new
             emitted: Dictionary new
             dependencies: Set new!


    direct method emitToString: classDef
        StringOutput with:
            { |out|
              self emit: classDef to: out }!


    direct method emit: classDef to: output
        (self output: output)
            ; discoverDependencies: classDef
            ; writeHeaders
            ; emitDependencies!


    direct method emitMainToString: mainClass in: namespace
        StringOutput with:
            { |out|
              self emitMain: mainClass in: namespace to: out }!


    direct method emitMain: mainClass in: namespace to: output
        (self output: output)
            ; discoverDependencies: mainClass
            ; writeHeaders
            ; emitDependencies
            ; emitMain: mainClass in: namespace!


    method emitDependencies
        dependencies sorted
            ; do: { |each| self emitDeclaration: each }
            ; do: { |each| self emitClass: each }!

    method emitMain: mainClass in: namespace
        let mainMetaclassInfo = self declare: mainClass ownClassDefinition.
        let mainInfo = self declare: mainClass.
        let runInMethod = mainClass findMethod: (namespace intern: "run:in:").
        let runInInfo = self declare: runInMethod cps.
        output
            ; newline
            ; print: "char* main_actor_exit(char* sp, struct Actor* actor) \{\n"
            ; print: "    datum_t res = READ_DATUM(sp, -2);\n"
            ; print: "    printf(\" INFO - main actor exit: %d\\n\", (int)res);\n"
            ; print: "    atomic_store(&actor->state, ActorExiting);\n"
            ; print: "    actor->sp = sp;\n"
            ; print: "    return 0;\n"
            ; print: "\}\n"
            ; newline
            ; print: "char* main_actor_entry(char* sp, struct Actor* actor) \{\n"
            ; print: "    (void)actor;\n"
            ; print: "    PUSH_DATUM(sp, main_actor_exit);\n"
            ; print: "    PUSH_DATUM(sp, &{mainMetaclassInfo name}); // Main class\n"
            ; print: "    PUSH_DATUM(sp, &{mainInfo name}); // Main\n"
            ; print: "    PUSH_DATUM(sp, 0); // FIXME Array\n"
            ; print: "    PUSH_DATUM(sp, 0); // FIXME    command datum\n"
            ; print: "    PUSH_DATUM(sp, 0); // FIXME System\n"
            ; print: "    PUSH_DATUM(sp, 0); // FIXME    system datum\n"
            ; print: "    PUSH_DATUM(sp, IMMS(1) | OBJS(3));\n"
            ; print: "    PUSH_DATUM(sp, {runInInfo name});\n"
            ; print: "    return sp;\n"
            ; print: "\}\n"
            ; newline
            ; print: "int main(int argc, char** argv) \{\n"
            ; print: "    (void)argc;\n"
            ; print: "    (void)argv;\n"
            ; print: "    struct ExecutorPool* pool = make_ExecutorPool(1);\n"
            ; print: "    struct Actor* mainActor = make_Actor(main_actor_entry, NULL);\n"
            ; print: "    enqueue_actor(pool->executors[0]->queue, mainActor);\n"
            ; print: "    start_pool(pool);\n"
            ; print: "    wait_for_actor_exit(mainActor, 0);\n"
            ; print: "    free_Actor(mainActor);\n"
            ; print: "    stop_pool(pool);\n"
            ; print: "    free_ExecutorPool(pool);\n"
            ; print: "    printf(\" INFO - exit\\n\");\n"
            ; print: "    return 0;\n"
            ; print: "\}\n"!


    method discoverDependencies: aClass
        (dependencies includes: aClass)
            ifTrue: { return aClass }.
        dependencies add: aClass.
        self discoverDependencies: aClass ownClassDefinition.
        aClass methodDictionary
            do: { |eachMethod|
                  eachMethod dependencies
                      do: { |eachDep|
                            self discoverDependencies: eachDep } }!


    method declare: thing
        declared
            at: thing
            ifNonePut: {
                let cName = self generateCName: thing.
                let cType = self cTypeOf: thing.
                { name: cName, type: cType }
            }!


    method markEmitted: thing
        (self emittedInfo: thing)
            => { Error raise: "Already emitted: {thing}" }.
        let info = self declare: thing.
        emitted put: info at: thing.
        info!


    method emittedInfo: thing
        -- Ie. returns info or False
        emitted at: thing!


    method writeHeaders
        output
            ; print: "/**\n"
            ; print: " * Foolang generated code - do not edit by hand!\n"
            ; print: " */\n\n"
            ; print: "#include \"foolang.h\"\n\n"!


    method emitDeclaration: thing
        let info = self declare: thing.
        output
            ; print: info type
            ; print: " "
            ; print: info name
            ; print: ";\n"!


    method emitClass: classDef
        (self emittedInfo: classDef)
            => { |info| return info }.
        self markEmitted: classDef.
        let classInfo = self declare: classDef.
        let metaclassInfo = self declare: classDef ownClassDefinition.
        let nameInfo = self emitString: classDef name.
        let methodInfo = self emitMethodDictionary: classDef methodDictionary.
        output print: "\n// ".
        output println: classDef displayString.
        output print: classInfo type.
        output print: " ".
        output print: classInfo name.
        output println: " = \{".

        output print: "    .name = &".
        output print: nameInfo name.
        output println: ",".

        output print: "    .own_class = &".
        output print: metaclassInfo name.
        output println: ",".

        output print: "    .methods = &".
        output println: methodInfo name.
        output print: "\};\n".
        classInfo!


    method emitString: string
        (self emittedInfo: string)
            => { |info| return info }.
        let info = self markEmitted: string.
        output print: "\n// ".
        output println: string displayString.
        output print: info type.
        output print: " ".
        output print: info name.
        output print: " = \{\n    .size = ".
        output print: string size.
        output print: ",\n    .data = \{ ".
        string  do: { |each| output print: "'{each}'," }.
        output print: " 0 \}\n\};\n".
        info!


    method emitSelector: aSelector
        (self emittedInfo: aSelector)
            => { |info| return info }.
        let info = self markEmitted: aSelector.
        let nameInfo = self emitString: aSelector name.
        output print: "\n// #".
        output println: aSelector name.
        output print: info type.
        output print: " ".
        output print: info name.
        output print: " = \{\n    .name = &".
        output print: nameInfo name.
        output print: "\n\};\n".
        info!


    method emitFunction: function
        (self emittedInfo: function)
            => { |info| return info }.
        let info = self markEmitted: function.
        function emitOn: self.
        info!


    method emitFunctionHeader: function
        output
            ; print: "\n// "
            ; println: function displayString
            ; print: "char* "
            ; print: (self declare: function) name
            ; print: "(char* sp, struct Actor* actor) \{\n"!


    method emitFunctionFooter
        output print: "\}\n"!


    method emitCpsGraph: graph
        -- FIXME: This gets called from emitFunction via emitOn,
        -- which leaves it "inside braces", but may generate
        -- N functions.
        --
        -- Should instead make this and other backend emitters
        -- be responsible for the whgile function output.
        --
        -- Common code can still be factored out.
        CpsGraphCBackend
            emit: graph
            withBackend: self!


    method emitConstructor: ctor
        let classInfo = self declare: ctor classDefinition.
        classInfo is False
            ifTrue: { Error raise: "Class definition for {ctor} not yet declared" }.
        self emitFunctionHeader: ctor.
        -- 0     1      2          3        4
        -- cont, Class, own-class, argInfo, cc
        output
            ; print: "    char* bp = actor->bp = sp - 4 * sizeof(datum_t);\n"
            ; print: "    datum_t cont = READ_DATUM(bp, 0);\n"
            ; print: "    sp = bp;\n"
            ; print: "    PUSH_DATUM(sp, &"
            ; print: classInfo name
            ; print: ");\n"
            ; print: "    PUSH_DATUM(sp, 0); // only empty classes for now!\n"
            ; print: "    PUSH_DATUM(sp, OBJS(1));\n"
            ; print: "    PUSH_DATUM(sp, cont);\n"
            ; print: "    return sp;\n".
        self emitFunctionFooter!


    method emitOpaqueIdentity: identity
        self emitFunctionHeader: identity.
        -- 0     1               2               3        4
        -- cont, receiver class, receiver datum, argInfo, cc
        output
            ; print: "    char* bp = actor->bp = sp - 4 * sizeof(datum_t);\n"
            ; print: "    datum_t cont = READ_DATUM(bp, 0);\n"
            ; print: "    datum_t class = READ_DATUM(bp, 1);\n"
            ; print: "    datum_t datum = READ_DATUM(bp, 2);\n"
            ; print: "    sp = bp;\n"
            ; print: "    PUSH_DATUM(sp, class);\n"
            ; print: "    PUSH_DATUM(sp, datum);\n"
            ; print: "    PUSH_DATUM(sp, OBJS(1));\n"
            ; print: "    PUSH_DATUM(sp, cont);\n"
            ; print: "    return sp;\n".
        self emitFunctionFooter!


    method emitTypecheck: typecheck
        self emitFunctionHeader: typecheck.
        -- 0     1               2          3           4          5        6
        -- cont, recv-own-class, recv-class, arg-class, arg-datum, argInfo, cc
        --
        -- The only reason this calls out to runtime is because I can't
        -- write the error handler code yet!
        output
            ; print: "    char* bp = actor->bp = sp - 6 * sizeof(datum_t);\n"
            ; print: "    datum_t expectedClass = READ_DATUM(bp, 1);\n"
            ; print: "    datum_t actualClass = READ_DATUM(bp, 3);\n"
            ; print: "    if (expectedClass == actualClass) \{\n"
            ; print: "        datum_t cont = READ_DATUM(bp, 0);\n"
            ; print: "        datum_t actualDatum = READ_DATUM(bp, 4);\n"
            ; print: "        sp = bp;\n"
            ; print: "        PUSH_DATUM(sp, actualClass);\n"
            ; print: "        PUSH_DATUM(sp, actualDatum);\n"
            ; print: "        PUSH_DATUM(sp, OBJS(1));\n"
            ; print: "        PUSH_DATUM(sp, cont);\n"
            ; print: "        return sp;\n"
            ; print: "    \} else \{\n"
            ; print: "        return runtime_type_error(sp, actor);\n    \}\n".
        self emitFunctionFooter!


    method emitBuiltin: impl
        -- FIXME: use the inline expansion
        self emitFunctionHeader: impl.
        output
            ; print: "    (void)sp;\n"
            ; print: "    (void)actor;\n"
            ; print: "    printf(\"TODO: {impl selector}\");\n"
            ; print: "    exit(1);\n".
        self emitFunctionFooter!


    method emitMethod: aMethod
        let info = self declare: aMethod.
        let selectorInfo = self emitSelector: aMethod selector.
        let homeInfo = self emitClass: aMethod home.
        let functionInfo = self emitFunction: aMethod impl.
        output print: "\n// ".
        output println: aMethod displayString.
        output print: info type.
        output print: " ".
        output print: info name.
        output print: " = \{\n    .home = &".
        output print: homeInfo name.
        output print: ",\n    .selector = &".
        output print: selectorInfo name.
        output print: ",\n    .method_function = ".
        output print: functionInfo name.
        output print: "\n\};\n".
        info!


    method emitMethodDictionary: methodDictionary
        methodDictionary
            do: { |each|
                  self emitMethod: each }.
        let methodInfo = self declare: methodDictionary.
        output print: "\n// ".
        output println: methodDictionary displayString.
        output print: methodInfo type.
        output print: " ".
        output print: methodInfo name.
        output print: " = \{\n    .size = ".
        output print: methodDictionary size.
        output print: ",\n    .data = \{\n".
        methodDictionary
            do: { |each|
                  let info = self declare: each.
                  output print: "        &".
                  output print: info name.
                  output print: ", // ".
                  output print: each displayString }
            interleaving: { output newline }.
        output print: "\n    \}\n\};\n".
        methodInfo!


    method generateCName: thing
        let n = declared size + 1.
        (MethodDefinition includes: thing)
            ifTrue: { return "foo_method_{n}" }.
        (CpsGraph includes: thing)
            ifTrue: { return "foo_method_function_{n}" }.
        (CpsSelector includes: thing)
            ifTrue: { return "foo_selector_{n}" }.
        (BuiltinMethodImpl includes: thing)
            ifTrue: { return "foo_builtin_{n}" }.
        (ClassDefinition includes: thing)
            ifTrue: { return "foo_class_{n}" }.
        (MethodDictionary includes: thing)
            ifTrue: { return "foo_methods_{n}" }.
        (String includes: thing)
            ifTrue: { return "foo_string_{n}" }.
        (Instance includes: thing)
            ifTrue: { thing type is IntegerClassDefinition
                          => { return "{thing}" }.
                      thing type is BooleanClassDefinition
                          => { return thing hostValue
                                   ifTrue: { "1" }
                                   ifFalse: { "0" } } }.
        (Datum includes: thing)
            ifTrue: { thing type is IntegerClassDefinition
                          ifTrue: { return "{thing}" } }.
        -- FIXME: Would be nice if the name identified which graph
        -- aka method_function_<id> the continuation belonged to.
        (Continuation includes: thing)
            ifTrue: { return "foo_continuation_{n}" }.
        Error raise: "Don't know how to generate C-name for: {thing displayString} :: {thing classOf name}"!

    method cTypeOf: thing
        (MethodDefinition includes: thing)
            ifTrue: { return "struct FooMethod" }.
        (CpsGraph includes: thing)
            ifTrue: { return "FooMethodFunction" }.
        (Continuation includes: thing)
            ifTrue: { return "FooContinuation" }.
        (CpsSelector includes: thing)
            ifTrue: { return "struct FooSelector" }.
        (BuiltinMethodImpl includes: thing)
            ifTrue: { return "FooMethodFunction" }.
        (ClassDefinition includes: thing)
            ifTrue: { return "struct FooClass" }.
        (MethodDictionary includes: thing)
            ifTrue: { return "struct FooMethodDictionary" }.
        (Instance includes: thing)
            ifTrue: { return (self declare: thing type) name }.
        (Datum includes: thing)
            ifTrue: { thing type is IntegerClassDefinition
                          ifTrue: { return "datum_t" } }.
        (String includes: thing)
            ifTrue: { return "struct FooBytes" }.
        Error raise: "Don't know how to generate C-type for: {thing displayString} :: {thing className}"!

end


class ForAllVariables { variables }
    direct method in: expressions doSorted: block
        let collector = self variables: Set new.
        expressions
            do: { |each| collector collectFrom: each }.
        collector variables
            doSorted: block!

    method collectFrom: anExpr
        anExpr visitBy: self!

    method visitVariable: aVar
        variables add: aVar!

    method visitOperation: anOp
        anOp args do: { |each| each visitBy: self }!

    method visitConstant: _
        False!

    method visitGlobal: _
        False!

    method visitContinuation: _
        False!

    method visitMethodDefinition: _
        False!
end


class CArgument { backend stackmap }
    direct method emit: expr
                  withBackend: backend
                  withStackmap: stackmap
        let argumentEmitter = self backend: backend stackmap: stackmap.
        expr visitBy: argumentEmitter!


    method visitVariable: aVar
        let info = stackmap at: aVar.
        info classSlot
            => { backend output
                     print: "    PUSH_DATUM(sp, {info classTemp});\n" }.
        info datumTemp
            => { |tmp|
                 return backend output
                     print: "    PUSH_DATUM(sp, {tmp});\n" }.
        Error raise: "No tmp: {aVar}, info: {info}"!


    method visitGlobal: aGlobal
        let definition = aGlobal definition :: ClassDefinition.
        let classInfo = backend declare: definition.
        let ownClassInfo = backend declare: definition ownClassDefinition.
        backend output
            ; print: "    PUSH_DATUM(sp, &{classInfo name});\n"
            ; print: "    PUSH_DATUM(sp, &{ownClassInfo name});\n"!


    method visitConstant: aConst
        let classInfo = backend declare: aConst type :: ClassDefinition.
        let valueInfo = backend declare: aConst value.
        backend output
            ; print: "    PUSH_DATUM(sp, &{classInfo name});\n"
            ; print: "    PUSH_DATUM(sp, {valueInfo name});\n"!


    method visitContinuation: aCont
        backend output
            ; print: "    PUSH_DATUM(sp, {(backend declare: aCont) name :: String});\n"!


    method visitOperation: anOp
        anOp kind visit: anOp by: self!


    method visitMakeInstance: aMakeInstance
        let classC = CExpr emit: aMakeInstance args first
                           withBackend: backend
                           withStackmap: stackmap.
        backend output
            print: "    PUSH_DATUM(sp, &{classC});\n".
        let datumC = CExpr emit: aMakeInstance args second
                           withBackend: backend
                           withStackmap: stackmap.
        backend output
            print: "    PUSH_DATUM(sp, {datumC});\n"!
end


class CExpr { backend stackmap }
    direct method emit: expr
                  withBackend: backend
                  withStackmap: stackmap -> String
        let exprBuilder = self backend: backend stackmap: stackmap.
        expr visitBy: exprBuilder!

    method visitConstant: aConst
         "{(backend declare: aConst value) name}"!

    method visitOperation: anOp -> String
        anOp kind visit: anOp by: self!

    method visitDatumOf: aDatumOf
        let var = aDatumOf args first :: Variable.
        (stackmap at: var)
            => { |info| return info datumTemp }.
        Error raise: "No info for datum: {var}"!

    method visitMakeInstance: aMakeInstance
        -- XXX HERE
        Error raise: "TODO: CExpr visitMakeInstance: {aMakeInstance}"!

    method visitAddi: anAddi
        let left = anAddi args first visitBy: self.
        let right = anAddi args second visitBy: self.
        "((int64_t){left} + (int64_t){right})"!

    method visitSubi: anAddi
        let left = anAddi args first visitBy: self.
        let right = anAddi args second visitBy: self.
        "((int64_t){left} - (int64_t){right})"!

    method visitImul: anAddi
        let left = anAddi args first visitBy: self.
        let right = anAddi args second visitBy: self.
        "((int64_t){left} * (int64_t){right})"!

    method visitIdiv: anAddi
        let left = anAddi args first visitBy: self.
        let right = anAddi args second visitBy: self.
        "((int64_t){left} / (int64_t){right})"!

    method visitVariable: aVar
        "READ_DATUM(bp, {(stackmap at: aVar) datumSlot})"!

    method visitIsEq: anIsEq
        let left = anIsEq args first.
        let right = anIsEq args second.
        left type is right type
            ifTrue: { let leftDatum = left visitBy: self.
                      let rightDatum = right visitBy: self.
                      "((int64_t){leftDatum} = (int64_t){rightDatum})" }
            ifFalse: { Error raise: "TODO: is with an an uncertain type" }!

end


class CVarInfo { classSlot datumSlot classTemp datumTemp }
    is Object

    direct method classSlot: classSlot datumSlot: datumSlot
        self classSlot: classSlot
             datumSlot: datumSlot
             classTemp: False
             datumTemp: False!

    direct method datumSlot: datumSlot
        self classSlot: False
             datumSlot: datumSlot
             classTemp: False
             datumTemp: False!

    method datumTemp: new::String
        datumTemp = new!

    method classTemp: new::String
        classTemp = new!

    method toString
        classSlot
            => { return "#<CVarInfo {datumSlot}::{classSlot}, {datumTemp}::{classTemp}>" }.
        "<CVarInfo {datumSlot}, {datumTemp}>"!
end


class CpsGraphCBackend { backend graph stackmap frameSize }

    direct method emit: graph withBackend: backend
        let graphBackend = self backend: backend
                                graph: graph
                                stackmap: Dictionary new
                                frameSize: 0.
        graph continuations
            do: { |each| graphBackend emitContinuation: each }!


    method emitContinuation: aCont
        aCont isUnused not assert: "Don't emit unused continuations.".
        -- Currently entry continuation is the method function
        -- entry point, and therefore gets its header from the
        -- the CpsGraph, not the continuation.
        aCont is graph entry
            ifTrue: { backend emitFunctionHeader: graph.
                      self emitMethodFunctionPrelude }
            ifFalse: { backend emitFunctionHeader: aCont.
                       self emitContinuationPrelude: aCont }.
        aCont target visitBy: self with: aCont args.
        backend emitFunctionFooter!


    method emitStackmap
        let params = graph entry params.
        -- Stack has:
        --
        --    exit
        --    receiver-class
        --    receiver-datum
        --    arg1-class
        --    arg2-datum
        --    ...
        --    argInfo
        --
        backend output print: "    // 0 - {graph exit name}\n".
        let next = 0.
        stackmap
            put: (CVarInfo datumSlot: next)
            at: params first.
        next = next + 1.
        params rest
            do: { |each|
                  backend output
                      ; print: "    // {next} - {each name} class\n"
                      ; print: "    // {next+1} - {each name} datum\n".
                  stackmap
                      put: (CVarInfo classSlot: next datumSlot: next + 1)
                      at: each.
                  next = next + 2 }.
        backend output
            ; print: "    // {next} - layout word\n    // -\n".
        next = next + 1.
        graph variables
            doSorted: { |each|
                        (stackmap has: each)
                            ifFalse: {
                                backend output
                                    ; print: "    // {next} - {each name} class\n"
                                    ; print: "    // {next+1} - {each name} datum\n".
                                stackmap
                                    put: (CVarInfo classSlot: next datumSlot: next + 1)
                                    at: each.
                                frameSize = frameSize + 2.
                                next = next + 2 } }.
        frameSize > 0
            ifTrue: { backend output print: "    // {next} - layout word\n" }!

    method basePointerOffset
        -- First slot is the return continuation. Everything else is datum.
        -- The params are the followed by the layout word. Ergo x 2.
        let nParams :: Integer = graph entry params size.
        nParams * 2!


    method emitMethodFunctionPrelude
        self emitStackmap.
        backend output
            ; print: "    char* bp = actor->bp = sp - {self basePointerOffset} * sizeof(datum_t);\n".
        (graph entry params rest rest)
            do: { |each|
                  each type
                      => { self emitParameterTypecheck: each } }.
        frameSize > 0
            ifTrue: { frameSize times: { backend output print: "    PUSH_DATUM(sp, 0);\n" }.
                      backend output print: "    PUSH_DATUM(sp, OBJS({frameSize / 2}));\n" }!


    method emitContinuationPrelude: aCont
        backend output print: "    char* bp = actor->bp;\n".
        -- FIXME: It would be really nice to avoid this copy to
        -- reserved stack-slot, but for now it keeps things nice
        -- and simple. (...and makes debugging easier as well.)
        let params = aCont params.
        let next = -(params size * 2 + 1).
        aCont params
            do: { |each|
                  let info = stackmap at: each.
                  info classSlot
                      => { |slot|
                           backend output
                               print: "    WRITE_DATUM(bp, {slot}, READ_DATUM(sp, {next}));\n" }.
                  backend output
                      print: "    WRITE_DATUM(bp, {info datumSlot}, READ_DATUM(sp, {next+1}));\n".
                  next = next + 2 }!


    method emitParameterTypecheck: aVar
        let actualClass = (stackmap at: aVar) classSlot.
        let expectedClass = (backend declare: aVar type) name.
        backend output
            ; print: "    if (READ_DATUM(bp, {actualClass}) != &{expectedClass}) // "
            ; print: aVar name
            ; print: " :: "
            ; print: aVar type name
            ; print: "\n        return runtime_type_error(sp, actor);\n"!


    method emitCopyVariable: var
        let info = stackmap at: var.
        info datumTemp: "d{info datumSlot}".
        info classSlot
            => { |slot|
                 let tmp = "c{slot}".
                 info classTemp: tmp.
                 backend output
                     print: "    datum_t {tmp} = READ_DATUM(bp, {slot});\n" }.
        backend output
            print: "    datum_t {info datumTemp} = READ_DATUM(bp, {info datumSlot});\n"!


    method visitVariable: target with: args
        ForAllVariables
            in: (args append: [target])
            doSorted: { |each| self emitCopyVariable: each }.
        -- Iff graph exit, then this is a tail call: pop frame by setting sp = bp.
        target is graph exit
            ifTrue: { backend output print: "    sp = bp;\n" }.
        args do: { |each|
                   CArgument
                       emit: each
                       withBackend: backend
                       withStackmap: stackmap }.
        backend output
            print: "    PUSH_DATUM(sp, OBJS({args size}));\n".
        CArgument
            emit: target
            withBackend: backend
            withStackmap: stackmap.
        backend output
            print: "    return sp;\n"!


    method visitSelect: aSelect with: args
        -- XXX: refactor
        ForAllVariables
            in: args
            doSorted: { |each| self emitCopyVariable: each }.
        args do: { |each|
                   CArgument
                       emit: each
                       withBackend: backend
                       withStackmap: stackmap }.
        args isEmpty
            ifFalse: { backend output
                           print: "    PUSH_DATUM(sp, OBJS({args size}));\n" }.
        let cond = aSelect cond.
        cond type is BooleanClassDefinition
            assert: "FIXME: Select with non-boolean cond".
        let condC = CExpr
                           emit: cond
                           withBackend: backend
                           withStackmap: stackmap.
        let thenC = (backend declare: aSelect then) name.
        let elseC = (backend declare: aSelect else) name.
        backend output
            ; print: "    if ({condC}) \{\n"
            ; print: "        PUSH_DATUM(sp, {thenC});\n"
            ; print: "    \} else \{\n"
            ; print: "        PUSH_DATUM(sp, {elseC});\n"
            ; print: "    \}\n"
            ; print: "    return sp;\n"!


    method visitApplication: anApp with: args
        -- Where the application will return.
        let target = anApp target.
        -- Function we're applying.
        let function = anApp function.
        (Constant includes: function)
            ifFalse: { Error raise: "TODO: handle unresolved application: {function}" }.
        let functionValue = function value.
        -- 1. Collect variables from all argument expressions.
        -- 2. Copy each variable to a temporary datum_t.
        ForAllVariables
            in: (args append: [target, functionValue])
            doSorted: { |each| self emitCopyVariable: each }.
        -- 3. Iff target is graph exit, then this is a tail-application: pop frame by setting sp = bp.
        anApp target is graph exit
            ifTrue: { backend output print: "    sp = bp;\n" }.
        -- 4. Push application args: target addr, copies of arguments, layout, and
        -- function addr.
        let functionInfo = backend declare: functionValue impl.
        CArgument
            emit: anApp target
            withBackend: backend
            withStackmap: stackmap.
        args
            do: { |each|
                  CArgument
                      emit: each
                      withBackend: backend
                      withStackmap: stackmap }.
        backend output
            ; print: "    PUSH_DATUM(sp, IMMS(1) | OBJS({args size}));\n"
            ; print: "    PUSH_DATUM(sp, {functionInfo name}); // {functionValue printName}\n"
            ; print: "    return sp;\n"!

end


class TestCPS { assert system }
    is TestSuite

    direct method assert: assert
        self assert: assert system: False!

    method system: new
        system = new!

    method convertExpr: source with: defs in: namespace
        let syntax = Parser parseExpression: source.
        CpsConverter convertExpr: syntax
                     with: defs
                     in: namespace!


    method convertExpr: source with: defs
        self convertExpr: source
             with: defs
             in: Namespace standard!


    method convertExpr: source
        self convertExpr: source
             with: []
             in: Namespace standard!


    method convertClass: source with: defs in: namespace
        let syntax = Parser parseDefinition: source.
        CpsConverter convertClass: syntax
                     with: defs
                     in: namespace!


    method convertClass: source with: defs
        self convertClass: source
             with: defs
             in: Namespace standard!


    method test_class_type_defined_inside_its_own_methods
        let ns = Namespace standard.
        let def = self convertClass: "class Test \{}
                                          method test
                                              self :: Test!
                                      end"
                      with: []
                      in: ns.
        let m = def findMethod: (ns intern: "test").
        assert that: { CpsPrinter printToString: m cps }
               equals: "
$entry:2($return:3, $receiver::Test:4):
    $return:3($receiver::Test:4)
"!


    method test_c_backend_trivial_method
        let ns = Namespace standard.
        let def = self convertClass: "class Test \{}
                                          method test
                                              self opaqueIdentity :: Test!
                                      end"
                      with: []
                      in: ns.
        -- Sanity check the CPS: OpaqueIdentity is explicitly never
        -- inlined, so must be via an Application.
        let m = def findMethod: (ns intern: "test").
        assert that: { CpsPrinter printToString: m cps }
               equals: "
$entry:2($return:3, $receiver::Test:4):
    apply:18($bind:13, Test#opaqueIdentity)($receiver::Test:4)
$bind:13($value:6):
    apply:11($return:3, Test class#typecheck:)(Test:Global, $value:6)
".

               let backend = CBackend output: StringOutput new.
        backend emitFunction: m impl.
        assert that: { backend output content }
               equals: "
// #<CpsGraph Test#test>
char* foo_method_function_1(char* sp, struct Actor* actor) \{
    // 0 - $return
    // 1 - $receiver class
    // 2 - $receiver datum
    // 3 - layout word
    // -
    // 4 - $value class
    // 5 - $value datum
    // 6 - layout word
    char* bp = actor->bp = sp - 4 * sizeof(datum_t);
    PUSH_DATUM(sp, 0);
    PUSH_DATUM(sp, 0);
    PUSH_DATUM(sp, OBJS(1));
    datum_t c1 = READ_DATUM(bp, 1);
    datum_t d2 = READ_DATUM(bp, 2);
    PUSH_DATUM(sp, foo_continuation_3);
    PUSH_DATUM(sp, c1);
    PUSH_DATUM(sp, d2);
    PUSH_DATUM(sp, IMMS(1) | OBJS(1));
    PUSH_DATUM(sp, foo_builtin_2); // Test#opaqueIdentity
    return sp;
}

// #<Continuation $bind:13>
char* foo_continuation_3(char* sp, struct Actor* actor) \{
    char* bp = actor->bp;
    WRITE_DATUM(bp, 4, READ_DATUM(sp, -3));
    WRITE_DATUM(bp, 5, READ_DATUM(sp, -2));
    datum_t d0 = READ_DATUM(bp, 0);
    datum_t c4 = READ_DATUM(bp, 4);
    datum_t d5 = READ_DATUM(bp, 5);
    sp = bp;
    PUSH_DATUM(sp, d0);
    PUSH_DATUM(sp, &foo_class_5);
    PUSH_DATUM(sp, &foo_class_6);
    PUSH_DATUM(sp, c4);
    PUSH_DATUM(sp, d5);
    PUSH_DATUM(sp, IMMS(1) | OBJS(2));
    PUSH_DATUM(sp, foo_builtin_4); // Test class#typecheck:
    return sp;
\}
"!


    method test_c_backend_integer_addition
        let ns = Namespace standard.
        let def = self convertClass: "class AddiTest \{}
                                          method double: x::Integer
                                              x + x!
                                      end"
                      with: [IntegerClassDefinition]
                      in: ns.
        -- Sanity check the CPS first
        let m = def findMethod: (ns intern: "double:").
        assert that: { CpsPrinter printToString: m cps }
               equals: "
$entry:2($return:3, $receiver::AddiTest:4, x::Integer:7):
    $return:3(makeInstance:26(Integer, addi:25(datumOf:24(x::Integer:7), datumOf:24(x::Integer:7))))
".

               let backend = CBackend output: StringOutput new.
        backend emitFunction: m impl.
        assert that: { backend output content }
               equals: "
// #<CpsGraph AddiTest#double:>
char* foo_method_function_1(char* sp, struct Actor* actor) \{
    // 0 - $return
    // 1 - $receiver class
    // 2 - $receiver datum
    // 3 - x class
    // 4 - x datum
    // 5 - layout word
    // -
    char* bp = actor->bp = sp - 6 * sizeof(datum_t);
    if (READ_DATUM(bp, 3) != &foo_class_2) // x :: Integer
        return runtime_type_error(sp, actor);
    datum_t d0 = READ_DATUM(bp, 0);
    datum_t c3 = READ_DATUM(bp, 3);
    datum_t d4 = READ_DATUM(bp, 4);
    sp = bp;
    PUSH_DATUM(sp, &foo_class_2);
    PUSH_DATUM(sp, ((int64_t)d4 + (int64_t)d4));
    PUSH_DATUM(sp, OBJS(1));
    PUSH_DATUM(sp, d0);
    return sp;
}
"!


    method test_c_backend_integer_constant
        let ns = Namespace standard.
        let def = self convertClass: "class IntegerConstantTest \{}
                                          method value
                                              123123!
                                      end"
                      with: [IntegerClassDefinition]
                      in: ns.
        -- Sanity check the CPS first
        let m = def findMethod: (ns intern: "value").
        assert that: { CpsPrinter printToString: m cps }
               equals: "
$entry:2($return:3, $receiver::IntegerConstantTest:4):
    $return:3(123123)
".
        -- Test the C code
        let backend = CBackend output: StringOutput new.
        backend emitFunction: m impl.
        assert that: { backend output content }
               equals: "
// #<CpsGraph IntegerConstantTest#value>
char* foo_method_function_1(char* sp, struct Actor* actor) \{
    // 0 - $return
    // 1 - $receiver class
    // 2 - $receiver datum
    // 3 - layout word
    // -
    char* bp = actor->bp = sp - 4 * sizeof(datum_t);
    datum_t d0 = READ_DATUM(bp, 0);
    sp = bp;
    PUSH_DATUM(sp, &foo_class_2);
    PUSH_DATUM(sp, 123123);
    PUSH_DATUM(sp, OBJS(1));
    PUSH_DATUM(sp, d0);
    return sp;
}
"!


    method test_c_backend_ifTrue_ifFalse
        let ns = Namespace standard.
        let def = self convertClass: "class IfTrueTest \{}
                                          method if: x :: Boolean then: a else: b
                                              x ifTrue: \{ a \} ifFalse: \{ b \}!
                                      end"
                      with: [BooleanClassDefinition]
                      in: ns.
        -- Sanity check the CPS first
        let m = def findMethod: (ns intern: "if:then:else:").
        assert that: { CpsPrinter printToString: m cps }
               equals: "
$entry:2($return:3, $receiver::IfTrueTest:4, x::Boolean:7, a:8, b:9):
    select:29(x::Boolean:7, $block:24, $block:20)()
$block:24():
    $return:3(a:8)
$block:20():
    $return:3(b:9)
".
        -- Test the C code
        let backend = CBackend output: StringOutput new.
        backend emitFunction: m impl.
        assert that: { backend output content }
               equals: "
// #<CpsGraph IfTrueTest#if:then:else:>
char* foo_method_function_1(char* sp, struct Actor* actor) \{
    // 0 - $return
    // 1 - $receiver class
    // 2 - $receiver datum
    // 3 - x class
    // 4 - x datum
    // 5 - a class
    // 6 - a datum
    // 7 - b class
    // 8 - b datum
    // 9 - layout word
    // -
    char* bp = actor->bp = sp - 10 * sizeof(datum_t);
    if (READ_DATUM(bp, 3) != &foo_class_2) // x :: Boolean
        return runtime_type_error(sp, actor);
    if (READ_DATUM(bp, 4)) \{
        PUSH_DATUM(sp, foo_continuation_3);
    } else \{
        PUSH_DATUM(sp, foo_continuation_4);
    }
    return sp;
}

// #<Continuation $block:20>
char* foo_continuation_4(char* sp, struct Actor* actor) \{
    char* bp = actor->bp;
    datum_t d0 = READ_DATUM(bp, 0);
    datum_t c7 = READ_DATUM(bp, 7);
    datum_t d8 = READ_DATUM(bp, 8);
    sp = bp;
    PUSH_DATUM(sp, c7);
    PUSH_DATUM(sp, d8);
    PUSH_DATUM(sp, OBJS(1));
    PUSH_DATUM(sp, d0);
    return sp;
}

// #<Continuation $block:24>
char* foo_continuation_3(char* sp, struct Actor* actor) \{
    char* bp = actor->bp;
    datum_t d0 = READ_DATUM(bp, 0);
    datum_t c5 = READ_DATUM(bp, 5);
    datum_t d6 = READ_DATUM(bp, 6);
    sp = bp;
    PUSH_DATUM(sp, c5);
    PUSH_DATUM(sp, d6);
    PUSH_DATUM(sp, OBJS(1));
    PUSH_DATUM(sp, d0);
    return sp;
}
"!


    method NO_test_c_backend_integration_test
        -- This is the only test that emits the full C code
        -- all the others emit just a single CPS graph's worth
        -- without globals, or even less.
        let ns = Namespace standard.
        let def = self convertClass: "class Test \{}
                                          method test
                                              self opaqueIdentity :: Test!
                                      end"
                      with: []
                      in: ns.
        assert that: { CBackend emitToString: def }
               equals: "/**
 * Foolang generated code - do not edit by hand!
 */

#include \"foolang.h\"

struct FooClass foo_class_1;
struct FooClass foo_class_2;
struct FooClass foo_class_3;
struct FooClass foo_class_4;
struct FooClass foo_class_5;

// \"Boolean\"
struct FooBytes foo_string_6 = \{
    .size = 7,
    .data = \{ 'B','o','o','l','e','a','n', 0 }
};

// \"ifFalse:\"
struct FooBytes foo_string_9 = \{
    .size = 8,
    .data = \{ 'i','f','F','a','l','s','e',':', 0 }
};

// #ifFalse:
struct FooSelector foo_selector_8 = \{
    .name = &foo_string_9
};

// #<BuiltinMethodImpl ifFalse:>
char* foo_builtin_10(char* sp, struct Actor* actor) \{
    printf(\"TODO: #<CpsSelector ifFalse:>\");
    exit(1);
}

// #<BuiltinMethod Boolean#ifFalse:>
struct FooMethod foo_method_7 = \{
    .home = &foo_class_1,
    .selector = &foo_selector_8,
    .method_function = foo_builtin_10
};

// \"ifTrue:\"
struct FooBytes foo_string_13 = \{
    .size = 7,
    .data = \{ 'i','f','T','r','u','e',':', 0 }
};

// #ifTrue:
struct FooSelector foo_selector_12 = \{
    .name = &foo_string_13
};

// #<BuiltinMethodImpl ifTrue:>
char* foo_builtin_14(char* sp, struct Actor* actor) \{
    printf(\"TODO: #<CpsSelector ifTrue:>\");
    exit(1);}

// #<BuiltinMethod Boolean#ifTrue:>
struct FooMethod foo_method_11 = \{
    .home = &foo_class_1,
    .selector = &foo_selector_12,
    .method_function = foo_builtin_14
};

// \"ifTrue:ifFalse:\"
struct FooBytes foo_string_17 = \{
    .size = 15,
    .data = \{ 'i','f','T','r','u','e',':','i','f','F','a','l','s','e',':', 0 }
};

// #ifTrue:ifFalse:
struct FooSelector foo_selector_16 = \{
    .name = &foo_string_17
};

// #<BuiltinMethodImpl ifTrue:ifFalse:>
char* foo_builtin_18(char* sp, struct Actor* actor) \{
    printf(\"TODO: #<CpsSelector ifTrue:ifFalse:>\");
    exit(1);}

// #<BuiltinMethod Boolean#ifTrue:ifFalse:>
struct FooMethod foo_method_15 = \{
    .home = &foo_class_1,
    .selector = &foo_selector_16,
    .method_function = foo_builtin_18
};

// \"opaqueIdentity\"
struct FooBytes foo_string_21 = \{
    .size = 14,
    .data = \{ 'o','p','a','q','u','e','I','d','e','n','t','i','t','y', 0 }
};

// #opaqueIdentity
struct FooSelector foo_selector_20 = \{
    .name = &foo_string_21
};

// #<BuiltinMethodImpl opaqueIdentity>
char* foo_builtin_22(char* sp, struct Actor* actor) \{
    datum_t class = ARG_DATUM(sp, 2);
    datum_t datum = ARG_DATUM(sp, 1);
    datum_t cont = POP_FRAME(sp, 3);
    PUSH_DATUM(sp, class);
    PUSH_DATUM(sp, datum);
    PUSH_DATUM(sp, ARG_OBJS(1));
    PUSH_DATUM(sp, cont);
    return sp;
}

// #<BuiltinMethod Boolean#opaqueIdentity>
struct FooMethod foo_method_19 = \{
    .home = &foo_class_1,
    .selector = &foo_selector_20,
    .method_function = foo_builtin_22
};

// #<MethodDictionary Boolean>
struct FooMethodDictionary foo_methods_23 = \{
    .size = 4,
    .data = \{
        &foo_method_7, // #<BuiltinMethod Boolean#ifFalse:>
        &foo_method_11, // #<BuiltinMethod Boolean#ifTrue:>
        &foo_method_15, // #<BuiltinMethod Boolean#ifTrue:ifFalse:>
        &foo_method_19, // #<BuiltinMethod Boolean#opaqueIdentity>
    }
};

// #<Class Boolean>
struct FooClass foo_class_1 = \{
    .name = &foo_string_6,
    .own_class = &foo_class_2,
    .methods = &foo_methods_23
\};

// \"Boolean class\"
struct FooBytes foo_string_24 = \{
    .size = 13,
    .data = \{ 'B','o','o','l','e','a','n',' ','c','l','a','s','s', 0 }
};

// \"new\"
struct FooBytes foo_string_27 = \{
    .size = 3,
    .data = \{ 'n','e','w', 0 }
};

// #new
struct FooSelector foo_selector_26 = \{
    .name = &foo_string_27
};

// #<BuiltinMethodImpl new>
char* foo_builtin_28(char* sp, struct Actor* actor) \{
    datum_t cont = POP_FRAME(sp, 3);
    PUSH_DATUM(sp, &foo_class_1);
    PUSH_DATUM(sp, 0); // only empty classes for now!
    PUSH_DATUM(sp, ARG_OBJS(1));
    PUSH_DATUM(sp, cont);
    return sp;
}

// #<BuiltinMethod Boolean class#new>
struct FooMethod foo_method_25 = \{
    .home = &foo_class_2,
    .selector = &foo_selector_26,
    .method_function = foo_builtin_28
};

// #<BuiltinMethod Boolean class#opaqueIdentity>
struct FooMethod foo_method_29 = \{
    .home = &foo_class_2,
    .selector = &foo_selector_20,
    .method_function = foo_builtin_22
};

// \"typecheck:\"
struct FooBytes foo_string_32 = \{
    .size = 10,
    .data = \{ 't','y','p','e','c','h','e','c','k',':', 0 }
};

// #typecheck:
struct FooSelector foo_selector_31 = \{
    .name = &foo_string_32
};

// #<BuiltinMethodImpl typecheck:>
char* foo_builtin_33(char* sp, struct Actor* actor) \{
    datum_t expectedClass = ARG_DATUM(sp, 3);
    datum_t actualClass = ARG_DATUM(sp, 2);
    if (want == got) \{
        datum_t actualDatum = ARG_DATUM(sp, 1);
        datum_t cont = POP_FRAME(sp, 5);
        PUSH_DATUM(sp, actualClass);
        PUSH_DATUM(sp, actualDatum);
        PUSH_DATUM(sp, ARG_OBJS(1));
        PUSH_DATUM(sp, cont);
        return sp;
    } else \{
        return runtime_type_error(sp, actor);
    }
}

// #<BuiltinMethod Boolean class#typecheck:>
struct FooMethod foo_method_30 = \{
    .home = &foo_class_2,
    .selector = &foo_selector_31,
    .method_function = foo_builtin_33
};

// #<MethodDictionary Boolean class>
struct FooMethodDictionary foo_methods_34 = \{
    .size = 3,
    .data = \{
        &foo_method_25, // #<BuiltinMethod Boolean class#new>
        &foo_method_29, // #<BuiltinMethod Boolean class#opaqueIdentity>
        &foo_method_30, // #<BuiltinMethod Boolean class#typecheck:>
    }
};

// #<Class Boolean class>
struct FooClass foo_class_2 = \{
    .name = &foo_string_24,
    .own_class = &foo_class_3,
    .methods = &foo_methods_34
\};

// \"Class\"
struct FooBytes foo_string_35 = \{
    .size = 5,
    .data = \{ 'C','l','a','s','s', 0 }
};

// #<BuiltinMethodImpl new>
char* foo_builtin_37(char* sp, struct Actor* actor) \{
    datum_t cont = POP_FRAME(sp, 3);
    PUSH_DATUM(sp, &foo_class_3);
    PUSH_DATUM(sp, 0); // only empty classes for now!
    PUSH_DATUM(sp, ARG_OBJS(1));
    PUSH_DATUM(sp, cont);
    return sp;
}

// #<BuiltinMethod Class#new>
struct FooMethod foo_method_27 = \{
    .home = &foo_class_25,
    .selector = &foo_selector_17,
    .method_function = foo_builtin_28
};

// \"Test\"
struct FooBytes foo_string_2 = \{
    .size = 4,
    .data = \{ 'T','e','s','t', 0 }
};

// \"test\"
struct FooBytes foo_string_9 = \{
    .size = 4,
    .data = \{ 't','e','s','t', 0 }
};

// #test
struct FooSelector foo_selector_8 = \{
    .name = &foo_string_9
};

// #<CpsGraph Test#test>
char* foo_method_function_10(char* sp, struct Actor* actor) \{
    // 0 - $return
    // 1 - $receiver class
    // 2 - $receiver datum
    // 3 - layout word
    // -
    // 4 - $value class
    // 5 - $value datum
    // 6 - layout word
    char* bp = actor->bp = sp - 4 * sizeof(datum_t);
    PUSH_DATUM(sp, 0);
    PUSH_DATUM(sp, 0);
    PUSH_DATUM(sp, OBJS(1));
    datum_t c1 = READ_DATUM(bp, 1);
    datum_t d2 = READ_DATUM(bp, 2);
    PUSH_DATUM(sp, foo_continuation_11);
    PUSH_DATUM(sp, c1);
    PUSH_DATUM(sp, d2);
    PUSH_DATUM(sp, IMMS(1) | OBJS(1));
    PUSH_DATUM(sp, foo_builtin_6); // Test#opaqueIdentity
    return sp;
}

// #<Continuation $bind:13>
char* foo_continuation_11(char* sp, struct Actor* actor) \{
    char* bp = actor->bp;
    WRITE_DATUM(bp, 4, READ_DATUM(sp, -3));
    WRITE_DATUM(bp, 5, READ_DATUM(sp, -2));
    datum_t d0 = READ_DATUM(bp, 0);
    datum_t c4 = READ_DATUM(bp, 4);
    datum_t d5 = READ_DATUM(bp, 5);
    sp = bp;
    PUSH_DATUM(sp, d0);
    PUSH_DATUM(sp, &foo_class_1);
    PUSH_DATUM(sp, &foo_class_13);
    PUSH_DATUM(sp, c4);
    PUSH_DATUM(sp, d5);
    PUSH_DATUM(sp, IMMS(1) | OBJS(2));
    PUSH_DATUM(sp, foo_builtin_12); // Test class#typecheck:
    return sp;
\}

// #<UserMethod Test#test>
struct FooMethod foo_method_7 = \{
    .home = &foo_class_1,
    .selector = &foo_selector_8,
    .method_function = foo_method_function_10
};

// #<MethodDictionary Test>
struct FooMethodDictionary foo_methods_14 = \{
    .size = 2,
    .data = \{
        &foo_method_3, // #<BuiltinMethod Test#opaqueIdentity>
        &foo_method_7, // #<UserMethod Test#test>
    }
};

// \"Test class\"
struct FooBytes foo_string_15 = \{
    .size = 10,
    .data = \{ 'T','e','s','t',' ','c','l','a','s','s', 0 }
};

// #<BuiltinMethod Test class#opaqueIdentity>
struct FooMethod foo_method_20 = \{
    .home = &foo_class_13,
    .selector = &foo_selector_4,
    .method_function = foo_builtin_6
};

// #<BuiltinMethod Test class#typecheck:>
struct FooMethod foo_method_21 = \{
    .home = &foo_class_13,
    .selector = &foo_selector_22,
    .method_function = foo_builtin_12
};

// #<MethodDictionary Test class>
struct FooMethodDictionary foo_methods_24 = \{
    .size = 3,
    .data = \{
        &foo_method_16, // #<BuiltinMethod Test class#new>
        &foo_method_20, // #<BuiltinMethod Test class#opaqueIdentity>
        &foo_method_21, // #<BuiltinMethod Test class#typecheck:>
    \}
\};

// #<BuiltinMethod Class#opaqueIdentity>
struct FooMethod foo_method_29 = \{
    .home = &foo_class_25,
    .selector = &foo_selector_4,
    .method_function = foo_builtin_6
};

// #<BuiltinMethodImpl typecheck:>
char* foo_builtin_31(char* sp, struct Actor* actor) \{
    datum_t expectedClass = ARG_DATUM(sp, 3);
    datum_t actualClass = ARG_DATUM(sp, 2);
    if (want == got) \{
        datum_t actualDatum = ARG_DATUM(sp, 1);
        datum_t cont = POP_FRAME(sp, 5);
        PUSH_DATUM(sp, actualClass);
        PUSH_DATUM(sp, actualDatum);
        PUSH_DATUM(sp, ARG_OBJS(1));
        PUSH_DATUM(sp, cont);
        return sp;
    } else \{
        return runtime_type_error(sp, actor);
    }
}

// #<BuiltinMethod Class#typecheck:>
struct FooMethod foo_method_30 = \{
    .home = &foo_class_25,
    .selector = &foo_selector_22,
    .method_function = foo_builtin_31
};

// #<MethodDictionary Class>
struct FooMethodDictionary foo_methods_32 = \{
    .size = 3,
    .data = \{
        &foo_method_27, // #<BuiltinMethod Class#new>
        &foo_method_29, // #<BuiltinMethod Class#opaqueIdentity>
        &foo_method_30, // #<BuiltinMethod Class#typecheck:>
    \}
\};

// #<Class>
struct FooClass foo_class_25 = \{
    .name = &foo_string_26,
    .own_class = &foo_class_25,
    .methods = &foo_methods_32
\};

// #<Class Test class>
struct FooClass foo_class_13 = \{
    .name = &foo_string_15,
    .own_class = &foo_class_25,
    .methods = &foo_methods_24
\};

// #<Class Test>
struct FooClass foo_class_1 = \{
    .name = &foo_string_2,
    .own_class = &foo_class_13,
    .methods = &foo_methods_14
\};
"!

    method test_c_backend_emit_main_42
        let ns = Namespace standard.
        let def = self convertClass: "class Main \{}
                                          method run: command in: system
                                              42!
                                      end"
                      with: [IntegerClassDefinition]
                      in: ns.
        let expected = (system currentDirectory / "tests/c-backend/main_42.c")
                           readString.
        assert that: { CBackend emitMainToString: def in: ns }
               equals: expected!


    method test_c_backend_emit_main_gcd
        let ns = Namespace standard.
        let def = self convertClass: "class Main \{}
                                          method gcd: a::Integer of: b::Integer
                                              a is 0
                                                  ifTrue: \{ return b }.
                                              b is 0
                                                  ifTrue: \{ return a }.
                                              let q = a // b.
                                              let r = a - q * b.
                                              self gcd: b of: r!
                                          method run: command in: system
                                              self gcd: 12 of: 4!
                                      end"
                      with: [IntegerClassDefinition]
                      in: ns.
        let expected = (system currentDirectory / "tests/c-backend/main_gcd.c")
                           readString.
        assert that: { CBackend emitMainToString: def in: ns }
               equals: expected!


    method test_convert_addition_of_integers_optimizes_to_operation_addi
        let cps = self convertExpr: "let a = X a :: Integer. let b = X b :: Integer. a + b"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:45($bind:40, findMethod:44(classOf:27(X:Global), #a))(X:Global)
$bind:40($value:34):
    apply:38($let:33, Integer class#typecheck:)(Integer:Global, $value:34)
$let:33(a::Integer:5):
    apply:29($bind:24, findMethod:28(classOf:27(X:Global), #b))(X:Global)
$bind:24($value:17):
    apply:22($let:16, Integer class#typecheck:)(Integer:Global, $value:17)
$let:16(b::Integer:6):
    $return:3(makeInstance:60(Integer, addi:59(datumOf:57(b::Integer:6), datumOf:58(a::Integer:5))))
"!

    method test_convert_arity_0_block
        let cps = self convertExpr: "\{ 421 }"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3($block:7)
$block:7($ret:5):
    $ret:5(421)
"!


    method test_convert_arity_3_block
        let cps = self convertExpr: "\{ |a b c| a + b + c }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3($block:24)
$block:24(a:5, b:6, c:7, $ret:4):
    apply:21($bind_recv:16, findMethod:20(classOf:19(a:5), #+))(a:5, b:6)
$bind_recv:16($recv:8):
    apply:13($ret:4, findMethod:12(classOf:11($recv:8), #+))($recv:8, c:7)
"!


    method test_convert_boolean_ifFalse
        let cps = self convertExpr: "X :: Boolean ifFalse: \{ 1 }"
                       with: [BooleanClassDefinition,
                              IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:24($bind_recv:18, Boolean class#typecheck:)(Boolean:Global, X:Global)
$bind_recv:18($recv::Boolean:6):
    select:35($recv::Boolean:6, $ifTrue:34, $block:16)()
$ifTrue:34():
    $return:3(False)
$block:16():
    $return:3(1)
"!


    method test_convert_boolean_ifTrue
        let cps = self convertExpr: "X :: Boolean ifTrue: \{ 1 }"
                       with: [BooleanClassDefinition,
                              IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:24($bind_recv:18, Boolean class#typecheck:)(Boolean:Global, X:Global)
$bind_recv:18($recv::Boolean:6):
    select:35($recv::Boolean:6, $block:16, $ifFalse:34)()
$block:16():
    $return:3(1)
$ifFalse:34():
    $return:3(False)
"!


    method test_convert_boolean_ifTrueIfFalse
        let cps = self convertExpr: "X :: Boolean ifTrue: \{ 1 } ifFalse: \{ 2 }"
                       with: [BooleanClassDefinition,
                              IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:30($bind_recv:24, Boolean class#typecheck:)(Boolean:Global, X:Global)
$bind_recv:24($recv::Boolean:6):
    select:38($recv::Boolean:6, $block:22, $block:17)()
$block:22():
    $return:3(1)
$block:17():
    $return:3(2)
"!


    method test_convert_result_type_of_addi_known
        let cps = self convertExpr: "let x = X :: Integer. (x + x) :: Integer"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:28($let:23, Integer class#typecheck:)(Integer:Global, X:Global)
$let:23(x::Integer:5):
    $return:3(makeInstance:43(Integer, addi:42(datumOf:41(x::Integer:5), datumOf:41(x::Integer:5))))
"!


    method test_convert_closure_whileFalse
        let cps = self convertExpr: "\{ X maybe\} whileFalse: \{ Y something \}".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $loopTest:36(False)
$loopTest:36($ignore:35):
    apply:28($whileFalse:42, findMethod:27(classOf:26(X:Global), #maybe))(X:Global)
$whileFalse:42($cond:40):
    select:41($cond:40, $loopExit:39, $loopBody:37)()
$loopExit:39():
    $return:3(False)
$loopBody:37():
    apply:17($loopTest:36, findMethod:16(classOf:15(Y:Global), #something))(Y:Global)
"!


    method test_convert_closure_whileTrue
        let cps = self convertExpr: "\{ X maybe\} whileTrue: \{ X something \}".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $loopTest:35(False)
$loopTest:35($ignore:34):
    apply:28($whileTrue:41, findMethod:27(classOf:15(X:Global), #maybe))(X:Global)
$whileTrue:41($cond:39):
    select:40($cond:39, $loopBody:36, $loopExit:38)()
$loopBody:36():
    apply:17($loopTest:35, findMethod:16(classOf:15(X:Global), #something))(X:Global)
$loopExit:38():
    $return:3(False)
"!


    method test_convert_constant_add
        let cps = self convertExpr: "123 + X::Integer"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:18($bind_arg:12, Integer class#typecheck:)(Integer:Global, X:Global)
$bind_arg:12($arg::Integer:6):
    $return:3(makeInstance:37(Integer, addi:36(datumOf:34($arg::Integer:6), 123::Datum)))
"!


    method test_convert_constant_integer
        let cps = self convertExpr: "123"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(123)
"!


    method test_convert_constructor
        let namespace = Namespace standard.
        let def = self convertClass: "
class A \{}
    direct method test
        self new!
end"
                      with: [IntegerClassDefinition]
                      in: namespace.
        let cps = (def type findMethod: (namespace intern: "test")) cps.
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3, $receiver::A class:4):
    $return:3(#<Instance A>)
"!

    method test_convert_untyped_method_argument
        let ns = Namespace standard.
        let def = self convertClass: "class UntypedArgTest \{}
                                          method succ: x
                                              x + 1!
                                      end"
                      with: [IntegerClassDefinition]
                      in: ns.
        let cps = (def findMethod: (ns intern: "succ:")) cps.
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3, $receiver::UntypedArgTest:4, x:7):
    apply:13($return:3, findMethod:12(classOf:11(x:7), #+))(x:7, 1)
"!


    method test_convert_typed_method_argument
        let ns = Namespace standard.
        let def = self convertClass: "class TypedArgTest \{}
                                          method next: x::Integer
                                              x + 1!
                                          end"
                      with: [IntegerClassDefinition]
                      in: ns.
        let cps = (def findMethod: (ns intern: "next:")) cps.
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3, $receiver::TypedArgTest:4, x::Integer:7):
    $return:3(makeInstance:29(Integer, addi:28(1::Datum, datumOf:27(x::Integer:7))))
"!


    method test_convert_global
        let cps = self convertExpr: "X".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(X:Global)
"!


    method test_convert_sends_to_self_resolved
        let namespace = Namespace standard.
        let def = self convertClass: "
class A \{}
    method a
        self b + self c!
    method b
        174!
    method c
        214!
end"
                      with: [IntegerClassDefinition]
                      in: namespace.
        assert that: { CpsPrinter printToString: (def findMethod: (namespace intern: "a")) cps }
               equals: "
$entry:2($return:3, $receiver::A:4):
    $return:3(388)
"!


    method test_convert_inline_sends_to_self
        let namespace = Namespace standard.
        let def = self convertClass: "
class A \{}
    direct method test
        self new a!
    method a
        self b + self c!
    method b
        174!
    method c
        213!
end"
                      with: [IntegerClassDefinition]
                      in: namespace.
        let cps = (def type findMethod: (namespace intern: "test")) cps.
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3, $receiver::A class:4):
    $return:3(387)
"!


    method test_convert_selector
        let cps = self convertExpr: "#foobar"
                       with: [SelectorClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(#foobar)
"!


    method test_convert_let
        let cps = self convertExpr: "let x = 87. x"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(87)
"!


    method test_convert_return
        let cps = self convertExpr: "return 421. X boom"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(421)
"!


    method test_convert_seq
        let cps = self convertExpr: "X some: 12 message: 97. Y + Z"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:24($seq:17, findMethod:23(classOf:22(X:Global), #some:message:))(X:Global, 12, 97)
$seq:17($ignore:16):
    apply:10($return:3, findMethod:9(classOf:8(Y:Global), #+))(Y:Global, Z:Global)
"!


    method test_convert_typecheck
        let cps = self convertExpr: "X :: Integer".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:9($return:3, findMethod:8(classOf:7(Integer:Global), #typecheck:))(Integer:Global, X:Global)
"!


    method test_convert_typecheck_gives_type
        let cps = self convertExpr: "X::Integer + Y"
                       with: [(ClassDefinition
                                   name: "Integer"
                                   methods: [(UserMethod selector: "+" intern)])].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:20($bind_recv:14, Integer class#typecheck:)(Integer:Global, X:Global)
$bind_recv:14($recv::Integer:5):
    apply:10($return:3, Integer#+)($recv::Integer:5, Y:Global)
"!


    method test_convert_typecheck_redundancy
        let cps = self convertExpr: "X :: Integer :: Integer"
                       with: [(ClassDefinition name: "Integer")].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:17($bind:12, Integer class#typecheck:)(Integer:Global, X:Global)
$bind:12($value::Integer:5):
    $return:3($value::Integer:5)
"!


    method test_eval_send_message
        let cps = self convertExpr: "123 opaqueIdentity + 321"
                       with: [IntegerClassDefinition].
        assert that: { (CpsEvaluator eval: cps) hostValue }
               equals: 444!


    method test_graphwiz_closure_whileTrue
        let cps = self convertExpr: "\{ X maybe\} whileTrue: \{ X something \}".
        (system currentDirectory / "closure_whileTrue.dot")
            truncateExisting forWrite
                createOrOpen: { |dot|
                                CpsGraphwizPrinter
                                    print: cps
                                    to: dot }.
        assert that: { CpsGraphwizPrinter printToString: cps }
               equals: "
strict digraph \{
    \"$entry:2\" [color=red]
    \"$entry:2\" [shape=box]
    \"$entry:2\" -> \"$return:3\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]
    \"False\" -> \"$entry:2\" [style=dotted]
    \"$entry:2\" -> \"$loopTest:35\" [arrowhead=vee]
    \"$loopTest:35\" [shape=box]
    \"findMethod:27(classOf:15(X:Global), #maybe)\" -> \"$loopTest:35\" [style=dotted]
    \"X:Global\" -> \"$loopTest:35\" [style=dotted]
    \"$loopTest:35\" -> \"$whileTrue:41\" [arrowhead=vee]
    \"$whileTrue:41\" [shape=box]
    \"$whileTrue:41\" -> \"$cond:39\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]
    \"$cond:39\" -> \"$whileTrue:41\" [style=dotted]
    \"$whileTrue:41\" -> \"$loopBody:36\" [arrowhead=vee]
    \"$whileTrue:41\" -> \"$loopExit:38\" [arrowhead=vee]
    \"$loopBody:36\" [shape=box]
    \"findMethod:16(classOf:15(X:Global), #something)\" -> \"$loopBody:36\" [style=dotted]
    \"X:Global\" -> \"$loopBody:36\" [style=dotted]
    \"$loopBody:36\" -> \"$loopTest:35\" [arrowhead=vee]
    \"classOf:15(X:Global)\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"#something\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"classOf:15(X:Global)\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"#something\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"classOf:15(X:Global)\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
    \"#maybe\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
    \"X:Global\" -> \"classOf:15(X:Global)\" [style=dotted]
    \"$loopExit:38\" [shape=box]
    \"False\" -> \"$loopExit:38\" [style=dotted]
    \"$loopExit:38\" -> \"$return:3\" [arrowhead=vee]
    \"classOf:15(X:Global)\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
    \"#maybe\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
}
"!


    method test_eval_sends_to_self_in_direct_method
        let namespace = Namespace standard.
        let def = self convertClass: "
class A \{}
    direct method test
        self opaqueIdentity a + self opaqueIdentity b!
    direct method a
        90!
    direct method b
        88!
end"
                      with: [IntegerClassDefinition]
                      in: namespace.
        assert true: { ClassDefinition includes: def }.
        let cps = self convertExpr: "A test"
                       with: [def]
                       in: namespace.
        assert that: { (CpsEvaluator eval: cps) hostValue }
               equals: 178!


    method test_eval_sends_to_self_in_instance_method
        let namespace = Namespace standard.
        let def = self convertClass: "
class A \{}
    direct method test
        self new a!
    method a
        self opaqueIdentity b + self opaqueIdentity c!
    method b
        981!
    method c
        231!
end"
                      with: [IntegerClassDefinition]
                      in: namespace.
        assert true: { ClassDefinition includes: def }.
        let cps = self convertExpr: "A test"
                       with: [def]
                       in: namespace.
        assert that: { (CpsEvaluator eval: cps) hostValue }
               equals: 1212!


    method test_eval_typecheck_literal
        let cps = self convertExpr: "123 :: Integer"
                       with: [IntegerClassDefinition].
        assert that: { (CpsEvaluator eval: cps) hostValue }
               equals: 123!


    method test_optimize_datumOf_makeInstance_pairs_eliminated
        let cps = self convertExpr: "let a = X a :: Integer.
                                     let b = X b :: Integer. a + b + a + b"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:61($bind:56, findMethod:60(classOf:43(X:Global), #a))(X:Global)
$bind:56($value:50):
    apply:54($let:49, Integer class#typecheck:)(Integer:Global, $value:50)
$let:49(a::Integer:5):
    apply:45($bind:40, findMethod:44(classOf:43(X:Global), #b))(X:Global)
$bind:40($value:33):
    apply:38($let:32, Integer class#typecheck:)(Integer:Global, $value:33)
$let:32(b::Integer:6):
    $return:3(makeInstance:88(Integer, addi:87(datumOf:73(b::Integer:6), addi:81(datumOf:74(a::Integer:5), addi:75(datumOf:73(b::Integer:6), datumOf:74(a::Integer:5))))))
"!

    method test_postOrder_whileTrue
        let cps = self convertExpr: "\{ X maybe\} whileTrue: \{ X something \}".
        let order = List new.
        PostOrder for: cps entry
                  do: { |each| order push: each id }.
        assert that: { order asArray }
               equals: [36, 38, 41, 35, 2]!


    method test_preOrder_whileTrue
        let cps = self convertExpr: "\{ X maybe\} whileTrue: \{ X something \}".
        let order = List new.
        PreOrder for: cps entry
                 do: { |each| order push: each id }.
        assert that: { order asArray }
               equals: [2, 35, 41, 36, 38]!


    method test_reversePostOrder_whileTrue
        let cps = self convertExpr: "\{ X maybe\} whileTrue: \{ X something \}".
        let order = List new.
        ReversePostOrder for: cps entry
                         do: { |each| order push: each id }.
        assert that: { order asArray }
               equals: [2, 35, 41, 38, 36]!
end


class Main {}
    direct method run: command in: system
        let assert = Assert reportingTo: system output.
        TestCPS runTests: assert
                in: system
                with: command.
        system exit: assert exitCode!
end
