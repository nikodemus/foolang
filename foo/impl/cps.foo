import lib.assert.Assert
import .parser.Parser


interface Log
    direct method newline
        Output debug newline!
    direct method print: what
        Output debug print: what!
    direct method println: what
        Output debug println: what!
end


interface CpsValue
    -- Valid value to flow through CPS in evaluator
    -- or as a constant.
    required method printName
    required method type
    required method hostValue
end


class CpsSelector { name }
    is Object
    is CpsValue

    method < other
        name < other name!

    method toString
        "#<CpsSelector {name}>"!

    method displayOn: stream
        stream writeString: "#<CpsSelector {name}>"!

    method printName
        "#{name}"!

    method hostValue
        Selector intern: name!

    method type
        self classDefinitionImpl!
end


class Namespace { _dictionary _sealed }
    -- For interning selectors
    direct method empty
        self _dictionary: Dictionary new
             _sealed: False!


    direct method standard
        StandardNamespace copy!


    method intern: name
        _dictionary
            at: name
            ifNonePut: { _sealed
                             ifTrue: { Error raise: "Cannot intern {name displayString} in a sealed namespace!" }.
                         CpsSelector name: name }!


    method seal
        _sealed = True.
        self!


    method copy
        Namespace _dictionary: _dictionary copy
                  _sealed: False!
end


define StandardNamespace
    let namespace = Namespace empty.
    [
         "+",
         "addInteger:",
         "ifFalse:",
         "ifTrue:",
         "ifTrue:ifFalse:",
         "new",
         "opaqueIdentity",
         "typecheck:",
         "whileFalse:",
         "whileTrue:"
    ]
    do: { |each|
          namespace intern: each }.
    namespace seal!


extend String
    -- This is the solution to allowing users to
    -- intern without special objects: they cannot
    -- intern new things!
    method intern
        StandardNamespace intern: self!
end


interface MethodDefinition
    is Object
    is CpsValue

    method name
        -- FIXME: why is this needed? some errors provoke it in turn
        self selector name!


    method returnType
        False!


    method inlineIn: _ in: _ with: _
        False!


    method printName
        "{self home name}#{self selector name}"!


    method toString
        "#<{self classOf name} {self home name}#{self name}>"!


    method visitBy: visitor
        visitor visitMethodDefinition: self!


    method hostValue
        self!


    method type
        MethodClassDefinition!


    method isStandard
        True!
end


class UserMethod { selector home cps }
    is MethodDefinition

    direct method selector: selector
        self selector: selector
             home: False
             cps: False!


    direct method selector: selector cps: cps
        self selector: selector
             home: False
             cps: cps!


    method home: new
        (home is False)
            ifFalse: { Error raise: "{self} already has a home: {home}" }.
        home = new!


    method cps: new
        (cps is False)
            ifFalse: { Error raise: "{self} already has a cps: {cps}" }.
        cps = new!


    method displayOn: stream
        stream writeString: "#<UserMethod {selector name}>"!


    method isStandard
        False!


    method apply: args
        cps is False
            ifTrue: { Error raise: "{self} has no body, cannot apply!" }.
        cps apply: args!


    method inlineIn: aCont in: graph with: worklist
        cps is False
            ifTrue: { return False }.
        let cc = aCont target target.
        aCont target: (CpsCopier copy: cps entry to: graph).
        aCont prependArgs: [cc].
        worklist push: aCont!

end


class BuiltinMethod { home impl }
    is MethodDefinition

    direct method new: impl
        self home: False
             impl: impl!


    method selector
        impl selector!


    method apply: args
        impl apply: args in: home!


    method returnType
        impl returnType!


    method inlineIn: aCont in: graph with: worklist
        impl inlineIn: aCont in: graph with: worklist!


    method home: new
        (home is False)
            ifFalse: { Error raise: "BuiltinMethod {self selector name} already has a home: {home}" }.
        home = new!
end


interface BuiltinMethodImpl
    method returnType
        False!
end


class OpaqueIdentityImpl {}
    -- Very useful for compiler testing.
    is BuiltinMethodImpl

    direct method for: _
        self new!


    method selector
        "opaqueIdentity" intern!


    method inlineIn: _aCont in: _aGraph with: _worklist
        False!


    method apply: args in: _classDefinition
        args first!
end


class ConstructorImpl { classDefinition }
    is BuiltinMethodImpl

    direct method for: classDefinition
        self classDefinition: classDefinition!


    method returnType
        classDefinition!


    method selector
        "new" intern!


    method inlineIn: continuation in: graph with: worklist
        continuation removeArgs.
        continuation addArgs: [graph ensureOperation: MAKE_INSTANCE
                                     args: [graph ensureConstant: classDefinition,
                                            graph ensureConstant: (Instance class: IntegerClassDefinition
                                                                            datum: 0)]].
        continuation target: continuation target :: Application target!


    method apply: args in: _classDefinition
        Log println: "\nNEW: {args}".
        Instance class: args first
                 datum: args second!
end


class TypecheckImpl { type }
    is BuiltinMethodImpl

    direct method for: type
        self type: type!


    method selector
        "typecheck:" intern!


    method apply: args in: _
        let value = args second.
        value type is type
            ifFalse: { Error raise: "CPS type error! Wanted: {type}, got: {value} ({value type})" }.
        value!


    method returnType
        type!


    method inlineIn: aContinuation in: graph with: worklist
        (aContinuation args size is 2) assert: "TypecheckImpl#inlineIn:in:with".
        let apply = aContinuation target.
        let value = aContinuation args at: 2.
        let valueType = value type.
        let cc = apply target.

        -- If value has the correct type, we can eliminate
        -- the typecheck entirely.
        --
        -- Otherwise we propagate the type to cc.
        valueType is type
            ifTrue: { aContinuation removeArgs.
                      aContinuation addArgs: [value].
                      aContinuation target: cc }
            ifFalse: { (cc uses isOnly: apply)
                           => { cc propagateTypes: [type] } }.
        (Continuation includes: cc)
            ifTrue: { worklist pushAll: cc params first uses }!
end


interface InlineMethodImpl
    is BuiltinMethodImpl


    method apply: args in: classDefinition
        let pattern = self inliner apply: args.
        let newRecv = pattern first.
        let newSelector = pattern second.
        (newRecv type :: ClassDefinition findMethod: newSelector)
            apply: ([newRecv]
                        append: (pattern
                                     from: 3
                                     to: pattern size))!


    method inlineIn: aContinuation in: graph with: worklist
        let apply = aContinuation target.
        let args = aContinuation args.
        let pattern = self inliner apply: args.
        let newRecv = pattern first.
        let newSelector = pattern second.
        let newMethod = graph ensureFindMethod: newSelector
                              for: newRecv.
        let newApply = graph application: newMethod
                             target: apply target.
        aContinuation target: newApply.
        aContinuation removeArgs.
        aContinuation addArgs: [newRecv].
        aContinuation addArgs: (pattern from: 3 to: pattern size).
        -- CLASS_OF is new
        worklist push: newMethod args first.
        -- FIND_METHOD is new
        worklist push: newMethod.
        -- APPLY is new
        worklist push: newApply.
        -- Continuation has changed.
        worklist push: aContinuation!
end


class IntegerPlusImpl {}
    is InlineMethodImpl

    method selector
        "+" intern!

    method inliner
        { |a b| [b, "addInteger:" intern, a] }!
end


interface PrimitiveInlineMethodImpl
    is BuiltinMethodImpl

    method apply: args in: _classDefinition
        let pattern = self primitiveInliner apply: args.
        self evalPattern: pattern!

    method inlineIn: aContinuation in: graph with: worklist
        let apply = aContinuation target.
        let pattern = self primitiveInliner apply: aContinuation args.
        let primop = self buildPattern: pattern in: graph with: worklist.
        -- Log println: "XXX: inline: {primop printName}".
        let cc = apply target.
        aContinuation removeArgs.
        aContinuation addArgs: [primop].
        aContinuation target: cc.
        cc propagateTypes: [primop type].
        worklist push: aContinuation!

    method evalPattern: pattern
        (Array includes: pattern)
            ifTrue: { let op = pattern first.
                      let args = pattern rest collect: { |each| self evalPattern: each }.
                      return op apply: args }
            ifFalse: { pattern }!

    method buildPattern: pattern in: graph with: worklist
        (Expression includes: pattern)
            ifTrue: { return pattern }.
        (Array includes: pattern)
            ifTrue: { let op = graph ensureOperation: pattern first
                                     args: (pattern rest
                                                collect: { |each|
                                                           self buildPattern: each
                                                                in: graph
                                                                with: worklist }).
                      worklist push: op.
                      return op }.
        -- Eg. "inline reference" to IntegerClassDefinition.
        (CpsValue includes: pattern)
            ifFalse: { Error raise: "Unexpected value in builPattern: {pattern}" }.
        graph ensureConstant: pattern!
end


class IntegerAddIntegerImpl {}
    is PrimitiveInlineMethodImpl

    method selector
        "addInteger:" intern!


    method primitiveInliner
        { |a b|
          [MAKE_INSTANCE, IntegerClassDefinition,
           [ADDI, [DATUM_OF, a], [DATUM_OF, b]]] }!
end


class IfTrueIfFalseImpl { ifTrue ifFalse }
    is BuiltinMethodImpl

    method selector
        (ifTrue and: ifFalse)
            => { return "ifTrue:ifFalse:" intern }.
        ifTrue
            => { return "ifTrue:" intern }.
        ifFalse
            => { return "ifFalse:" intern }.
        Error raise: "Invalid IfTrueIfFalseImpl!"!

    method inlineIn: aContinuation in: graph with: worklist
        let lastArg = (ifTrue and: ifFalse)
                          ifTrue: { 3 }
                          ifFalse: { 2 }.
        (aContinuation args size is lastArg) assert: "IfTrueIfFalseImpl#inlineIn:in:with".
        let apply = aContinuation target.
        let args = aContinuation args.
        let cond = args at: 1.
        let thenCont = ifTrue
                           ifTrue: { (args at: 2) }
                           ifFalse: { let ret = graph makeVariable: "$ret".
                                      graph continuation: "$ifTrue"
                                            params: [ret]
                                            target: ret
                                            args: [graph ensureConstant: FalseDefinition] }.
        let elseCont = ifFalse
                           ifTrue: { (args at: lastArg) }
                           ifFalse: { let ret = graph makeVariable: "$ret".
                                      graph continuation: "$ifFalse"
                                            params: [ret]
                                            target: ret
                                            args: [graph ensureConstant: FalseDefinition] }.
        -- Need to change args before replacing target: otherwise old
        -- apply target would become unused and get flushed!
        aContinuation removeArgs.
        aContinuation addArgs: [apply target].
        aContinuation target: (graph select: cond
                                     then: thenCont
                                     else: elseCont).
        -- Log println: "INLINED IF".
        -- Log println: (CpsPrinter printToString: graph).
        False!
end


class WhileLoopImpl { selector while }
    is BuiltinMethodImpl

    direct method while: maybe
        self selector: ("while{maybe}:" intern)
             while: maybe!


    method inlineIn: aContinuation in: graph with: worklist
        (aContinuation args size is 2) assert: "WhileLoopImpl#inlineIn:in:with".
        let ignore1 = graph makeVariable: "$ignore".
        -- valueCont args will be patched with the branch
        let valueCont = graph continuation: "$loopTest"
                              params: [ignore1]
                              target: (aContinuation args at: 1)
                              args: [].
        let bodyCont = graph continuation: "$loopBody"
                             params: []
                             target: (aContinuation args at: 2)
                             args: [valueCont].
        -- Explicit loop exit continuation so we don't need to
        -- pass False as argument to selected continuation each time
        -- through the branch.
        let exitCont = graph continuation: "$loopExit"
                             params: []
                             target: (aContinuation target target)
                             args: [graph ensureConstant: FalseDefinition].
        let cond = graph makeVariable: "$cond".
        let thenElse = while
                           ifTrue: { [bodyCont, exitCont] }
                           ifFalse: { [exitCont, bodyCont] }.
        let branch = graph continuation: "$while{while}"
                           params: [cond]
                           target: (graph select: cond
                                          then: thenElse first
                                          else: thenElse second)
                           args: [].
        valueCont addArgs: [branch].
        let headCont = graph continuation: "$loopHead"
                             params: aContinuation params copy
                             target: valueCont
                             args: [graph ensureConstant: FalseDefinition].
        aContinuation removeArgs.
        aContinuation replaceUsesWith: headCont in: worklist.
        aContinuation target: INVALID_TARGET.
        aContinuation removeParams.
        worklist push: headCont.
        worklist push: valueCont.
        worklist push: bodyCont.
        worklist push: exitCont!
end


class ClassDefinition { name
                        hostClass
                        ownClassDefinition
                        methodDictionary }
    is Object
    is CpsValue

    -- ClassDefinition itself is used as the ClassDefinition for Class.
    -- Clever, yes? Horrible, maybe!
    direct method name
        "Class"!


    direct method type
        self!


    direct method name: name
        self
            name: name
            hostClass: False
            methods: []
            directMethods: []!


    direct method name: name methods: methods
        self
            name: name
            hostClass: False
            methods: methods
            directMethods: []!


    direct method name: name methods: methods directMethods: directMethods
        self
            name: name
            hostClass: False
            methods: methods
            directMethods: directMethods!


    direct method hostClass: hostClass methods: methods
        self
            name: hostClass name
            hostClass: hostClass
            methods: methods
            directMethods: []!


    direct method name: name hostClass: hostClass methods: methods
        self
            name: name
            hostClass: hostClass
            methods: methods
            directMethods: []!


    direct method name: name hostClass: hostClass
                  methods: methods directMethods: directMethods
        let instanceMethodDictionary = Dictionary new.
        let directMethodDictionary = Dictionary new.
        let ownClassDefinition = self name: "{name} class"
                                      hostClass: hostClass classOf
                                      ownClassDefinition: ClassDefinition
                                      methodDictionary: directMethodDictionary.
        let classDefinition = self name: name
                                   hostClass: hostClass
                                   ownClassDefinition: ownClassDefinition
                                   methodDictionary: instanceMethodDictionary.

        methods
            do: { |each| classDefinition addMethod: each }.
        self standardInstanceMethodImpls
            do: { |each|
                  classDefinition addMethod: (BuiltinMethod new: (each for: classDefinition)) }.

        directMethods
            do: { |each| ownClassDefinition addMethod: each }.
        self standardDirectMethodImpls
            do: { |each|
                  ownClassDefinition addMethod: (BuiltinMethod new: (each for: classDefinition)) }.

        classDefinition!


    direct method standardInstanceMethodImpls
        [OpaqueIdentityImpl]!


    direct method standardDirectMethodImpls
        [
            ConstructorImpl,
            OpaqueIdentityImpl,
            TypecheckImpl,
        ]!


    method addMethod: aMethod
        aMethod home: self.
        methodDictionary
            put: aMethod
            at: aMethod selector!


    method isPrimitive
        (hostClass is False) not!


    method printName
        name!


    method type
        ownClassDefinition!


    method hostValue
        hostClass is False
            ifTrue: { Error raise: "No host definition for {self}" }
            ifFalse: { hostClass }!


    method findMethod: name::CpsSelector
        methodDictionary at: name!


    method findMethod: name::CpsSelector ifNone: block
        methodDictionary at: name ifNone: block!


    method displayString
        name!

    method toString
        name!
end


class Datum { value }
    is Object
    is CpsValue

    method toString
        -- Instances don't get an explicit marker of
        -- being such.
        "{value displayString}::Datum"!

    method printName
        self toString!

    method displayString
        self toString!

    method hostValue
        value!

    method type
        Error raise: "Datum has no type!"!
end

class Instance { _class::ClassDefinition
                 _datum }
    is Object
    is CpsValue

    direct method class: aClass datum: aDatum
        self _class: aClass
             _datum: aDatum!

    method type
        _class!

    method hostValue
        _datum!

    method printName
        self toString!

    method toString
        _class isPrimitive
            ifTrue: { _datum displayString }
            ifFalse: { "#<Instance {_class name}>" }!

    method displayString
        self toString!

    method == other
        (Instance includes: other)
            ifTrue: { _class is other type
                          ifTrue: { _datum == other hostValue } }!
end


define BooleanClassDefinition
    (ClassDefinition
         hostClass: Boolean
         methods: [BuiltinMethod new: (IfTrueIfFalseImpl ifTrue: True ifFalse: True),
                   BuiltinMethod new: (IfTrueIfFalseImpl ifTrue: True ifFalse: False),
                   BuiltinMethod new: (IfTrueIfFalseImpl ifTrue: False ifFalse: True)])!


define FalseDefinition
    (Instance
         class: BooleanClassDefinition
         datum: False)!


define FunctionClassDefinition
    (ClassDefinition
         name: "Function"
         hostClass: Closure
         methods: [BuiltinMethod new: (WhileLoopImpl while: True),
                   BuiltinMethod new: (WhileLoopImpl while: False)])!


define IntegerClassDefinition
    (ClassDefinition
         hostClass: Integer
         methods: [BuiltinMethod new: IntegerPlusImpl new,
                   BuiltinMethod new: IntegerAddIntegerImpl new,
                   BuiltinMethod new: OpaqueIdentityImpl new])!


define MethodClassDefinition
    (ClassDefinition
         name: "Method"
         methods: [])!


define SelectorClassDefinition
    (ClassDefinition
         name: "Selector"
         methods: [])!


-- KLUDGE: Bootstrap evaluator is picky about order of definitions
extend CpsSelector
    method classDefinitionImpl
        SelectorClassDefinition!
end


class Set { dict }
    is Object

    direct method new
        self dict: Dictionary new!


    direct method with: node
        let new = self new.
        new add: node.
        new!


    method add: node
        let old = dict at: node.
        dict put: node at: node.
        old is False!


    method remove: node
        dict remove: node!


    method collect: block
        dict keys collect: block!


    method includes: node
        ((dict at: node) is False) not!


    method singular
        dict size is 1
            ifTrue: { dict values first }!


    method size
        dict size!


    method isEmpty
        dict isEmpty!


    method isOnly: node
        node is self singular!


    method do: block
        dict values do: block!


    method doSorted: block
        dict values sort do: block!
end


interface UseTracking
    method isUnused
        self uses isEmpty!


    method addUse: use
        self uses add: use!


    method removeUse: use
        self uses remove: use.
        self debugVerify: "#removeUse"!


    method replaceUsesWith: new
        self uses do: { |each|
                        each replaceUses: self with: new }.
        self flush!


    method replaceUsesWith: new in: worklist
        self uses do: { |each|
                        each replaceUses: self with: new.
                        worklist push: each }.
        self flush!


    method debugVerify: what
        DebugVerify
            ifTrue: { self verify: what }!


    required method uses
    required method replaceUses: expr1 with: expr2
end


class OpMap { list }
    is Object

    direct method new
        self list: List new!


    method kind: kind withArguments: args ifNonePut: block
        kind isFoldable
            ifTrue: { list do: { |each|
                                 each kind is kind
                                     => { (each args == args)
                                              => { return each } } } }.
        let new = block value.
        list push: new.
        new!


    method mergeDuplicates
        -- FIXME: O(N^2) with current OpMap!
        list do: { |each| self tryMerge: each }!


    method tryMerge: operation
        operation isFoldable
            ifFalse: { return False }.
        operation isUnused
            ifTrue: { return False }.
        list do: { |each| self tryMerge: operation with: each }!


    method tryMerge: op1 with: op2
        op1 is op2
            ifTrue: { return False }.
        op2 isUnused
            ifTrue: { return False }.
        op1 kind is op2 kind
            ifTrue: { op1 args == op2 args
                          ifTrue: { -- Doesn't use #replaceUsesWith: because
                                    -- there's no worklist or need for one.
                                    op2 uses do: { |each|
                                                   each replaceUses: op2 with: op1 } } }!


    method reject: block
        Self list: (list reject: block)!


    method select: block
        Self list: (list select: block)!


    method do: block
        list do: block!
end


class Worklist { list dict }
    is Object

    direct method new
        self list: List new
             dict: Dictionary new!


    method push: thing
        dict at: thing
             ifNonePut: { list push: thing.
                          thing }!


    method pushAll: aList
        aList do: { |each| self push: each }!


    method pop
        let thing = list pop.
        dict remove: thing.
        thing!


    method isEmpty
        list isEmpty!
end


define DebugVerify False!


interface Node
    method < other
        self id < other id!
    required method id
end


interface Expression
    is Object
    is UseTracking
    is Node


    method propagateTypes: _
        False!


    method isConstant
        False!


    method isOperation
        False!


    method simplifyIn: _ with: _
        False!


    method type
        False!


    method verify: _
        False!


    method toString
        "#<{self classOf name} {self printName}>"!


    required method printName
end


interface Childless
    method doChildren: _
        False!
end


class Constant { id::Integer
                 value::CpsValue
                 uses::Set }
    is Expression
    is Childless


    direct method id: id value: value
        (CpsValue includes: value)
            ifFalse: { Error raise: "Constant value not CpsValue: {value} :: {value classOf name}" }.
        self id: id
             value: value
             uses: Set new!


    method isConstant
        True!


    method returnType
        value returnType!


    method type
        value type!


    method printName
        value printName!


    method replaceUses: expr1 with: expr2
        Error raise: "Constant#replaceUses:with: is invalid"!


    method visitBy: visitor
        visitor visitConstant: self!


    method visitBy: visitor with: arg
        visitor visitConstant: self with: arg!
end


class Global { id::Integer
               name::String
               uses::Set
               definition }
    is Expression
    is Childless

    direct method id: id name: name
        self id: id
             name: name
             uses: Set new
             definition: False!


    method definition: new::ClassDefinition
        definition = new!


    method type
        definition is False
            ifTrue: { False }
            ifFalse: { definition type }!


    method replaceUses: expr1 with: expr2
        Error raise: "Global#replaceUses:with: is invalid"!


    method printName
        "{name}:Global"!


    method visitBy: visitor
        visitor visitGlobal: self!
end


interface ContinuationTarget
    is Node

    method doChildren: block
        self doSuccessors: block.
        self doValues: block!
end


interface AtomicContinuationTarget
    is ContinuationTarget
end


class InvalidTarget {}
    is Object
    is AtomicContinuationTarget
    is UseTracking

    method id
        0!

    method uses
        Set new!

    method replaceUses: _ with: _
        False!

    method printName
        "INVALID"!

    method doSuccessors: _
        False!

    method doValues: _
        False!

    method flush
        False!
end


define INVALID_TARGET InvalidTarget new!


class Variable { id::Integer
                 name::String
                 type
                 defs::Set
                 uses::Set }
    is Expression
    is Childless
    is AtomicContinuationTarget

    direct method id: id
        self id: id
             name: False
             type: False
             defs: Set new
             uses: Set new!


    direct method id: id name: name
        self id: id
             name: name
             type: False
             defs: Set new
             uses: Set new!


    direct method id: id name: name type: type
        self id: id
             name: name
             type: type
             defs: Set new
             uses: Set new!


    method renameIfSingleUse: new
        uses size <= 1
            => { name = new }.
        self!


    method addDef: def
        defs add: def!


    method addUse: use
        use is self
            ifFalse: { uses add: use }!


    method removeDef: def
        defs remove: def.
        (defs isEmpty and: uses isEmpty not)
            ifTrue: { Error raise: "{self} lost definition {def printName} while still being used by: {self uses collect: #printName}"}!


    method replaceUses: expr1 with: expr2
        Error raise: "Variable#replaceUses:with: is invalid"!


    method type: new
        (type is new)
            ifTrue: { return False }.
        (type is False)
            ifFalse: { Error raise: "Variable already has a type: {self}. Old={type}, New={new}" }.
        type = new!


    method type
        (ClassDefinition includes: type)
            ifTrue: { type }
            ifFalse: { (type is False) assert: "sanity check, type = {type} :: {type className}".
                       False }!


    method printName
        type is False
            ifTrue: { "{name}:{id}" }
            ifFalse: { "{name}::{type name}:{id}" }!


    method visitBy: visitor
        visitor visitVariable: self!

    method visitBy: visitor with: arg
        visitor visitVariable: self with: arg!

    method flush
        self isUnused assert: "Variable must be unused to flush"!
end


interface OperationKind
    direct method isFoldable
        True!


    direct method returnType: _
        False!


    direct method type: _
        False!


    direct method simplify: op in: graph with: worklist
        -- General-purpose constant-folding for ops. Must opt-out via
        -- #isFoldable.
        (op args allSatisfy: #isConstant)
            ifTrue: { let argVals = op args collect: #value.
                      let value = op kind apply: argVals.
                      let constant = graph ensureConstant: value.
                      op replaceUsesWith: constant in: worklist }!
end


class ADDI {}
    is OperationKind


    direct method name
        "addi"!


    direct method type: _
        IntegerClassDefinition!


    direct method visit: operation by: visitor
        visitor visitAddi: operation!


    direct method apply: args
        Datum value: (args first hostValue :: Integer +
                      args second hostValue :: Integer)!
end


extend Object
    method className
        self classOf name!
end


class CLASS_OF {}
    is OperationKind

    direct method name
        "classOf"!


    direct method apply: args
        args first type :: ClassDefinition!


    direct method simplify: operation in: graph with: worklist
        -- This is slightly more powerful than the general-purpose
        -- constant folding.
        let recv = operation args first.
        let type = recv type.
        -- Log println: "\nXXX: CLASS_OF {recv toString} => {type}".
        (ClassDefinition includes: type)
            => { let const = graph ensureConstant: type.
                 operation replaceUsesWith: const in: worklist }!


    direct method visit: operation by: visitor
        visitor visitClassOf: operation!
end


class DATUM_OF {}
    is OperationKind

    direct method name
        "datumOf"!

    direct method apply: args
        Datum value: args first hostValue!
end


class FIND_METHOD {}
    is OperationKind

    direct method name
        "findMethod"!


    direct method apply: args
        args first findMethod: args second!


    direct method visit: operation by: visitor
        visitor visitFindMethod: operation!


    direct method visit: operation by: visitor with: arg
        visitor visitFindMethod: operation with: arg!
end


class INVALID {}
    is OperationKind

    direct method name
        "invalid"!
end


class MAKE_INSTANCE {}
    is OperationKind

    direct method name
        "makeInstance"!


    direct method type: operation
        let classDef = operation args first.
        classDef isConstant
            ifTrue: { classDef value }!


    direct method apply: args
        Instance class: args first
                 datum: args second hostValue!


    direct method visit: operation by: visitor
        visitor visitMakeInstance: operation!
end


class Operation { id::Integer
                  kind
                  args::Array
                  uses::Set }
    is Expression

    direct method id: id kind: kind args: args
        let new = self id: id
                       kind: kind
                       args: args
                       uses: Set new.
        args do: { |each| each addUse: new }.
        new!


    method type
        kind type: self!


    method returnType
        kind returnType: self!


    method isOperation
        True!


    method isFoldable
        kind isFoldable!


    method simplifyIn: graph with: worklist
        kind simplify: self in: graph with: worklist!


    method doChildren: block
        args do: block!


    method verify: what
        (args allSatisfy: { |each| each uses includes: self })
            assert: "{self printName} should use its args: {args collect: #printName}"!


    method printName
        StringOutput
            with: { |out|
                    out
                        ; print: kind name
                        ; print: ":"
                        ; print: id
                        ; print: "(".
                    args
                        do: { |each| out print: each printName }
                        interleaving: { out print: ", " }.
                    out print: ")" }!


    method flush
        self isUnused assert: "Operation must be unused to flush".
        args do: { |each| each removeUse: self }.
        args = [].
        kind = INVALID!


    method replaceUses: expr1 with: expr2
        expr2 addUse: self.
        args = args replace: expr1 with: expr2.
        expr1 removeUse: self.
        self debugVerify: "Operation#replaceUses:"!


    method visitBy: visitor
        visitor visitOperation: self!


    method visitBy: visitor with: arg
        visitor visitOperation: self with: arg!
end


class Continuation { id::Integer
                     name
                     params::Array
                     target
                     args::Array
                     uses::Set }
    is Expression
    is AtomicContinuationTarget

    direct method id: id name: name params: params target: target args: args
        let new = self id: id
                       name: name
                       params: params
                       target: target
                       args: args asArray
                       uses: Set new.
        params do: { |each| each addDef: new }.
        target is False
            ifFalse: {target addUse: new }.
        args do: { |each| each addUse: new }.
        new!


    method verify: what
        (target is INVALID_TARGET)
            ifFalse: { (target uses includes: self)
                           ifFalse: { Error raise: "{self} does not use its target: {target} ({what})" } }.
        let badParams = params reject: { |each| each defs includes: self }.
        badParams isEmpty assert: "Continuation should define its params".
        let badArgs = args reject: { |each| each uses includes: self }.
        badArgs isEmpty assert: "Continuation should use its args".
        self!


    method renameIfSingleUse: new
        uses size <= 1
            => { name = new }.
        self!


    method name: new
        name = new!


    method type
        FunctionClassDefinition!


    method doSuccessors: block
        (AtomicContinuationTarget includes: target)
            ifTrue: { block value: target }
            ifFalse: { target doSuccessors: block }!


    method doValues: block
        (AtomicContinuationTarget includes: target)
            ifFalse: { target doValues: block }.
        args do: block!


    method propagateTypes: types
        params with: types
               do: { |param type| param type: type }!


    method propagateTargetType
        (Constant includes: target)
            => { let value = target value .
                 (MethodDefinition includes: value)
                     => { args last propagateTypes: [value returnType] } }!


    method simplifyIn: _ with: worklist
        { self hasUniqueTarget }
            whileTrue: { self inlineUniqueTargetWith: worklist }.
        -- The above zips up chains of local continuations
        -- nicely, which in turn leaves us with a Select
        -- or Application here, with a good chance of constant
        -- arguments thanks to the inlinining.
        ---
        (Continuation includes: target)
            ifFalse: { target simplifyIn: graph }.
        (args select: #isOperation)
            do: { |each| each simplifyIn: graph }.
        ---
        self!


    method hasUniqueTarget
        (Continuation includes: target)
            ifTrue: { target uses isOnly: self }!


    method inlineUniqueTargetWith: worklist
        self args
            with: target params
            do: { |arg param|
                  param replaceUsesWith: arg in: worklist }.
        self replaceArgsFrom: target.
        target unlinkWith: worklist.
        self debugVerify: "Continuation#inlineUniqueTarget"!


    method replaceUses: expr1 with: expr2
        expr2 addUse: self.
        target is expr1
            ifTrue: { target = expr2 }.
        args replace: expr1 with: expr2.
        expr1 removeUse: self.
        self debugVerify: "Continuation#replaceUses:with:"!



    method replaceArgsFrom: other::Continuation
        -- This is more convenient than #args:, since
        -- we usually want to copy the array!
        args do: { |each| each removeUse: self }.
        args = other args copy.
        args do: { |each| each addUse: self }.
        self debugVerify: "Continuation#replaceArgsFrom:"!


    method removeParams
        params do: { |each| each removeDef: self }.
        params = [].
        self debugVerify: "Continuation#removeParams"!


    method removeArgs
        args do: { |each| each removeUse: self }.
        args = [].
        self debugVerify: "Continuation#removeArgs"!


    method addParams: new
        new do: { |each| each addDef: self }.
        params = params append: new.
        self debugVerify: "Continuation#addParams:"!


    method addArgs: new
        new do: { |each| each addUse: self }.
        args = args append: new.
        self debugVerify: "Continuation#addArgs:"!


    method prependArgs: new
        new do: { |each| each addUse: self }.
        args = new append: args.
        self debugVerify: "Continuation#prependArgs:"!


    method target: new
        -- No copy needed here
        let old = target.
        target removeUse: self.
        target = new.
        target addUse: self.
        old isUnused
            ifTrue: { old flush }.
        self debugVerify: "Continuation#target:"!


    method unlinkWith: worklist
        self removeArgs.
        self replaceUsesWith: target in: worklist.
        self target: INVALID_TARGET.
        -- args and target may use params, so need to remove last!
        self removeParams.
        self debugVerify: "Continuation#unlinkWith:"!


    method flush
        self isUnused assert: "Continuation must be unused to flush".
        self removeArgs.
        self target: INVALID_TARGET.
        -- args and target may use params, so need to remove last!
        self removeParams!


    method printName
        name is False
            ifTrue: { "$cont:{id}" }
            ifFalse: { "{name}:{id}" }!


    method toString
        "#<Continuation {self printName} -> {target printName}>"!


    method visitBy: visitor
        visitor visitContinuation: self!

    method visitBy: visitor with: arg
        visitor visitContinuation: self with: arg!
end


class Application { id::Integer
                    target::AtomicContinuationTarget
                    function
                    uses::Set }
    is Object
    is ContinuationTarget
    is UseTracking

    direct method id: id target: target function: function
        let new = self id: id
                       target: target
                       function: function
                       uses: Set new.
        target addUse: new.
        function
            => { function addUse: new }.
        new!


    method flush
        self isUnused assert: "Application must be unused to flush".
        target removeUse: self.
        target = INVALID_TARGET.
        function removeUse: self.
        function = False!


    method target: new
        target removeUse: self.
        target = new.
        target addUse: self!


    method function: new
        function
            => { function removeUse: self }.
        function = new.
        function addUse: self!


    method doDeps: block
        block value: target.
        block value: function!


    method doValues: block
        block value: function!


    method replaceUses: node1 with: node2
        node1 removeUse: self.
        target is node1
            => { target = node2 }.
        function is node1
            => { function = node2 }.
        node2 addUse: self!


    method printName
        "apply:{id}({target printName}, {function printName})"!


    method simplifyIn: graph with: worklist
        function simplifyIn: graph with: worklist!


    method toString
        self printName!


    method visitBy: visitor
        visitor visitApplication: self!

    method visitBy: visitor with: arg
        visitor visitApplication: self with: arg!

    method doSuccessors: block
        block value: target!
end


class Select { id::Integer
               cond::Variable
               then::AtomicContinuationTarget
               else::AtomicContinuationTarget
               uses::Set }
    is Object
    is ContinuationTarget
    is UseTracking

    direct method id: id cond: cond then: then else: else
        let new = self id: id
                       cond: cond
                       then: then
                       else: else
                       uses: Set new.
        cond addUse: new.
        then addUse: new.
        else addUse: new.
        new!


    method printName
        "select:{id}({cond printName}, {then printName}, {else printName})"!


    method replaceUses: node1 with: node2
        node1 removeUse: self.
        cond is node1
            => { cond = node2 }.
        then is node1
            => { then = node2 }.
        else is node1
            => { else = node2 }.
        node2 addUse: self!


    method simplifyIn: graph with: worklist
        uses singular
            => { |use|
                 ((self hasUniqueTarget: then) and: (self hasUniqueTarget: else))
                     ifTrue: { -- Log println: "SIMPLIFY SELECT".
                               -- Log println: (CpsPrinter printToString: graph).
                               self propagateArgsFrom: use to: then in: worklist.
                               self propagateArgsFrom: use to: else in: worklist.
                               use removeArgs
                               -- Log println: "===>".
                               -- Log println: (CpsPrinter printToString: graph)
                               }} !


    method hasUniqueTarget: node
        (Continuation includes: node)
            ifTrue: { node uses isOnly: self }!


    method propagateArgsFrom: cont1 to: cont2 in: worklist
        cont1 args
            with: cont2 params
            do: { |arg param|
                  param replaceUsesWith: arg in: worklist }.
        cont2 removeParams!


    method visitBy: visitor
        visitor visitSelect: self!


    method doSuccessors: block
        block value: then.
        block value: else!


    method doValues: block
        block value: cond!
end


class PreOrder { seen block }
    direct method for: entry do: block
        (self seen: Set new block: block)
            traverse: entry!

    method traverse: cont
        (Continuation includes: cont)
            ifFalse: { return False }.
        (seen includes: cont)
            ifTrue: { return False }.
        seen add: cont.
        block value: cont.
        cont doSuccessors: { |each| self traverse: each }!
end


class PostOrder { seen block }
    direct method for: entry do: block
        (self seen: Set new
              block: block)
            traverse: entry!

    method traverse: cont
        (Continuation includes: cont)
            ifFalse: { return False }.
        (seen includes: cont)
            ifTrue: { return False }.
        seen add: cont.
        cont doSuccessors: { |each| self traverse: each }.
        block value: cont!
end


class ReversePostOrder { seen stack }
    direct method for: entry do: block
        let stack = List new.
        (self seen: Set new stack: stack)
            traverse: entry.
        stack reverse do: block!

    method traverse: cont
        (Continuation includes: cont)
            ifFalse: { return False }.
        (seen includes: cont)
            ifTrue: { return False }.
        seen add: cont.
        cont doSuccessors: { |each| self traverse: each }.
        stack push: cont!
end


class CpsGraph { entry::Continuation
                 exit::Variable
                 receiver -- False or Variable, identifies methods
                 lastId::Integer
                 operations::OpMap
                 constants::Dictionary
                 globals::Dictionary
                 continuations::List }
    is Expression

    direct method newExpr
        -- ID 1 is reserved for graph.
        --
        -- Entry node just binds the exit continuation,
        -- target patched in later.
        let exit = Variable id: 3
                            name: "$return".
        let entry = Continuation id: 2
                                 name: "$entry"
                                 params: [exit]
                                 target: INVALID_TARGET
                                 args: [].
        let graph = self
                        entry: entry
                        exit: exit
                        receiver: False
                        lastId: 3
                        operations: OpMap new
                        constants: Dictionary new
                        globals: Dictionary new
                        continuations: (List with: entry).
        exit addUse: exit.
        entry addUse: graph.
        graph!


    direct method methodFor: aClass
        -- ID 1 is reserved for graph.
        --
        -- Entry node just binds the exit continuation and
        -- receiver, target patched in later.
        let receiver = Variable id: 4
                                name: "$receiver"
                                type: aClass.
        let exit = Variable id: 3
                            name: "$return".
        let entry = Continuation id: 2
                                 name: "$entry"
                                 params: [exit, receiver]
                                 target: INVALID_TARGET
                                 args: [].
        let selectors = Dictionary new.
        let graph = self
                        entry: entry
                        exit: exit
                        receiver: receiver
                        lastId: 4
                        operations: OpMap new
                        constants: Dictionary new
                        globals: Dictionary new
                        continuations: (List with: entry).
        exit addUse: exit.
        entry addUse: graph.
        graph!


    method id
        1!


    method uses
        Set new!


    method printName
        "graph:1"!


    method replaceUses: expr1 with: expr2
        expr1 removeUse: self.
        exit is expr1
            ifTrue: { exit = expr2 }.
        entry is expr1
            ifTrue: { entry = expr2 }.
        expr2 addUse: self!


    method cleanup
        operations mergeDuplicates.
        continuations do: { |each| each verify: "CpsGrapg#cleanup" }.
        let worklist = Worklist new.
        worklist pushAll: (continuations select: #isUnused).
        worklist pushAll: (operations select: #isUnused).
        { worklist isEmpty }
            whileFalse: { let expr = worklist pop.
                          -- Output debug println: "flushing: {expr printName}".
                          expr doChildren: { |each|
                                                   each removeUse: expr.
                                                   each isUnused
                                                       ifTrue: { worklist push: each }} }.
        continuations = continuations reject: #isUnused.
        operations = operations reject: #isUnused!


    method doNodes: block
        continuations do: block.
        operations do: block!


    method entry: target
        entry target: target.
        self cleanup.
        -- Log println: "\nGRAPH:\n{CpsPrinter printToString: self}".
        self!


    method optimize
        CpsOptimizer optimize: self with: LocalOptimizationPolicy.
        self cleanup.
        self!


    method continuation: name params: params target: target args: args
        let cont = Continuation id: self nextId
                                name: name
                                params: params
                                target: target
                                args: args.
        continuations push: cont.
        cont!


    method makeVariable: name
        Variable
            id: self nextId
            name: name!


    method makeVariable: name type: type
        Variable
            id: self nextId
            name: name
            type: type!


    method ensureConstant: value
        constants
            at: value
            ifNonePut: { Constant
                             id: self nextId
                             value: value }!


    method ensureGlobal: name
        globals
            at: name
            ifNonePut: { Global
                             id: self nextId
                             name: name }!


    method addDefinition: definition
        let global = self ensureGlobal: definition name.
        global definition: definition!


    method ensureOperation: kind args: args
        operations
            kind: kind
            withArguments: args
            ifNonePut: { Operation
                             id: self nextId
                             kind: kind
                             args: args }!

    method application: function target: continuation
        -- FIXME: hashcons
        Application
            id: self nextId
            target: continuation
            function: function!


    method select: cond then: then else: else
        -- FIXME: hashcons
        Select
            id: self nextId
            cond: cond
            then: then
            else: else!


    method classOf: recv
        self ensureOperation: CLASS_OF
             args: [recv]!


    method ensureFindMethod: selector for: recv
        let selector = self ensureConstant: selector::CpsSelector.
        let classOf = self classOf: recv.
        self ensureOperation: FIND_METHOD
             args: [classOf, selector]!


    method nextId
        lastId = lastId + 1!


    method apply: args
        CpsEvaluator eval: self with: args!
end


class CpsConverter { graph var next classMap namespace }

    direct method makeConverter: graph classDefinitions: defs in: namespace
        -- Add definitions to the graph.
        defs do: { |each| graph addDefinition: each }.
        -- Create a map from host classes to definitions,
        -- used for conversion of literals.
        let classMap = Dictionary new.
        defs
            do: { |each|
                  let hostClass = each hostClass.
                  hostClass is False
                      ifFalse: { classMap put: each at: hostClass } }.
        self graph: graph
             var: False
             next: False
             classMap: classMap
             namespace: namespace!


    direct method convertExpr: syntax with: defs in: namespace
        let graph = CpsGraph newExpr.
        let converter = self makeConverter: graph
                             classDefinitions: defs
                             in: namespace.
        graph entry: (syntax visitBy: converter
                             with: graph exit).
        graph optimize!


    direct method convertMethod: syntax as: aMethod for: aClass with: defs in: namespace
        let graph = CpsGraph methodFor: aClass.
        let converter = self makeConverter: graph
                             classDefinitions: defs
                             in: namespace.
        graph entry: (syntax body visitBy: converter
                                  with: graph exit).
        aMethod cps: graph optimize!


    direct method userMethodFor: syntax in: namespace
        UserMethod
            selector: (namespace intern: syntax selector name)!


    direct method convertClass: aClass with: defs in: namespace
        let newClass = ClassDefinition name: aClass name.
        -- First we add placeholder methods, so that all methods
        -- can be immediately resolved to each other.
        let userMethods =  aClass instanceMethods
                              collect: { |each|
                                         let m = self userMethodFor: each in: namespace.
                                         newClass addMethod: m.
                                         m }.
        let ownClass = newClass ownClassDefinition.
        let directMethods = aClass directMethods
                                collect: { |each|
                                           let m = self userMethodFor: each in: namespace.
                                           ownClass addMethod: m.
                                           m }.
        -- Then as actually convert all methods.
        aClass instanceMethods
            with: userMethods
            do: { |syntax userMethod|
                  self convertMethod: syntax
                       as: userMethod
                       for: newClass
                       with: defs
                       in: namespace }.
        aClass directMethods
            with: directMethods
            do: { |syntax userMethod|
                  self convertMethod: syntax
                       as: userMethod
                       for: ownClass
                       with: defs
                       in: namespace }.
        (newClass methodDictionary reject: #isStandard)
            do: { |each|
                  CpsOptimizer optimize: each cps
                               with: GlobalOptimizationPolicy }.
        (ownClass methodDictionary reject: #isStandard)
            do: { |each|
                  CpsOptimizer optimize: each cps
                               with: GlobalOptimizationPolicy }.
        newClass!


    method bindVariable: var
        CpsConverter
            graph: graph
            var: var
            next: self
            classMap: classMap
            namespace: namespace!


    method bindVariables: vars
        let converter = self.
        vars do: { |each|
                   converter = converter bindVariable: each }.
        converter!


    method findBinding: name
        var is False
            ifTrue: { return graph ensureGlobal: name }.
        var name == name
            ifTrue: { var }
            ifFalse: { self next findBinding: name }!


    method visitBlock: syntax with: cc
        let blockReturn = graph makeVariable: "$ret".
        let blockVars = syntax parameters
                            collect: { |each| graph makeVariable: each name }.
        let block = syntax body
                        visitBy: (self bindVariables: blockVars)
                        with: blockReturn.
        block name: "$block".
        block addParams: (blockVars append: [blockReturn]).
        graph continuation: "$makeClosure"
              params: []
              target: cc
              args: [block]!


    method visitLet: syntax with: cc
        let var = graph makeVariable: syntax variable name.
        let body = syntax body
                       visitBy: (self bindVariable: var)
                       with: cc.
        let bind = graph continuation: "$let"
                         params: [var]
                         target: body
                         args: [].
        syntax value visitBy: self
                     with: bind!


    method visitLiteral: syntax with: cc
        let value = syntax value.
        let classDef = classMap
                           at: value classOf
                           ifNone: { Error raise: "No target class for {value} in: {classMap}" }.
        let instance =  Instance
                           class: classDef
                           datum: value.
        let const = graph ensureConstant: instance.
        graph continuation: "$const_ref"
              params: []
              target: cc
              args: [const]!


    method visitParens: syntax with: cc
        syntax body visitBy: self with: cc!


    method visitReturn: syntax with: _
        syntax value visitBy: self with: graph exit!


    method visitSelfInstance: _ with: cc
        graph continuation: "$self"
              params: []
              target: cc
              args: [graph receiver]!


    method visitSend: syntax with: cc
        let recv = graph makeVariable: "$recv".
        let args = syntax arguments
                       collect: { |a| graph makeVariable: "$arg" }
                       as: Array.
        let selector = namespace intern: syntax selector name.
        let methodFunction = graph ensureFindMethod: selector
                                   for: recv.
        let next = graph continuation: "$send"
                         params: []
                         target: (graph application: methodFunction
                                        target: cc)
                         args: ([recv] append: args).
        syntax arguments reverse
            with: args reverse
            do: { |syntaxArg var|
                  let bind = graph continuation: "$bind_arg"
                                   params: [var]
                                   target: next
                                   args: [].
                  next = syntaxArg visitBy: self with: bind }.
        let recvBind = graph continuation: "$bind_recv"
                             params: [recv]
                             target: next
                             args: [].
        syntax receiver visitBy: self
                        with: recvBind!


    method visitSeq: syntax with: cc
        let then = syntax then visitBy: self with: cc.
        let discard = graph continuation: "$seq"
                            params: [graph makeVariable: "$ignore"]
                            target: then
                            args: [].
        syntax first visitBy: self
                     with: discard!


    method visitValueTypeDeclaration: syntax with: cc
        let value = graph makeVariable: "$value".
        let type = graph makeVariable: "$type".
        let typecheck = graph ensureFindMethod: "typecheck:" intern for: type.
        let checkCont = graph continuation: "$typecheck"
                              params: [type]
                              target: (graph application: typecheck
                                             target: cc)
                              args: [type, value].
        let typeCont = syntax type visitBy: self with: checkCont.
        let bindValue = graph continuation: "$bind"
                              params: [value]
                              target: typeCont
                              args: [].
        syntax value visitBy: self with: bindValue!


    method visitVariable: syntax with: cc
        let var = self findBinding: syntax name.
        (Continuation includes: cc)
            => { cc isUnused
                     => { cc params first replaceUsesWith: var.
                          cc removeParams.
                          return cc } }.
        graph continuation: "$var_ref"
              params: []
              target: cc
              args: [var]!
end



class OptimizationPolicy { inlineUserMethods }
    method shouldInline: aMethod
        (BuiltinMethod includes: aMethod)
            ifTrue: { return True }.
        inlineUserMethods!
end


define LocalOptimizationPolicy
    (OptimizationPolicy
         inlineUserMethods: False)!


define GlobalOptimizationPolicy
    (OptimizationPolicy
         inlineUserMethods: True)!


class CpsOptimizer { worklist graph policy }

    direct method optimize: graph with: policy
        let worklist = Worklist new.
        graph doNodes: { |each| worklist push: each }.
        (self worklist: worklist graph: graph policy: policy)
            optimize!


    method optimize
        { worklist isEmpty }
            whileFalse: { let node = worklist pop.
                          -- Was node eliminated while it was on the worklist?
                          node isUnused
                              -- ifTrue: { Log println: "DEAD: {node}" }
                              ifFalse: { node visitBy: self } }!


    method visitContinuation: aCont
        -- Do strictly local simplifications: zipping up chains of
        -- of known continuations into a single one, etc.
        aCont simplifyIn: graph with: worklist.
        -- If target is an operation, let its optimizers kick in. In case
        -- of APPLY the continuation is the user of the arguments, but the
        -- apply is
        let target = aCont target.
        (Application includes: target)
            => { worklist push: target }!


    method visitOperation: anOperation
        anOperation kind simplify: anOperation in: graph with: worklist!


    method visitApplication: anApply
        let func = anApply function.
        let target = anApply target.
        -- Propagate return type for unique uses
        (target uses isOnly: anApply)
            ifTrue: { func returnType
                          => { |returnType|
                               target propagateTypes: [returnType].
                               worklist push: target } }.
        -- Lower constant method functions when possible.
        (Constant includes: func)
            ifTrue: { let value = func value.
                      (policy shouldInline: value)
                          => { anApply uses
                                   do: { |each::Continuation|
                                         value inlineIn: each in: graph with: worklist } } }!


    method visitSelect: aSelect
        aSelect simplifyIn: graph with: worklist!


    method visitTypeInfo: _
        False!


    method visitGlobal: _
        False!


    method visitVariable: _
        False!


    method visitConstant: _
        False!
end


class CpsCopier { graph copied }

    direct method copy: cps to: graph
        cps visitBy: (self graph: graph
                           copied: Dictionary new)!


    method visitAll: seq
        seq collect: { |each| each visitBy: self } as: Array!


    method visitContinuation: aCont
        -- Continuations can be in cycles, so we need to be
        -- careful and put in the copy of the continuation
        -- before copying its children.
        copied
            at: aCont
            ifNone: { let new = graph continuation: aCont name
                                      params: []
                                      target: INVALID_TARGET
                                      args: [].
                       copied put: new at: aCont.
                       new addParams: (self visitAll: aCont params).
                       new target: (aCont target visitBy: self).
                       new addArgs: (self visitAll: aCont args).
                       new }!


    method visitVariable: aVar
        copied
            at: aVar
            ifNonePut: { graph makeVariable: aVar name
                               type: aVar type }!


    method visitOperation: anOp
        copied
            at: anOp
            ifNonePut: { graph ensureOperation: anOp kind
                               args: (self visitAll: anOp args) }!


    method visitConstant: aConstant
        copied
            at: aConstant
            ifNonePut: { graph ensureConstant: aConstant value }!


    method visitApplication: anApp
        -- Same care as with continuation applies here!
        copied
            at: anApp
            ifNone: { let new = graph application: False
                                      target: INVALID_TARGET.
                       copied put: new at: anApp.
                       new target: (anApp target visitBy: self).
                       new function: (anApp function visitBy: self).
                       new }!

end


class CpsEvaluator { bound values parent }

    direct method new
        self bound: []
             values: []
             parent: False!


    direct method eval: cps
        -- Log println: (CpsPrinter printToString: cps).
        cps entry
            visitBy: (CpsEvaluator new)
            with: [{ |value| return value }]!


    direct method eval: cps with: args
        -- Log println: (CpsPrinter printToString: cps).
        cps entry
            visitBy: (CpsEvaluator new)
            with: ([{ |value| return value }] append: args)!


    method bind: params to: args
        CpsEvaluator
            bound: params
            values: args
            parent: self!


    method visitAll: seq
        seq collect: { |each| each visitBy: self }!


    method visitContinuation: aCont with: args
        let params = aCont params.
        params size is args size
            ifFalse: { Error raise: "Argument count mismatch, wanted: {aCont params collect: #printName}, got {args collect: #toString}" }.
        let eval = self bind: params
                        to: args.
        aCont target
            visitBy: eval
            with: (eval visitAll: aCont args)!


    method visitVariable: aVar with: args
        (self visitVariable: aVar)
            apply: args!


    method visitVariable: var
        let index = bound positionOf: var.
        index is False
            ifTrue: { parent is False
                          ifTrue: { Error raise: "Unbound variable: {var printName}" }.
                      parent visitVariable: var }
            ifFalse: { values at: index }!


    method visitApplication: app with: args
        app target
            visitBy: self
            with: [(app function visitBy: self with: args)]!


    method visitConstant: constant
        constant value :: CpsValue!


    method visitConstant: constant with: args
        constant value apply: args!


    method visitGlobal: aGlobal
        let def = aGlobal definition.
        def is False
            ifTrue: { Error raise: "Undefined global in CpsEvaluator: {aGlobal name}" }
            ifFalse: { def }!


    method visitOperation: anOp
        anOp kind apply: (self visitAll: anOp args)!


    method visitOperation: anOp with: args
        (anOp visitBy: self)
            apply: args!
end


class CpsPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output newline.
        visitor visit: graph entry!


    method visit: other
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitContinuation: aCont
        output
            ; print: aCont printName
            ; print: "(".
        aCont params
            do: { |each| output print: each printName }
            interleaving: { output print: ", " }.
        output println: "):".
        output
            ; print: "    "
            ; print: aCont target printName
            ; print: "(".
        aCont args
            do: { |arg| output print: arg printName }
            interleaving: { output print: ", " }.
        output println: ")".
        aCont args do: { |each| self visit: each }.
        self visit: aCont target!


    method visitConstant: _
        False!


    method visitVariable: _
        False!


    method visitGlobal: _
        False!


    method visitApplication: anApplication
        self visit: anApplication target!


    method visitSelect: aSelect
        self visit: aSelect cond.
        self visit: aSelect then.
        self visit: aSelect else!


    method visitOperation: anOp
        anOp args do: { |each| self visit: each }!
end

class CpsGraphwizOrderPrinter { output }
    direct method printToString: graph in: order
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph in: order to: output
        output writeString: "\nstrict digraph \{\n".
        output writeString: "    \"{graph entry printName}\" [color=red]\n".
        let prev = False.
        order for: graph entry
              do: { |cont|
                    output writeString: "   \"".
                    output writeString: cont printName.
                    output writeString: "\" [shape=box]\n".
                    prev => {
                        output writeString: "    \"".
                        output writeString: prev printName.
                        output writeString: "\" -> \"".
                        output writeString: cont printName.
                        output writeString: "\"\n" }.
                    prev = cont }.
        output writeString: "\}\n"!
end


class CpsGraphwizPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output writeString: "\nstrict digraph \{\n".
        output writeString: "    \"{graph entry printName}\" [color=red]\n".
        visitor visit: graph entry.
        output writeString: "\}\n"!


    method visit: other
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitAll: nodes
        nodes do: { |each| self visit: each }!


    method visitContinuation: aCont
        output writeString: "    \"{aCont printName}\" [shape=box]\n".
        aCont params
            do: { |each|
                  each uses isEmpty
                      ifFalse: { output writeString: "    \"".
                                 output writeString: aCont printName.
                                 output writeString: "\" -> \"".
                                 output writeString: each printName.
                                 output writeString: "\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]\n" } }.
        aCont doValues: { |each|
                          output writeString: "    \"".
                          output writeString: each printName.
                          output writeString: "\" -> \"".
                          output writeString: aCont printName.
                          output writeString: "\" [style=dotted]\n" }.
        aCont doSuccessors: { |each|
                              output writeString: "    \"".
                              output writeString: aCont printName.
                              output writeString: "\" -> \"".
                              output writeString: each printName.
                              output writeString: "\" [arrowhead=vee]\n" }.
        aCont doChildren: { |each|
                            self visit: each }.
        self visitAll: aCont args!


    method visitVariable: aVar
        False!


    method visitConstant: _
        False!


    method visitGlobal: _
        False!


    method visitApplication: _
        False!


    method visitOperation: anOperation
        anOperation uses
            doSorted: { |each| each visitBy: self }.
        anOperation args
            do: { |each|
                  output writeString: "    \"".
                  output writeString: each printName.
                  output writeString: "\" -> \"".
                  output writeString: anOperation printName.
                  output writeString: "\" [style=dotted]\n" }.
        self visitAll: anOperation args!
end


class TestCPS { assert system }
    is TestSuite

    direct method assert: assert
        self assert: assert system: False!

    method system: new
        system = new!

    method convertExpr: source
        self convertExpr: source
             with: []
             in: Namespace standard!


    method convertExpr: source with: defs
        self convertExpr: source
             with: defs
             in: Namespace standard!


    method convertExpr: source with: defs in: namespace
        let syntax = Parser parseExpression: source.
        CpsConverter convertExpr: syntax
                     with: defs
                     in: namespace!


    method convertClass: source with: defs in: namespace
        let syntax = Parser parseDefinition: source.
        CpsConverter convertClass: syntax
                     with: defs
                     in: namespace!


    method test_convert_addition_of_integers_optimizes_to_operation_addi
        let cps = self convertExpr: "let a = X a :: Integer. let b = X b :: Integer. a + b"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:45($bind:40, findMethod:44(classOf:27(X:Global), #a))(X:Global)
$bind:40($value:34):
    apply:38($let:33, Integer class#typecheck:)(Integer:Global, $value:34)
$let:33(a::Integer:5):
    apply:29($bind:24, findMethod:28(classOf:27(X:Global), #b))(X:Global)
$bind:24($value:17):
    apply:22($let:16, Integer class#typecheck:)(Integer:Global, $value:17)
$let:16(b::Integer:6):
    $return:3(makeInstance:60(Integer, addi:59(datumOf:57(b::Integer:6), datumOf:58(a::Integer:5))))
"!

    method test_convert_arity_0_block
        let cps = self convertExpr: "\{ 421 }"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3($block:7)
$block:7($ret:5):
    $ret:5(421)
"!


    method test_convert_arity_3_block
        let cps = self convertExpr: "\{ |a b c| a + b + c }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3($block:24)
$block:24(a:5, b:6, c:7, $ret:4):
    apply:21($bind_recv:16, findMethod:20(classOf:19(a:5), #+))(a:5, b:6)
$bind_recv:16($recv:8):
    apply:13($ret:4, findMethod:12(classOf:11($recv:8), #+))($recv:8, c:7)
"!


    method test_convert_boolean_ifFalse
        let cps = self convertExpr: "X :: Boolean ifFalse: \{ 1 }"
                       with: [BooleanClassDefinition,
                              IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:24($bind_recv:18, Boolean class#typecheck:)(Boolean:Global, X:Global)
$bind_recv:18($recv::Boolean:6):
    select:35($recv::Boolean:6, $ifTrue:34, $block:16)()
$ifTrue:34():
    $return:3(False)
$block:16():
    $return:3(1)
"!


    method test_convert_boolean_ifTrue
        let cps = self convertExpr: "X :: Boolean ifTrue: \{ 1 }"
                       with: [BooleanClassDefinition,
                              IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:24($bind_recv:18, Boolean class#typecheck:)(Boolean:Global, X:Global)
$bind_recv:18($recv::Boolean:6):
    select:35($recv::Boolean:6, $block:16, $ifFalse:34)()
$block:16():
    $return:3(1)
$ifFalse:34():
    $return:3(False)
"!


    method test_convert_boolean_ifTrueIfFalse
        let cps = self convertExpr: "X :: Boolean ifTrue: \{ 1 } ifFalse: \{ 2 }"
                       with: [BooleanClassDefinition,
                              IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:30($bind_recv:24, Boolean class#typecheck:)(Boolean:Global, X:Global)
$bind_recv:24($recv::Boolean:6):
    select:38($recv::Boolean:6, $block:22, $block:17)()
$block:22():
    $return:3(1)
$block:17():
    $return:3(2)
"!


    method test_convert_result_type_of_addi_known
        let cps = self convertExpr: "let x = X :: Integer. (x + x) :: Integer"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:28($let:23, Integer class#typecheck:)(Integer:Global, X:Global)
$let:23(x::Integer:5):
    $return:3(makeInstance:43(Integer, addi:42(datumOf:41(x::Integer:5), datumOf:41(x::Integer:5))))
"!


    method test_convert_closure_whileFalse
        let cps = self convertExpr: "\{ X maybe\} whileFalse: \{ Y something \}".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $loopTest:36(False)
$loopTest:36($ignore:35):
    apply:28($whileFalse:42, findMethod:27(classOf:26(X:Global), #maybe))(X:Global)
$whileFalse:42($cond:40):
    select:41($cond:40, $loopExit:39, $loopBody:37)()
$loopExit:39():
    $return:3(False)
$loopBody:37():
    apply:17($loopTest:36, findMethod:16(classOf:15(Y:Global), #something))(Y:Global)
"!


    method test_convert_closure_whileTrue
        let cps = self convertExpr: "\{ X maybe\} whileTrue: \{ X something \}".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $loopTest:35(False)
$loopTest:35($ignore:34):
    apply:28($whileTrue:41, findMethod:27(classOf:15(X:Global), #maybe))(X:Global)
$whileTrue:41($cond:39):
    select:40($cond:39, $loopBody:36, $loopExit:38)()
$loopBody:36():
    apply:17($loopTest:35, findMethod:16(classOf:15(X:Global), #something))(X:Global)
$loopExit:38():
    $return:3(False)
"!


    method test_convert_constant_add
        let cps = self convertExpr: "123 + X::Integer"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:18($bind_arg:12, Integer class#typecheck:)(Integer:Global, X:Global)
$bind_arg:12($arg::Integer:6):
    $return:3(makeInstance:37(Integer, addi:36(datumOf:34($arg::Integer:6), 123::Datum)))
"!


    method test_convert_constant_integer
        let cps = self convertExpr: "123"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(123)
"!


    method test_convert_constructor
        let namespace = Namespace standard.
        let def = self convertClass: "
class A \{}
    direct method test
        self new!
end"
                      with: [IntegerClassDefinition]
                      in: namespace.
        let cps = (def type findMethod: (namespace intern: "test")) cps.
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3, $receiver::A class:4):
    $return:3(#<Instance A>)
"!


    method test_convert_global
        let cps = self convertExpr: "X".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(X:Global)
"!


    method test_convert_sends_to_self_resolved
        let namespace = Namespace standard.
        let def = self convertClass: "
class A \{}
    method a
        self b + self c!
    method b
        174!
    method c
        214!
end"
                      with: [IntegerClassDefinition]
                      in: namespace.
        assert that: { CpsPrinter printToString: (def findMethod: (namespace intern: "a")) cps }
               equals: "
$entry:2($return:3, $receiver::A:4):
    $return:3(388)
"!


    method test_convert_inline_sends_to_self
        let namespace = Namespace standard.
        let def = self convertClass: "
class A \{}
    direct method test
        self new a!
    method a
        self b + self c!
    method b
        174!
    method c
        213!
end"
                      with: [IntegerClassDefinition]
                      in: namespace.
        let cps = (def type findMethod: (namespace intern: "test")) cps.
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3, $receiver::A class:4):
    $return:3(387)
"!


    method test_convert_let
        let cps = self convertExpr: "let x = 87. x"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(87)
"!


    method test_convert_return
        let cps = self convertExpr: "return 421. X boom"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(421)
"!


    method test_convert_seq
        let cps = self convertExpr: "X some: 12 message: 97. Y + Z"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:24($seq:17, findMethod:23(classOf:22(X:Global), #some:message:))(X:Global, 12, 97)
$seq:17($ignore:16):
    apply:10($return:3, findMethod:9(classOf:8(Y:Global), #+))(Y:Global, Z:Global)
"!


    method test_convert_typecheck
        let cps = self convertExpr: "X :: Integer".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:9($return:3, findMethod:8(classOf:7(Integer:Global), #typecheck:))(Integer:Global, X:Global)
"!


    method test_convert_typecheck_gives_type
        let cps = self convertExpr: "X::Integer + Y"
                       with: [(ClassDefinition
                                   name: "Integer"
                                   methods: [(UserMethod selector: "+" intern)])].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:20($bind_recv:14, Integer class#typecheck:)(Integer:Global, X:Global)
$bind_recv:14($recv::Integer:5):
    apply:10($return:3, Integer#+)($recv::Integer:5, Y:Global)
"!


    method test_convert_typecheck_redundancy
        let cps = self convertExpr: "X :: Integer :: Integer"
                       with: [(ClassDefinition name: "Integer")].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:17($bind:12, Integer class#typecheck:)(Integer:Global, X:Global)
$bind:12($value::Integer:5):
    $return:3($value::Integer:5)
"!


    method test_eval_send_message
        let cps = self convertExpr: "123 opaqueIdentity + 321"
                       with: [IntegerClassDefinition].
        assert that: { (CpsEvaluator eval: cps) hostValue }
               equals: 444!


    method test_graphwiz_closure_whileTrue
        let cps = self convertExpr: "\{ X maybe\} whileTrue: \{ X something \}".
        (system currentDirectory / "closure_whileTrue.dot")
            truncateExisting forWrite
                createOrOpen: { |dot|
                                CpsGraphwizPrinter
                                    print: cps
                                    to: dot }.
        assert that: { CpsGraphwizPrinter printToString: cps }
               equals: "
strict digraph \{
    \"$entry:2\" [color=red]
    \"$entry:2\" [shape=box]
    \"$entry:2\" -> \"$return:3\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]
    \"False\" -> \"$entry:2\" [style=dotted]
    \"$entry:2\" -> \"$loopTest:35\" [arrowhead=vee]
    \"$loopTest:35\" [shape=box]
    \"findMethod:27(classOf:15(X:Global), #maybe)\" -> \"$loopTest:35\" [style=dotted]
    \"X:Global\" -> \"$loopTest:35\" [style=dotted]
    \"$loopTest:35\" -> \"$whileTrue:41\" [arrowhead=vee]
    \"$whileTrue:41\" [shape=box]
    \"$whileTrue:41\" -> \"$cond:39\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]
    \"$cond:39\" -> \"$whileTrue:41\" [style=dotted]
    \"$whileTrue:41\" -> \"$loopBody:36\" [arrowhead=vee]
    \"$whileTrue:41\" -> \"$loopExit:38\" [arrowhead=vee]
    \"$loopBody:36\" [shape=box]
    \"findMethod:16(classOf:15(X:Global), #something)\" -> \"$loopBody:36\" [style=dotted]
    \"X:Global\" -> \"$loopBody:36\" [style=dotted]
    \"$loopBody:36\" -> \"$loopTest:35\" [arrowhead=vee]
    \"classOf:15(X:Global)\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"#something\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"classOf:15(X:Global)\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"#something\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"classOf:15(X:Global)\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
    \"#maybe\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
    \"X:Global\" -> \"classOf:15(X:Global)\" [style=dotted]
    \"$loopExit:38\" [shape=box]
    \"False\" -> \"$loopExit:38\" [style=dotted]
    \"$loopExit:38\" -> \"$return:3\" [arrowhead=vee]
    \"classOf:15(X:Global)\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
    \"#maybe\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
}
"!


    method test_eval_sends_to_self_in_direct_method
        let namespace = Namespace standard.
        let def = self convertClass: "
class A \{}
    direct method test
        self opaqueIdentity a + self opaqueIdentity b!
    direct method a
        90!
    direct method b
        88!
end"
                      with: [IntegerClassDefinition]
                      in: namespace.
        assert true: { ClassDefinition includes: def }.
        let cps = self convertExpr: "A test"
                       with: [def]
                       in: namespace.
        assert that: { (CpsEvaluator eval: cps) hostValue }
               equals: 178!


    method test_eval_sends_to_self_in_instance_method
        let namespace = Namespace standard.
        let def = self convertClass: "
class A \{}
    direct method test
        self new a!
    method a
        self opaqueIdentity b + self opaqueIdentity c!
    method b
        981!
    method c
        231!
end"
                      with: [IntegerClassDefinition]
                      in: namespace.
        assert true: { ClassDefinition includes: def }.
        let cps = self convertExpr: "A test"
                       with: [def]
                       in: namespace.
        assert that: { (CpsEvaluator eval: cps) hostValue }
               equals: 1212!


    method test_eval_typecheck_literal
        let cps = self convertExpr: "123 :: Integer"
                       with: [IntegerClassDefinition].
        assert that: { (CpsEvaluator eval: cps) hostValue }
               equals: 123!


    method test_postOrder_whileTrue
        let cps = self convertExpr: "\{ X maybe\} whileTrue: \{ X something \}".
        let order = List new.
        PostOrder for: cps entry
                  do: { |each| order push: each id }.
        assert that: { order asArray }
               equals: [36, 38, 41, 35, 2]!


    method test_preOrder_whileTrue
        let cps = self convertExpr: "\{ X maybe\} whileTrue: \{ X something \}".
        let order = List new.
        PreOrder for: cps entry
                 do: { |each| order push: each id }.
        assert that: { order asArray }
               equals: [2, 35, 41, 36, 38]!


    method test_reversePostOrder_whileTrue
        let cps = self convertExpr: "\{ X maybe\} whileTrue: \{ X something \}".
        let order = List new.
        ReversePostOrder for: cps entry
                         do: { |each| order push: each id }.
        assert that: { order asArray }
               equals: [2, 35, 41, 38, 36]!
end


class Main {}
    direct method run: command in: system
        TestCPS runTests: (Assert reportingTo: system output)
                in: system
                with: command!
end
