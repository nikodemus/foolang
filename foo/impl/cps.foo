-- For tests
import lib.assert.Assert
import impl.parser.Parser
import impl.syntax.SyntaxLiteral
import impl.syntax.SyntaxLet
import impl.syntax.SyntaxBinary
import impl.syntax.SyntaxVariable
import impl.syntax.SyntaxSelector
import impl.syntax.SyntaxSeq

class Set { dict }
    direct method new
        self dict: Dictionary new!
    method add: node
        dict put: node at: node!
    method remove: node
        dict remove: node!
    method size
        dict size!
    method isEmpty
        dict isEmpty!
    method isOnly: node
        dict size is 1
            ifTrue: { (dict values first) is node }
            ifFalse: { False }!
    method replace: node1 with: node2
        dict doKeys: { |each|
                       each replace: node1 with: node2 }!
end

class Counter { count }
    direct method new
        self count: 0!
    method next
        count = count + 1!
end

-- Continuations represent control flow and computations:
-- they can both receive and produce values.
interface CONT
    is Object

    method simplify
        self!

    method flush
        -- Things which use values need to implement this.
        False!

    method unlink
        self pred link: self cont.
        self pred: False.
        self cont: False.
        self flush!

    method link: next
        next pred: self.
        self cont: next!
end

-- Nullary continuations ignore any values they receive.
interface NULLARY
    is CONT
end

-- Nodes represent constants, bound names, and compiler generated
-- temporaries: values requring no computations. They are used
-- by continuations, either REF continuations fetching the value
-- of a node and passing it onwards, or SEND continuations directly
-- using a node.
interface NODE
    is Object
end

class TMP { id defs uses }
    is NODE
    direct method id: id
        self id: id
             defs: Set new
             uses: Set new!
    method printOn: output
        output print: "${id}"!
end

class VAR { id name defs uses }
    is NODE
    direct method id: id name: name
        self id: id
             name: name
             defs: Set new
             uses: Set new!
    method printOn: output
        output print: "{name}{id}"!
end

class CONST { value uses }
    is NODE
    direct method value: value
        self value: value
             uses: Set new!
    method printOn: output
        output writeString: value displayString!
end


class SEND { id pred cont selector recv args }
    is NULLARY
    direct method id: id cont: cont selector: selector recv: recv args: args
        let new = self id: id
                       pred: False
                       cont:cont
                       selector: selector
                       recv: recv
                       args: args.
        cont pred: new.
        recv uses add: new.
        args do: { |each| each uses add: new }.
        new!
    method name
        "send{id}"!
    method cont: new
        cont = new!
    method pred: new
        pred = new!
    method replace: node1 with: node2
        node1 uses remove: self.
        node2 uses add: self.
        recv is node1
            => { recv = node2 }.
        args doWithIndex: { |each index|
                            each is node1
                                => { args at: index put: node2 } }!
    method visitBy: visitor
        visitor visitSend: self!
end

class BIND { id pred cont var }
    is CONT
    direct method id: id cont: cont var: var
        let new = self id: id
                       pred: False
                       cont: cont
                       var: var.
        cont pred: new.
        var defs add: new.
        new!
    method name
        "bind{id}"!
    method pred: new
        pred = new!
    method cont: new
        cont = new!
    method simplify
        (REF includes: pred)
            => { CONST includes: pred target }
                => { var defs isOnly: self }
                    => { var uses replace: var with: pred target }.
        cont simplify.
        var uses isEmpty
            => { self unlink }!
    method flush
        var uses isEmpty assert: "Cannot flush a bind whose var has uses left".
        var defs remove: self!
    method visitBy: visitor
        visitor visitBind: self!
end

class REF { id pred cont target }
    is NULLARY
    direct method id: id cont: cont target: target
        -- If the REF would be dead, don't build it in the
        -- first place.
        (NULLARY includes: cont)
            => { return cont }.
        let new = self id: id
                       pred: False
                       cont: cont
                       target: target.
        cont pred: new.
        target uses add: new.
        new!
    method name
        "ref{id}"!
    method cont: new
        cont = new!
    method pred: new
        pred = new!
    method simplify
        cont simplify.
        (NULLARY includes: cont)
            ifTrue: { self unlink }!
    method replace: node1 with: node2
        node1 uses remove: self.
        node2 uses add: self.
        target = node2!
    method flush
        target uses remove: self!
    method visitBy: visitor
        visitor visitRef: self!
end

class START { _cont }
    is CONT
    direct method cont: cont
        let new = self _cont: cont.
        cont pred: new.
        new!
    method cont
        _cont!
    method cont: new
        _cont = new!
    method simplify
        _cont simplify.
        _cont is False
            ifTrue: { panic "Invalid simplifcation: START lost cont!" }!
    method visitBy: visitor
        visitor visitStart: self!
end

class HALT { pred }
    is CONT
    direct method new
        self pred: False!
    method name
        "halt"!
    method pred: new
        pred = new!
    method visitBy: visitor
        visitor visitHalt: visitor!
end

class CpsBuilder { var next counter constants }

    direct method convert: syntax
        START cont: (self new visit: syntax with: HALT new)!

    direct method new
        self var: False
             next: False
             counter: Counter new
             constants: Dictionary new!

    method bind: var
        CpsBuilder
            var: var
            next: self
            counter: counter
            constants: constants!

    method find: name
        var is False
            ifTrue: { Error raise: "Unbound variable in CPSBuilder: {name}" }.
        var name == name
            ifTrue: { var }
            ifFalse: { self next find: name }!

    method constant: value
        constants
            at: value
            ifNonePut: { CONST value: value }!

    method tmp
        TMP id: counter next!

    method var: name
        VAR id: counter next name: name!

    method visit: syntax with: cc
        syntax visitBy: self with: cc!

    method visitLiteral: aLiteral with: cc
        REF
            id: counter next
            cont: cc
            target: (self constant: aLiteral value)!

    method visitVariable: aVar with: cc
        REF
            id: counter next
            cont: cc
            target: (self find: aVar name)!

    method visitLet: aLet with: cc
        let var = self var: aLet variable name.
        let body = (self bind: var)
                       visit: aLet body
                       with: cc.
        let bind = BIND id: 1 cont: body var: var.
        self visit: aLet value with: bind!

    method visitSend: aSend with: cc
        -- We generate TMPs and BINDs for receiver and arguments,
        -- which would be very nice to avoid if they just end
        -- up being REFs, since then we could pick up the
        -- targets directly. Now that's left to simplification
        -- pass.
        let recvTmp = self tmp.
        let argTmps = aSend arguments collect: { |_each| self tmp }.
        let next = SEND
                       id: counter next
                       cont: cc
                       selector: aSend selector
                       recv: recvTmp
                       args: argTmps.
        let counter = Counter new.
        let argVals = aSend arguments reverse
                          with: argTmps reverse
                          collect: { |arg tmp|
                                     let bind = BIND id: counter next
                                                     cont: next
                                                     var: tmp.
                                     next = self visit: arg with: bind }.
        let recvBind = BIND id: counter next
                            cont: next
                            var: recvTmp.
        self visit: aSend receiver with: recvBind!

    method visitSeq: aSeq with: cc
        let then = self visit: aSeq then with: cc.
        self visit: aSeq first with: then!
end

interface CpsPrinter
    direct method print: cps to: output
        cps visitBy: (self output: output)!

    direct method println: cps to: output
        self print: cps to: output.
        output newline!

    direct method printToString: cps
        StringOutput with: { |out| self print: cps to: out }!

    method visitStart: aStart
        aStart cont visitBy: self!
end

class CpsLambdaPrinter { output }
    is CpsPrinter

    method visitRef: aRef
        aRef cont visitBy: self.
        output writeString: " {aRef target}"!

    method visitBind: aBind
        output writeString: "(\\{aBind var}.".
        aBind cont visitBy: self.
        output writeString: ")"!

    method visitSend: aSend
        aSend cont visitBy: self.
        output writeString: " {aSend recv}".
        (aSend selector name splitBy: ":" character)
            with: aSend args
            do: { |selectorPart arg|
                  output writeString: " {selectorPart} {arg}" }!

    method visitHalt: _aHalt
        output writeString: "\\_.halt"!
end

define NoValue ["NoValue"]!

class CpsSourcePrinter { output value }
    is CpsPrinter

    direct method output: output
        self output: output
             value: NoValue!

    method visitRef: aRef
        value = aRef target.
        aRef cont visitBy: self!

    method visitBind: aBind
        output print: "let {aBind var} = {value}. ".
        value = NoValue.
        aBind cont visitBy: self!

    method visitSend: aSend
        output writeString: "{aSend recv}".
        (aSend selector name splitBy: ":" character)
            with: aSend args
            do: { |selectorPart arg|
                  output writeString: " {selectorPart} {arg}" }!

    method visitHalt: _aHalt
        value is NoValue
            ifFalse: { output print: value }!
end

class CpsContPrinter { output }
    is CpsPrinter

    method visitStart: aStart
        output
            ; newline
            ; println: "start():"
            ; println: "    {aStart cont name}()".
        aStart cont visitBy: self!

    method visitRef: aRef
        output
            ; println: "ref{aRef id}():"
            ; println: "    {aRef cont name}({aRef target})".
        aRef cont visitBy: self!

    method visitBind: aBind
        output
            ; println: "bind{aBind id}({aBind var}):"
            ; println: "    {aBind cont name}()".
        aBind cont visitBy: self!

    method visitSend: aSend
        output
            ; println: "send{aSend id}():"
            ; print: "   {aSend cont name}("
            ; print: "{aSend recv}".
        (aSend selector name splitBy: ":" character)
            with: aSend args
            do: { |selectorPart arg|
                  output print: " {selectorPart} {arg}" }.
        output println: ")"!

    method visitHalt: _aHalt
        False!
end

class TestCPS { assert }
    is TestSuite

    method convert: syntax
        let cps = CpsBuilder convert: syntax.
        assert true: { START includes: cps }.
        assert true: { cps is cps cont pred }.
        cps!

    method assertRef: ref ofConst: value
        assert true: { REF includes: ref }
               testing: "REF to const expected".
        assert true: { CONST includes: ref target }
               testing: "REF target is CONST".
        assert true: { value == ref target value }
               testing: "REF target has right value: {value}, got: {ref target value}"!

    method assertRef: ref ofVar: var::VAR
        assert true: { let target = ref::REF target.
                       target::VAR is var }
               testing: "REF to {var} expected, got: {ref}"!

    method assertHalt: cps
        assert true: { HALT includes: cps }
               testing: "HALT where expected, got: {cps classOf name}"!

    method assertBind: bind ofVar: name
        assert true: { let var = bind::BIND var.
                       name == var::VAR name }
               testing: "BIND of VAR {name} expected, got: {bind}"!

    method assertBind: bind ofTmp: id
        assert true: { let var = bind::BIND var.
                       id is var::TMP id }
               testing: "BIND of TMP {id} expected, got: {bind}"!

    method make_const_ref
        self convert: (SyntaxLiteral value: 42)!

    method test_convert_const_ref
        let cps = self make_const_ref.
        self assertRef: cps cont ofConst: 42.
        self assertHalt: cps cont cont!

    method test_simplify_const_ref
        let cps = self make_const_ref.
        cps simplify.
        self assertRef: cps cont ofConst: 42.
        self assertHalt: cps cont cont!

    method make_let_x_and_ref
        let syntax = SyntaxLet
                         variable: (SyntaxVariable name: "x")
                         value: (SyntaxLiteral value: 1343)
                         body: (SyntaxVariable name: "x").
        self convert: syntax!

    method test_convert_let_x_and_ref
        let cps = self make_let_x_and_ref.
        self assertRef: cps cont ofConst: 1343.
        let bind = cps cont cont.
        self assertBind: bind ofVar: "x".
        self assertRef: bind cont ofVar: bind var.
        self assertHalt: bind cont cont!

    method test_simplify_let_x_and_ref
        let cps = self make_let_x_and_ref.
        cps simplify.
        self assertRef: cps cont ofConst: 1343.
        self assertHalt: cps cont cont!

    method make_let_xy_and_add
        let syntax = SyntaxLet
                         variable: (SyntaxVariable name: "x")
                         value: (SyntaxLiteral value: 322)
                         body: (SyntaxLet
                                    variable: (SyntaxVariable name: "y")
                                    value: (SyntaxVariable name: "x")
                                    body: (SyntaxBinary
                                               receiver: (SyntaxVariable name: "y")
                                               selector: (SyntaxSelector name: "+")
                                               argument: (SyntaxVariable name: "x"))).
        self convert: syntax!

    method test_convert_and_simplify_let_xy_and_add
        -- Both conversion and simplification in one test
        -- so that the simplification can refer to the send
        -- cont.
        let cps = self make_let_xy_and_add.
        self assertRef: cps cont ofConst: 322.
        let number= cps cont target.
        let bindX = cps cont cont.
        self assertBind: bindX ofVar: "x".
        self assertRef: bindX cont ofVar: bindX var.
        let bindY = bindX cont cont.
        self assertBind: bindY ofVar: "y".
        let refY = bindY cont.
        self assertRef: refY ofVar: bindY var.
        let bind1 = refY cont.
        -- ID 1-2 taken by x and y
        self assertBind: bind1 ofTmp: 3.
        self assertRef: bind1 cont ofVar: bindX var.
        let bind2 = bind1 cont cont.
        self assertBind: bind2 ofTmp: 4.
        let send = bind2 cont :: SEND.
        assert true: { send selector name == "+" }.
        assert true: { send recv is bind1 var }.
        assert true: { send args == [bind2 var] }.
        self assertHalt: send cont.

        cps simplify.

        assert true: { cps cont is send }.
        assert true: { send recv is number }.
        assert true: { send args == [number] }.
        self assertHalt: send cont!

    method test_convert_and_simplify_seq_with_dead_ref
        -- Unused referenced are dropped early.
        let syntax = SyntaxSeq
                         first: (SyntaxLiteral value: 983)
                         then: (SyntaxLiteral value: 651).
        let cps = self convert: syntax.
        self assertRef: cps cont ofConst: 651.
        self assertHalt: cps cont cont.

        cps simplify.

        self assertRef: cps cont ofConst: 651.
        self assertHalt: cps cont cont!

    method test_print_lambda_const_ref
        let cps = self make_const_ref.
        assert that: { CpsLambdaPrinter printToString: cps }
               equals: "\\_.halt 42"!

    method test_print_lambda_let_x_and_ref
        let cps = self make_let_x_and_ref.
        assert that: { CpsLambdaPrinter printToString: cps }
               equals: "(\\x1.\\_.halt x1) 1343"!

    method test_print_lambda_let_xy_and_add
        let cps = self make_let_xy_and_add.
        assert that: { CpsLambdaPrinter printToString: cps }
               equals: "(\\x1.(\\y2.(\\$3.(\\$4.\\_.halt $3 + $4) x1) y2) x1) 322"!

    method test_print_source_const_ref
        let cps = self make_const_ref.
        assert that: { CpsSourcePrinter printToString: cps }
               equals: "42"!

    method test_print_lambda_let_x_and_ref
        let cps = self make_let_x_and_ref.
        assert that: { CpsSourcePrinter printToString: cps }
               equals: "let x1 = 1343. x1"!

    method test_print_lambda_let_xy_and_add
        let cps = self make_let_xy_and_add.
        assert that: { CpsSourcePrinter printToString: cps }
               equals: "let x1 = 322. let y2 = x1. let $3 = y2. let $4 = x1. $3 + $4"!

    method test_print_cont_const_ref
        let cps = self make_const_ref.
        assert that: { CpsContPrinter printToString: cps }
               equals: "
start():
    ref1()
ref1():
    halt(42)
"!

    method test_print_cont_let_x_and_ref
        let cps = self make_let_x_and_ref.
        assert that: { CpsContPrinter printToString: cps }
               equals: "
start():
    ref3()
ref3():
    bind1(1343)
bind1(x1):
    ref2()
ref2():
    halt(x1)
"!

    method test_print_cont_let_xy_and_add
        let cps = self make_let_xy_and_add.
        assert that: { CpsContPrinter printToString: cps }
               equals: "
start():
    ref9()
ref9():
    bind1(322)
bind1(x1):
    ref8()
ref8():
    bind1(x1)
bind1(y2):
    ref7()
ref7():
    bind2(y2)
bind2($3):
    ref6()
ref6():
    bind1(x1)
bind1($4):
    send5()
send5():
   halt($3 + $4)
"!

end

class DemoCPS { output }
    method run
        self
            ; demo: "let x = 42. let y = 666. x. y. 999. x + x"!
    method demo: code
        let syntax = Parser parseExpressions: code.
        output println: "--".
        output print: "Source: ".
        output println: code.
        syntax do: { |each|
                     let cps = CpsBuilder convert: each.
                     output print: "CPS: ".
                     CpsLambdaPrinter println: cps to: output.
                     cps simplify.
                     output print: "Simplified: ".
                     CpsLambdaPrinter println: cps to: output }!
end

class Main {}
    direct method run: command in: system
        TestCPS runTests: (Assert reportingTo: system output)
                in: system!
        -- (DemoCPS output: system output) run!
end
