import lib.assert.Assert
import impl.parser.Parser


interface MethodDefinition
    is Object

    method displayString
        "methodFunction({self home name}#{self name})"!


    method returnType
        False!


    method lowerToCps: _ in: _ with: _
        False!


    method toString
        "#<{self classOf name} {self displayString}>"!
end


class UserMethod { name home }
    is MethodDefinition

    direct method name: name
        self name: name
             home: False!


    method home: new
        (home is False)
            ifFalse: { Error raise: "{self} already has a home: {self}" }.
        home= new!
end


class BuiltinMethod { home impl }
    is MethodDefinition

    direct method new: impl
        self home: False
             impl: impl!


    method name
        impl name!


    method returnType
        impl returnType!


    method lowerToCps: aCont in: graph with: worklist
        impl lowerToCps: aCont in: graph with: worklist!


    method home: new
        (home is False)
            ifFalse: { Error raise: "BuiltinMethod {name} already has a home: {home}" }.
        home = new!


end


interface BuiltinMethodImpl
    method returnType
        False!
end


class TypecheckImpl { type }
    is BuiltinMethodImpl

    method name
        "typecheck:"!


    method returnType
        type!


    method lowerToCps: aContinuation in: graph with: worklist
        (aContinuation args size is 3) assert: "TypecheckImpl#lowerToCps:in:with".
        let value = aContinuation args at: 2.
        let valueType = value type.
        let cc = aContinuation args last.

        -- If value has the correct type, we can eliminate
        -- the typecheck entirely.
        valueType is type
            => { aContinuation removeArgs.
                 aContinuation addArgs: [value].
                 aContinuation target: cc.
                 worklist push: cc }.

        -- CC has no other uses we can propagate the type information
        -- there. (Could also propagate the value information, but
        -- that doesn't seem super useful unless the value is constant,
        -- in which case the first leg takes care of it above.)
        (cc uses isOnly: aContinuation)
            => { cc propagateTypes: [type].
                 worklist push: cc }!
end


interface InlineMethodImpl
    is BuiltinMethodImpl

    method lowerToCps: aContinuation in: graph with: worklist
        let args = aContinuation args.
        let pattern = self inliner apply: args butlast.
        let newRecv = pattern first.
        let newSelector = pattern second.
        let methodExpr = graph findMethod: newSelector
                               for: newRecv.
        aContinuation target: methodExpr.
        aContinuation removeArgs.
        aContinuation addArgs: [newRecv].
        aContinuation addArgs: (pattern from: 3 to: pattern size).
        aContinuation addArgs: [args last].     -- cc
        worklist push: methodExpr args first. -- CLASS_OF
        worklist push: aContinuation.
        worklist push: aContinuation target!
end

class IntegerPlusImpl {}
    is InlineMethodImpl

    method name
        "+"!


    method inliner
        { |a b| [b, "addInteger:", a] }!
end


interface PrimitiveInlineMethodImpl
    is BuiltinMethodImpl

    method lowerToCps: aContinuation in: graph with: worklist
        let args = aContinuation args.
        let pattern = self primitiveInliner apply: args butlast.
        let cc = args last.
        let primop = graph ensureOperation: pattern first
                           args: pattern rest.
        aContinuation removeArgs.
        aContinuation addArgs: [primop].
        aContinuation target: cc.
        cc propagateTypes: [primop type]!
end


class IntegerAddIntegerImpl {}
    is PrimitiveInlineMethodImpl

    method name
        "addInteger:"!


    method primitiveInliner
        { |a b| [ADDI, b, a] }!
end


class IfTrueIfFalseImpl {}
    is BuiltinMethodImpl

    method name
        "ifTrue:ifFalse:"!

    method lowerToCps: aContinuation in: graph with: worklist
        (aContinuation args size is 4) assert: "IfTrueIfFalseImpl#lowerToCps:in:with".
        let args = aContinuation args.
        let cond = args at: 1.
        let thenCont = args at: 2.
        let elseCont = args at: 3.
        let cc = args at: 4.
        aContinuation target: (graph ensureOperation: SELECT
                                     args: [cond, thenCont, elseCont]).
        aContinuation removeArgs.
        aContinuation addArgs: [cc]!
end


class WhileLoopImpl { name while }
    is BuiltinMethodImpl

    direct method newWhileTrue
        self name: "whileTrue:" while: True!


    direct method newWhileFalse
        self name: "whileFalse:" while: False!


    method lowerToCps: aContinuation in: graph with: worklist
        (aContinuation args size is 3) assert: "WhileLoopImpl#lowerToCps:in:with".
        let ignore1 = graph makeVariable: "$ignore".
        -- valueCont args will be patched with the branch
        let valueCont = graph continuation: "$loopTest"
                              params: [ignore1]
                              target: (aContinuation args at: 1)
                              args: [].
        let bodyCont = graph continuation: "$loopBody"
                             params: []
                             target: (aContinuation args at: 2)
                             args: [valueCont].
        -- Explicit loop exit continuation so we don't need to
        -- pass False as argument to selected continuation each time
        -- through the branch.
        let exitCont = graph continuation: "$loopExit"
                             params: []
                             target: (aContinuation args at: 3)
                             args: [graph ensureConstant: False].
        let cond = graph makeVariable: "$cond".
        let selectArgs = while
                             ifTrue: { [cond, bodyCont, exitCont] }
                             ifFalse: { [cond, exitCont, bodyCont] }.
        let branch = graph continuation: "$while{while}"
                           params: [cond]
                           target: (graph ensureOperation: SELECT
                                          args: selectArgs)
                           args: [].
        valueCont addArgs: [branch].
        let headCont = graph continuation: "$loopHead"
                             params: aContinuation params copy
                             target: valueCont
                             args: [graph ensureConstant: False].
        aContinuation removeArgs.
        aContinuation replaceUsesWith: headCont.
        aContinuation target: False.
        aContinuation removeParams.
        worklist push: headCont.
        worklist push: valueCont.
        worklist push: bodyCont.
        worklist push: exitCont!
end


class ClassDefinition { name ownClassDefinition methodDictionary }

    -- ClassDefinition itself is used as the ClassDefinition for Class.
    -- Clever, yes? Horrible, maybe!
    direct method name
        "Class"!


    direct method classDefinition
        self!


    direct method name: name
        self name: name methods: []!


    direct method name: name methods: methods
        let instanceMethodDictionary = Dictionary new.
        let directMethodDictionary = Dictionary new.
        let ownClassDefinition = self name: "{name} class"
                                      ownClassDefinition: ClassDefinition
                                      methodDictionary: directMethodDictionary.
        let classDefinition = self name: name
                                   ownClassDefinition: ownClassDefinition
                                   methodDictionary: instanceMethodDictionary.
        methods do: { |each|
                      each home: classDefinition.
                      instanceMethodDictionary put: each at: each name }.

        let typecheck = BuiltinMethod home: ownClassDefinition
                                      impl: (TypecheckImpl type: classDefinition).
        directMethodDictionary
            put: typecheck
            at: typecheck name.

        classDefinition!


    method classDefinition
        ownClassDefinition!


    method findMethod: name
        methodDictionary at: name!


    method displayString
        name!

    method toString
        name!
end


define FunctionClassDefinition
    (ClassDefinition name: "Function"
                     methods: [BuiltinMethod new: WhileLoopImpl newWhileTrue,
                               BuiltinMethod new: WhileLoopImpl newWhileFalse])!


class Set { dict }
    is Object

    direct method new
        self dict: Dictionary new!


    direct method with: node
        let new = self new.
        new add: node.
        new!


    method add: node
        let old = dict at: node.
        dict put: node at: node.
        old is False!


    method remove: node
        dict remove: node!


    method collect: block
        dict keys collect: block!


    method includes: node
        ((dict at: node) is False) not!


    method size
        dict size!


    method isEmpty
        dict isEmpty!


    method isOnly: node
        dict size is 1
            ifTrue: { (dict values first) is node }
            ifFalse: { False }!


    method replaceUses: node1 with: node2
        dict doKeys: { |each|
                       (each is node1) not assert: "Replacement target is an immediate use".
                       each replaceUses: node1 with: node2 }!


    method do: block
        dict values do: block!

    method doSorted: block
        dict values sort do: block!
end


class OpMap { list }
    is Object

    direct method new
        self list: List new!


    method kind: kind withArguments: args ifNonePut: block
        kind isFoldable
            ifTrue: { list do: { |each|
                                 each kind is kind
                                     => { (each args == args)
                                              => { return each } } } }.
        let new = block value.
        list push: new.
        new!


    method mergeDuplicates
        -- FIXME: O(N^2) with current OpMap!
        list do: { |each| self tryMerge: each }!


    method tryMerge: operation
        operation isFoldable
            ifFalse: { return False }.
        operation isUnused
            ifTrue: { return False }.
        list do: { |each| self tryMerge: operation with: each }!


    method tryMerge: op1 with: op2
        op1 is op2
            ifTrue: { return False }.
        op2 isUnused
            ifTrue: { return False }.
        op1 kind is op2 kind
            ifTrue: { op1 args == op2 args
                          ifTrue: { op2 replaceUsesWith: op1 } }!


    method reject: block
        Self list: (list reject: block)!


    method select: block
        Self list: (list select: block)!


    method do: block
        list do: block!
end


class Worklist { list dict }
    is Object

    direct method new
        self list: List new
             dict: Dictionary new!


    method push: thing
        dict at: thing
             ifNonePut: { list push: thing.
                          thing }!


    method pushAll: aList
        aList do: { |each| self push: each }!


    method pop
        let thing = list pop.
        dict remove: thing.
        thing!


    method isEmpty
        list isEmpty!
end


define DebugVerify False!


interface Expression
    is Object


    method < other
        self id < other id!


    method doSubExpressions: _
        False!


    method propagateTypes: _
        False!


    method hasKnownClass
        False!


    method simplify
        False!


    method debugVerify: what
        DebugVerify
            ifTrue: { self verify: what }!


    method type
        False!


    method verify: _
        False!


    method isUnused
        self uses isEmpty!


    method addUse: use
        self uses add: use!


    method removeUse: use
        self uses remove: use.
        self debugVerify: "Expression#removeUse"!


    method replaceUsesWith: expr
        self uses do: { |each| each replaceUses: self with: expr }.
        self debugVerify: "Expression#replaceUsesWith:"!


    method toString
        "#<{self classOf name} {self printName}>"!


    required method uses
    required method printName
    required method replaceUses: expr1 with: expr2
end


class Constant { id::Integer
                 value
                 uses::Set }
    is Expression


    direct method id: id value: value
        self id: id
             value: value
             uses: Set new!


    method hasKnownClass
        True!


    method printName
        value displayString!


    method replaceUses: expr1 with: expr2
        Error raise: "Constant#replaceUses:with: is invalid"!


    method visitBy: visitor
        visitor visitConstant: self!
end


class CpsSelector { name }
    method displayString
        "#{name}"!
end


class Global { id::Integer
               name::String
               uses::Set
               definition }
    is Expression

    direct method id: id name: name
        self id: id
             name: name
             uses: Set new
             definition: False!


    method definition: new::ClassDefinition
        definition = new!


    method hasKnownClass
        (definition is False) not!


    method classDefinition
        definition classDefinition!


    method replaceUses: expr1 with: expr2
        Error raise: "Global#replaceUses:with: is invalid"!


    method printName
        "{name}:Global"!


    method visitBy: visitor
        visitor visitGlobal: self!
end



class Variable { id::Integer
                 name
                 type
                 defs::Set
                 uses::Set }
    is Expression

    direct method id: id
        self id: id
             name: False
             type: False
             defs: Set new
             uses: Set new!


    direct method id: id name: name
        self id: id
             name: name
             type: False
             defs: Set new
             uses: Set new!


    method addDef: def
        defs add: def!


    method addUse: use
        use is self
            ifFalse: { uses add: use }!


    method removeDef: def
        defs remove: def.
        (defs isEmpty and: uses isEmpty not)
            ifTrue: { Error raise: "Variable {self} lost definitions while still being used by: {self uses collect: #printName}"}!


    method replaceUses: expr1 with: expr2
        Error raise: "Variable#replaceUses:with: is invalid"!


    method type: new
        (type is new)
            ifTrue: { return False }.
        (type is False)
            ifFalse: { Error raise: "Variable already has a type: {self}. Old={type}, New={new}" }.
        type = new!


    method hasKnownClass
        ClassDefinition includes: type!


    method classDefinition
        type :: ClassDefinition!


    method printName
        name is False
            ifTrue: { "$var:{id}" }
            ifFalse: { "{name}:{id}" }!


    method visitBy: visitor
        visitor visitVariable: self!
end


interface OperationKind
    direct method isFoldable
        True!
end


class ADDI {}
    is OperationKind


    direct method name
        "addi"!


    direct method visit: operation by: visitor
        visitor visitAddi: operation!
end


class CLASS_OF {}
    is OperationKind

    direct method name
        "classOf"!


    direct method visit: operation by: visitor
        visitor visitClassOf: operation!
end


class FIND_METHOD {}
    is OperationKind

    direct method name
        "findMethod"!


    direct method visit: operation by: visitor
        visitor visitFindMethod: operation!
end


class SELECT {}
    is OperationKind

    direct method name
        "select"!

    direct method visit: operation by: visitor
        visitor visitSelect: operation!
end


class INVALID {}
    is OperationKind

    direct method name
        "invalid"!
end


class Operation { id::Integer
                  kind
                  args::Array
                  uses::Set }
    is Expression

    direct method id: id kind: kind args: args
        let new = self id: id
                       kind: kind
                       args: args
                       uses: Set new.
        args do: { |each| each addUse: new }.
        new!


    method isFoldable
        kind isFoldable!


    method doSubExpressions: block
        args do: block!


    method verify: what
        (args allSatisfy: { |each| each uses includes: self })
            assert: "{self printName} should use its args: {args collect: #printName}"!


    method printName
        StringOutput
            with: { |out|
                    out
                        ; print: kind name
                        ; print: ":"
                        ; print: id
                        ; print: "(".
                    args
                        do: { |each| out print: each printName }
                        interleaving: { out print: ", " }.
                    out print: ")" }!


    method flush
        args do: { |each| each removeUse: self }.
        args = [].
        kind = INVALID!



    method replaceUses: expr1 with: expr2
        expr2 addUse: self.
        args = args replace: expr1 with: expr2.
        expr1 removeUse: self.
        self debugVerify: "Operation#replaceUses:"!


    method visitBy: visitor
        visitor visitOperation: self!
end


class Continuation { id::Integer
                     name
                     params::Array
                     target
                     args::Array
                     uses::Set }
    is Expression

    direct method id: id name: name params: params target: target args: args
        let new = self id: id
                       name: name
                       params: params
                       target: target
                       args: args asArray
                       uses: Set new.
        params do: { |each| each addDef: new }.
        target is False
            ifFalse: {target addUse: new }.
        args do: { |each| each addUse: new }.
        new!


    method verify: what
        (target is False)
            ifFalse: { (target uses includes: self)
                           ifFalse: { Error raise: "{self} does not use its target: {target} ({what})" } }.
        let badParams = params reject: { |each| each defs includes: self }.
        badParams isEmpty assert: "Continuation should define its params".
        let badArgs = args reject: { |each| each uses includes: self }.
        badArgs isEmpty assert: "Continuation should uses its args".
        self!


    method name: new
        name = new!


    method doSuccessors: block
        -- Iterate over all possible successors of the block.
        --
        -- FIXME: Overly conservative since we don't propagate types
        -- well enough to be able to filter out variables only bound
        -- to integers as successors.
        let filteredBlock = { |each|
                              (Constant includes: each)
                                  ifTrue: { (MethodDefinition includes: each value)
                                                ifTrue: { block value: each } }
                                  ifFalse: { block value: each } }.
        let target = self target.
        (Operation includes: target)
            => { -- FIND_METHOD is a known case: only successor is the last argument.
                 target kind is FIND_METHOD
                     => { return block value: self args last }.
                 -- SELECT is partially known: 2nd and 3rd SELECT arguments are successors,
                 -- as are all continuation arguments.
                 target kind is SELECT
                     => { target args rest do: filteredBlock.
                          return args do: filteredBlock } }.
        -- General case
        block value: target.
        return args do: filteredBlock!


    method hasKnownClass
        True!


    method classDefinition
        FunctionClassDefinition!


    method doSubExpressions: block
        target => { block value: target }.
        args do: block!


    method propagateTypes: types
        params with: types
               do: { |param type| param type: type }!


    method propagateTargetType
        (Constant includes: target)
            => { let value = target value .
                 (MethodDefinition includes: value)
                     => { args last propagateTypes: [value returnType] } }!


    method simplify
        { self hasUniqueTarget }
            whileTrue: { self inlineUniqueTarget }.
        self!


    method hasUniqueTarget
        (Continuation includes: target)
            ifTrue: { target uses isOnly: self }!


    method inlineUniqueTarget
        self args
            with: target params
            do: { |arg param|
                  param replaceUsesWith: arg }.
        self replaceArgsFrom: target.
        target unlink.
        self debugVerify: "Continuation#inlineUniqueTarget"!


    method replaceUses: expr1 with: expr2
        expr2 addUse: self.
        target is expr1
            ifTrue: { target = expr2 }.
        args replace: expr1 with: expr2.
        expr1 removeUse: self.
        self debugVerify: "Continuation#replaceUses:with:"!



    method replaceArgsFrom: other::Continuation
        -- This is more convenient than #args:, since
        -- we usually want to copy the array!
        args do: { |each| each removeUse: self }.
        args = other args copy.
        args do: { |each| each addUse: self }.
        self debugVerify: "Continuation#replaceArgsFrom:"!


    method removeParams
        params do: { |each| each removeDef: self }.
        params = [].
        self debugVerify: "Continuation#removeParams"!


    method removeArgs
        args do: { |each| each removeUse: self }.
        args = [].
        self debugVerify: "Continuation#removeArgs"!


    method addParams: new
        new do: { |each| each addDef: self }.
        params = params append: new.
        self debugVerify: "Continuation#addParams:"!


    method addArgs: new
        new do: { |each| each addUse: self }.
        args = args append: new.
        self debugVerify: "Continuation#addArgs:"!


    method target: new
        -- No copy needed here, so #target: is the way to go.
        target => { target removeUse: self }.
        target = new.
        target => { target addUse: self }.
        self debugVerify: "Continuation#target:"!


    method unlink
        self removeArgs.
        self replaceUsesWith: target.
        self target: False.
        -- args and target may use params, so need to remove last!
        self removeParams.
        self debugVerify: "Continuation#unlink"!


    method printName
        name is False
            ifTrue: { "$cont:{id}" }
            ifFalse: { "{name}:{id}" }!


    method toString
        "#<Continuation {self printName} -> {target printName}>"!


    method visitBy: visitor
        visitor visitContinuation: self!
end


class CpsGraph { entry::Continuation
                 exit::Variable
                 lastId::Integer
                 operations::OpMap
                 constants::Dictionary
                 globals::Dictionary
                 selectors::Dictionary
                 continuations::List }
    is Expression

    direct method new
        -- Entry node just binds the exit continuation. ID 1
        -- is reserved for graph itself
        let exit = Variable id: 3
                            name: "$return".
        let entry = Continuation id: 2
                                 name: "$entry"
                                 params: [exit]
                                 target: False
                                 args: [].
        let graph = self
                        entry: entry
                        exit: exit
                        lastId: 3
                        operations: OpMap new
                        constants: Dictionary new
                        globals: Dictionary new
                        selectors: Dictionary new
                        continuations: (List with: entry).
        exit addUse: exit.
        entry addUse: graph.
        graph!


    method id
        1!


    method uses
        Set new!


    method printName
        "graph:1"!


    method replaceUses: expr1 with: expr2
        expr1 removeUse: self.
        exit is expr1
            ifTrue: { exit = expr2 }.
        entry is expr1
            ifTrue: { entry = expr2 }.
        expr2 addUse: self!


    method cleanup
        operations mergeDuplicates.
        continuations do: { |each| each verify: "CpsGrapg#cleanup" }.
        let worklist = Worklist new.
        worklist pushAll: (continuations select: #isUnused).
        worklist pushAll: (operations select: #isUnused).
        { worklist isEmpty }
            whileFalse: { let expr = worklist pop.
                          -- Output debug println: "flushing: {expr printName}".
                          expr doSubExpressions: { |each|
                                                   each removeUse: expr.
                                                   each isUnused
                                                       ifTrue: { worklist push: each }} }.
        continuations = continuations reject: #isUnused.
        operations = operations reject: #isUnused!


    method doExpressions: block
        continuations do: block.
        operations do: block!


    method copyContinuation: aCont
           self continuation: aCont name
                params: aCont params
                target: aCont target
                args: aCont args!


    method entry: target
        entry target: target.
        entry simplify.
        self cleanup.
        self!


    method optimize
        CpsOptimizer optimize: self.
        self cleanup.
        self!


    method continuation: name params: params target: target args: args
        let cont = Continuation id: self nextId
                                name: name
                                params: params
                                target: target
                                args: args.
        continuations push: cont.
        cont!


    method makeVariable: name
        Variable
            id: self nextId
            name: name!


    method makeTemporary
        Variable
            id: self nextId!


    method ensureConstant: value
        constants
            at: value
            ifNonePut: { Constant
                             id: self nextId
                             value: value }!

    method ensureGlobal: name
        globals
            at: name
            ifNonePut: { Global
                             id: self nextId
                             name: name }!


    method addGlobalDefinitions: definitions
        definitions
            do: { |def|
                  let global = self ensureGlobal: def name.
                  global definition: def }!


    method ensureSelector: name
        selectors
            at: name
            ifNonePut: { self ensureConstant: (CpsSelector name: name) }!



    method ensureOperation: kind args: args
        operations
            kind: kind
            withArguments: args
            ifNonePut: { Operation
                             id: self nextId
                             kind: kind
                             args: args }!


    method classOf: recv
           self ensureOperation: CLASS_OF
                args: [recv]!


    method findMethod: name for: recv
        let selector = self ensureSelector: name.
        let classOf = self classOf: recv.
        self ensureOperation: FIND_METHOD
             args: [classOf, selector]!


    method nextId
        lastId = lastId + 1!
end


class CpsConverter { graph var next }

    direct method new
        self graph: CpsGraph new
             var: False
             next: False!


    direct method convert: syntax withGlobalDefinitions: defs
        let converter = self new.
        converter graph addGlobalDefinitions: defs.
        converter graph
            entry: (syntax visitBy: converter
                           with: converter graph exit).
        converter graph optimize!


    method bindVariable: var
        CpsConverter
            graph: graph
            var: var
            next: self!


    method bindVariables: vars
        let converter = self.
        vars do: { |each|
                   converter = converter bindVariable: each }.
        converter!


    method findBinding: name
        var is False
            ifTrue: { return graph ensureGlobal: name }.
        var name == name
            ifTrue: { var }
            ifFalse: { self next findBinding: name }!


    method visitBlock: syntax with: cc
        let blockReturn = graph makeVariable: "$ret".
        let blockVars = syntax parameters
                            collect: { |each| graph makeVariable: each name }.
        let block = syntax body
                        visitBy: (self bindVariables: blockVars)
                        with: blockReturn.
        block name: "$block".
        block addParams: (blockVars append: [blockReturn]).
        graph continuation: "$makeClosure"
              params: []
              target: cc
              args: [block simplify]!


    method visitLet: syntax with: cc
        let var = graph makeVariable: syntax variable name.
        let body = syntax body
                       visitBy: (self bindVariable: var)
                       with: cc.
        let bind = graph continuation: "$let"
                         params: [var]
                         target: body
                         args: [].
        (syntax value visitBy: self with: bind simplify)
            simplify!


    method visitLiteral: syntax with: cc
        let const = graph ensureConstant: syntax value.
        (graph continuation: "$const_ref"
              params: []
              target: cc
              args: [const])
        simplify!


    method visitReturn: syntax with: _
        syntax value visitBy: self with: graph exit!


    method visitSend: syntax with: cc
        let recv = graph makeVariable: "$recv".
        let args = syntax arguments
                       collect: { |a| graph makeVariable: "$arg" }
                       as: Array.
        let methodFunction = graph findMethod: syntax selector name
                                   for: recv.
        let next = graph continuation: "$send"
                         params: []
                         target: methodFunction
                         args: ([recv] append: args append: [cc]).
        syntax arguments reverse
            with: args reverse
            do: { |syntaxArg var|
                  let bind = graph continuation: "$bind_arg"
                                   params: [var]
                                   target: next
                                   args: [].
                  next = (syntaxArg visitBy: self with: bind)
                             simplify }.
        let recvBind = graph continuation: "$bind_recv"
                             params: [recv]
                             target: next
                             args: [].
        syntax receiver visitBy: self with: recvBind simplify!


    method visitSeq: syntax with: cc
        let then = syntax then visitBy: self with: cc.
        let discard = graph continuation: "$seq"
                            params: [graph makeVariable: "$ignore"]
                            target: then
                            args: [].
        syntax first visitBy: self with: discard simplify!


    method visitValueTypeDeclaration: syntax with: cc
        let value = graph makeVariable: "$value".
        let type = graph makeVariable: "$type".
        let checkCont = graph continuation: "$typecheck"
                              params: [type]
                              target: (graph findMethod: "typecheck:" for: type)
                              args: [type, value, cc].
        let typeCont = syntax type visitBy: self with: checkCont.
        let bindValue = graph continuation: "$bind"
                              params: [value]
                              target: typeCont
                              args: [].
        syntax value visitBy: self with: bindValue!


    method visitVariable: syntax with: cc
        let var = self findBinding: syntax name.
        (Continuation includes: cc)
            => { cc uses isEmpty
                     => { cc params first replaceUsesWith: var.
                          cc removeParams.
                          return cc } }.
        graph continuation: "$var_ref"
              params: []
              target: cc
              args: [var]!
end


class CpsOptimizer { worklist graph }

    direct method optimize: graph
        let worklist = Worklist new.
        graph doExpressions: { |each| worklist push: each }.
        (self worklist: worklist graph: graph)
            optimize!


    method optimize
        { worklist isEmpty }
            whileFalse: { worklist pop visitBy: self }!


    method visitContinuation: aCont
        -- Was this continuation eliminated while it was on the worklist?
        aCont uses isEmpty
            => { return False }.
        -- Do strictly local simplifications.
        aCont simplify.
        -- If the target is a known method with an optimizer, use that.
        let target = aCont target.
        (Constant includes: target)
            => { let aMethod = target value.
                 (MethodDefinition includes: aMethod)
                     => { aMethod lowerToCps: aCont in: graph with: worklist } }!


    method visitOperation: anOperation
        anOperation kind visit: anOperation by: self!


    method visitClassOf: aClassOf
        let recv = aClassOf args first.
        (recv hasKnownClass)
            ifTrue: { let const = graph ensureConstant: recv classDefinition.
                      aClassOf uses
                          do: { |each|
                                each replaceUses: aClassOf with: const.
                                worklist push: each }.
                      aClassOf flush }!


    method visitFindMethod: aFindMethod
        let classArg = aFindMethod args at: 1.
        (Constant includes: classArg)
            => { let classDef = classArg value.
                 (ClassDefinition includes: classDef)
                     => { let selectorArg = aFindMethod args at: 2.
                          (Constant includes: selectorArg)
                              => { let selector = selectorArg value.
                                   (CpsSelector includes: selector)
                                       => { let methodFunction = classDef findMethod: selector name.
                                            (methodFunction is False) not
                                                => { let constMethod = graph ensureConstant: methodFunction.
                                                     aFindMethod replaceUsesWith: constMethod.
                                                     constMethod uses do: { |each|
                                                                            each propagateTargetType.
                                                                            worklist push: each } } } } } }!

    method visitSelect: _
        False!


    method visitTypeInfo: _
        False!


    method visitGlobal: _
        False!


    method visitVariable: _
        False!


    method visitConstant: _
        False!
end


class CpsPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output newline.
        visitor visit: graph entry!


    method visit: other::Expression
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitContinuation: aCont
        output
            ; print: aCont printName
            ; print: "(".
        aCont params
            do: { |each| output print: each printName }
            interleaving: { output print: ", " }.
        output println: "):".
        output
            ; print: "    "
            ; print: aCont target printName
            ; print: "(".
        aCont args
            do: { |arg| output print: arg printName }
            interleaving: { output print: ", " }.
        output println: ")".
        aCont args do: { |each| self visit: each }.
        self visit: aCont target!


    method visitConstant: _
        False!


    method visitVariable: _
        False!


    method visitGlobal: _
        False!


    method visitOperation: anOp
        anOp args do: { |each| self visit: each }!
end


class CpsGraphwizPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output writeString: "\nstrict digraph \{\n".
        output writeString: "    \"{graph entry printName}\" [color=red]\n".
        visitor visit: graph entry.
        output writeString: "\}\n"!


    method visit: other::Expression
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitAll: nodes
        nodes do: { |each| self visit: each }!


    method visitContinuation: aCont
        output writeString: "    \"{aCont printName}\" [shape=box]\n".
        aCont params
            do: { |each|
                  each uses isEmpty
                      ifFalse: { output writeString: "    \"".
                                 output writeString: aCont printName.
                                 output writeString: "\" -> \"".
                                 output writeString: each printName.
                                 output writeString: "\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]\n" } }.
        aCont doSuccessors: { |each|
                              output writeString: "    \"".
                              output writeString: aCont printName.
                              output writeString: "\" -> \"".
                              output writeString: each printName.
                              output writeString: "\" [arrowhead=vee]\n" }.
        self visit: aCont target.
        self visitAll: aCont args!

    method visitVariable: aVar
        aVar uses
            doSorted: { |each|
                        output writeString: "    \"".
                        output writeString: aVar printName.
                        output writeString: "\" -> \"".
                        output writeString: each printName.
                        output writeString: "\" [style=dotted]\n" }.
        False!


    method visitConstant: aConst
        False!


    method visitGlobal: aGlobal
        False!


    method visitOperation: anOperation
        anOperation uses
            doSorted: { |each|
                        output writeString: "    \"".
                        output writeString: anOperation printName.
                        output writeString: "\" -> \"".
                        output writeString: each printName.
                        output writeString: "\" [style=dotted]\n" }.
        self visitAll: anOperation args!
end


class TestCPS { assert system }
    is TestSuite

    direct method assert: assert
        self assert: assert system: False!

    method system: new
        system = new!

    method convert: source
        self convert: source withGlobalDefinitions: []!


    method convert: source withGlobalDefinitions: defs
        let syntax = Parser parseExpression: source.
        CpsConverter convert: syntax withGlobalDefinitions: defs!


    method test_convert_addition_of_integers_optimizes_to_operation_addi
        let cps = self convert: "let a = X a :: Integer. let b = X b :: Integer. a + b"
                       withGlobalDefinitions: [(ClassDefinition
                                                    name: "Integer"
                                                    methods: [BuiltinMethod new: IntegerPlusImpl new,
                                                              BuiltinMethod new: IntegerAddIntegerImpl new])].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    findMethod:40(classOf:25(X:Global), #a)(X:Global, $bind:36)
$bind:36($value:31):
    methodFunction(Integer class#typecheck:)(Integer:Global, $value:31, $let:30)
$let:30(a:5):
    findMethod:26(classOf:25(X:Global), #b)(X:Global, $bind:22)
$bind:22($value:16):
    methodFunction(Integer class#typecheck:)(Integer:Global, $value:16, $let:15)
$let:15(b:6):
    $return:3(addi:51(a:5, b:6))
"!

    method test_convert_arity_0_block
        let cps = self convert: "\{ 421 }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3($block:6)
$block:6($ret:4):
    $ret:4(421)
"!


    method test_convert_arity_3_block
        let cps = self convert: "\{ |a b c| a + b + c }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3($block:22)
$block:22(a:5, b:6, c:7, $ret:4):
    findMethod:19(classOf:18(a:5), #+)(a:5, b:6, $bind_recv:15)
$bind_recv:15($recv:8):
    findMethod:12(classOf:11($recv:8), #+)($recv:8, c:7, $ret:4)
"!


    method test_convert_boolean_ifTrueIfFalse
        let cps = self convert: "X :: Boolean ifTrue: \{ 1 } ifFalse: \{ 2 }"
                       withGlobalDefinitions: [(ClassDefinition
                                                    name: "Boolean"
                                                    methods: [(BuiltinMethod new: IfTrueIfFalseImpl new)])].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    methodFunction(Boolean class#typecheck:)(Boolean:Global, X:Global, $bind_recv:22)
$bind_recv:22($recv:5):
    select:35($recv:5, $block:20, $block:15)($return:3)
$block:20($ret:18):
    $ret:18(1)
$block:15($ret:13):
    $ret:13(2)
"!


    method test_convert_closure_whileFalse
        let cps = self convert: "\{ X maybe\} whileFalse: \{ Y something \}".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$loopHead:40($return:3):
    $loopTest:33(False)
$loopTest:33($ignore:32):
    findMethod:25(classOf:24(X:Global), #maybe)(X:Global, $whileFalse:39)
$whileFalse:39($cond:37):
    select:38($cond:37, $loopExit:36, $loopBody:34)()
$loopExit:36():
    $return:3(False)
$loopBody:34():
    findMethod:15(classOf:14(Y:Global), #something)(Y:Global, $loopTest:33)
"!


    method test_convert_closure_whileTrue
        let cps = self convert: "\{ X maybe\} whileTrue: \{ X something \}".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$loopHead:39($return:3):
    $loopTest:32(False)
$loopTest:32($ignore:31):
    findMethod:25(classOf:14(X:Global), #maybe)(X:Global, $whileTrue:38)
$whileTrue:38($cond:36):
    select:37($cond:36, $loopBody:33, $loopExit:35)()
$loopBody:33():
    findMethod:15(classOf:14(X:Global), #something)(X:Global, $loopTest:32)
$loopExit:35():
    $return:3(False)
"!

    method test_graphwiz_closure_whileTrue
        let cps = self convert: "\{ X maybe\} whileTrue: \{ X something \}".
        (system currentDirectory / "closure_whileTrue.dot")
            truncateExisting forWrite
                createOrOpen: { |dot| CpsGraphwizPrinter print: cps to: dot }.
        assert that: { CpsGraphwizPrinter printToString: cps }
               equals: "
strict digraph \{
    \"$loopHead:39\" [color=red]
    \"$loopHead:39\" [shape=box]
    \"$loopHead:39\" -> \"$return:3\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]
    \"$loopHead:39\" -> \"$loopTest:32\" [arrowhead=vee]
    \"$loopTest:32\" [shape=box]
    \"$loopTest:32\" -> \"$whileTrue:38\" [arrowhead=vee]
    \"findMethod:25(classOf:14(X:Global), #maybe)\" -> \"$loopTest:32\" [style=dotted]
    \"classOf:14(X:Global)\" -> \"findMethod:15(classOf:14(X:Global), #something)\" [style=dotted]
    \"classOf:14(X:Global)\" -> \"findMethod:25(classOf:14(X:Global), #maybe)\" [style=dotted]
    \"$whileTrue:38\" [shape=box]
    \"$whileTrue:38\" -> \"$cond:36\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]
    \"$whileTrue:38\" -> \"$loopBody:33\" [arrowhead=vee]
    \"$whileTrue:38\" -> \"$loopExit:35\" [arrowhead=vee]
    \"select:37($cond:36, $loopBody:33, $loopExit:35)\" -> \"$whileTrue:38\" [style=dotted]
    \"$cond:36\" -> \"select:37($cond:36, $loopBody:33, $loopExit:35)\" [style=dotted]
    \"$loopBody:33\" [shape=box]
    \"$loopBody:33\" -> \"$loopTest:32\" [arrowhead=vee]
    \"findMethod:15(classOf:14(X:Global), #something)\" -> \"$loopBody:33\" [style=dotted]
    \"$loopExit:35\" [shape=box]
    \"$loopExit:35\" -> \"$return:3\" [arrowhead=vee]
    \"$return:3\" -> \"$loopExit:35\" [style=dotted]
}
"!


    method test_convert_constant_integer
        let cps = self convert: "123".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(123)
"!


    method test_convert_global
        let cps = self convert: "X".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(X:Global)
"!


    method test_convert_let
        let cps = self convert: "let x = 87. x".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(87)
"!


    method test_convert_return
        let cps = self convert: "return 421. X boom".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(421)
"!


    method test_convert_send
        let cps = self convert: "X some: 12 message: 97".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    findMethod:9(classOf:8(X:Global), #some:message:)(X:Global, 12, 97, $return:3)
"!


    method test_convert_seq
        let cps = self convert: "X some: 12 message: 97. Y + Z".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    findMethod:21(classOf:20(X:Global), #some:message:)(X:Global, 12, 97, $seq:15)
$seq:15($ignore:14):
    findMethod:8(classOf:7(Y:Global), #+)(Y:Global, Z:Global, $return:3)
"!


    method test_convert_typecheck
        let cps = self convert: "X :: Integer".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    findMethod:8(classOf:7(Integer:Global), #typecheck:)(Integer:Global, X:Global, $return:3)
"!


    method test_convert_typecheck_gives_type
        let cps = self convert: "X::Integer + Y"
                       withGlobalDefinitions: [(ClassDefinition
                                                    name: "Integer"
                                                    methods: [(UserMethod name: "+")])].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    methodFunction(Integer class#typecheck:)(Integer:Global, X:Global, $bind_recv:13)
$bind_recv:13($recv:5):
    methodFunction(Integer#+)($recv:5, Y:Global, $return:3)
"!


    method test_convert_typecheck_redundancy
        let cps = self convert: "X :: Integer :: Integer"
                       withGlobalDefinitions: [(ClassDefinition name: "Integer")].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    methodFunction(Integer class#typecheck:)(Integer:Global, X:Global, $bind:11)
$bind:11($value:5):
    $return:3($value:5)
"!


end

class Main {}
    direct method run: command in: system
        TestCPS runTests: (Assert reportingTo: system output)
                in: system!
end
