import lib.assert.Assert
import impl.parser.Parser


interface Log
    direct method newline
        Output debug newline!
    direct method println: what
        Output debug println: what!
end


interface CpsValue
    -- Valid value to flow through CPS in evaluator
    -- or as a constant.
    required method printName
    required method classDefinition
    required method hostValue
end


interface MethodDefinition
    is Object
    is CpsValue

    method returnType
        False!


    method lowerToCps: _ in: _ with: _
        False!


    method printName
        "{self home name}#{self name}"!


    method toString
        "#<{self classOf name} {self home name}#{self name}>"!


    method visitBy: visitor
        visitor visitMethodDefinition: self!


    method hostValue
        self!

    method classDefinition
        MethodClassDefinition!
end


class UserMethod { name home }
    is MethodDefinition

    direct method name: name
        self name: name
             home: False!

    method home: new
        (home is False)
            ifFalse: { Error raise: "{self} already has a home: {self}" }.
        home= new!
end


class BuiltinMethod { home impl }
    is MethodDefinition

    direct method new: impl
        self home: False
             impl: impl!


    method name
        impl name!


    method apply: args
        impl apply: args in: home!


    method returnType
        impl returnType!


    method lowerToCps: aCont in: graph with: worklist
        impl lowerToCps: aCont in: graph with: worklist!


    method home: new
        (home is False)
            ifFalse: { Error raise: "BuiltinMethod {name} already has a home: {home}" }.
        home = new!
end


interface BuiltinMethodImpl
    method returnType
        False!
end


class OpaqueIdentityImpl {}
    is BuiltinMethodImpl

    method name
        "opaqueIdentity"!

    method lowerToCps: _aCont in: _aGraph with: _worklist
        False!

    method apply: args in: _classDefinition
        args first!
end


class TypecheckImpl { type }
    is BuiltinMethodImpl


    method name
        "typecheck:"!


    method apply: args in: _
        let value = args second.
        value classDefinition is type
            ifFalse: { Error raise: "CPS type error! Wanted: {type}, got: {value} ({value classDefinition})" }.
        value!


    method returnType
        type!


    method lowerToCps: aContinuation in: graph with: worklist
        (aContinuation args size is 2) assert: "TypecheckImpl#lowerToCps:in:with".
        let apply = aContinuation target.
        let value = aContinuation args at: 2.
        let valueType = value type.
        let cc = apply target.

        -- If value has the correct type, we can eliminate
        -- the typecheck entirely.
        --
        -- Otherwise we propagate the type to cc.
        valueType is type
            ifTrue: { aContinuation removeArgs.
                      aContinuation addArgs: [value].
                      aContinuation target: cc }
            ifFalse: { (cc uses isOnly: apply)
                           => { cc propagateTypes: [type] } }.
        (Continuation includes: cc)
            ifTrue: { worklist pushAll: cc params first uses }!
end


interface InlineMethodImpl
    is BuiltinMethodImpl


    method apply: args in: _classDefinition
        let pattern = self inliner apply: args.
        let newRecv = pattern first.
        let newSelector = pattern second.
        (newRecv classDefinition findMethod: newSelector)
            apply: ([newRecv]
                        append: (pattern
                                     from: 3
                                     to: pattern size))!


    method lowerToCps: aContinuation in: graph with: worklist
        let apply = aContinuation target.
        let args = aContinuation args.
        let pattern = self inliner apply: args.
        let newRecv = pattern first.
        let newSelector = pattern second.
        let newMethod = graph findMethod: newSelector
                              for: newRecv.
        let newApply = graph application: newMethod
                             target: apply target.
        aContinuation target: newApply.
        aContinuation removeArgs.
        aContinuation addArgs: [newRecv].
        aContinuation addArgs: (pattern from: 3 to: pattern size).
        -- CLASS_OF is new
        worklist push: newMethod args first.
        -- FIND_METHOD is new
        worklist push: newMethod.
        -- APPLY is new
        worklist push: newApply.
        -- Continuation has changed.
        worklist push: aContinuation!
end


class IntegerPlusImpl {}
    is InlineMethodImpl

    method name
        "+"!

    method inliner
        { |a b| [b, "addInteger:", a] }!
end


interface PrimitiveInlineMethodImpl
    is BuiltinMethodImpl

    method apply: args in: _classDefinition
        let pattern = self primitiveInliner apply: args.
        pattern first apply: pattern rest!

    method lowerToCps: aContinuation in: graph with: worklist
        let apply = aContinuation target.
        let args = aContinuation args.
        let pattern = self primitiveInliner apply: args.
        let primop = graph ensureOperation: pattern first
                           args: pattern rest.
        let cc = apply target.
        aContinuation removeArgs.
        aContinuation addArgs: [primop].
        aContinuation target: cc.
        cc propagateTypes: [primop type]!
end


class IntegerAddIntegerImpl {}
    is PrimitiveInlineMethodImpl

    method name
        "addInteger:"!


    method primitiveInliner
        { |a b| [ADDI, b, a] }!
end


class IfTrueIfFalseImpl { ifTrue ifFalse }
    is BuiltinMethodImpl

    method name
        let name = StringOutput
                       with: { |out|
                               ifTrue => { out writeString: "ifTrue:" }.
                               ifFalse => { out writeString: "ifFalse:" } }.
        name isEmpty not assert: "IfTrueIfFalseImpl#name".
        name!

    method lowerToCps: aContinuation in: graph with: worklist
        let lastArg = (ifTrue and: ifFalse)
                          ifTrue: { 3 }
                          ifFalse: { 2 }.
        (aContinuation args size is lastArg) assert: "IfTrueIfFalseImpl#lowerToCps:in:with".
        let apply = aContinuation target.
        let args = aContinuation args.
        let cond = args at: 1.
        let thenCont = ifTrue
                           ifTrue: { (args at: 2) renameIfSingleUse: "$ifTrue" }
                           ifFalse: { let ret = graph makeVariable: "$ret".
                                      graph continuation: "$ifTrue"
                                            params: [ret]
                                            target: ret
                                            args: [graph ensureConstant: FalseDefinition] }.
        let elseCont = ifFalse
                           ifTrue: { (args at: lastArg) renameIfSingleUse: "$ifFalse" }
                           ifFalse: { let ret = graph makeVariable: "$ret".
                                      graph continuation: "$ifFalse"
                                            params: [ret]
                                            target: ret
                                            args: [graph ensureConstant: FalseDefinition] }.
        aContinuation target: (graph select: cond
                                     then: thenCont
                                     else: elseCont).
        aContinuation removeArgs.
        aContinuation addArgs: [apply target]!
end


class WhileLoopImpl { name while }
    is BuiltinMethodImpl

    direct method newWhileTrue
        self name: "whileTrue:" while: True!


    direct method newWhileFalse
        self name: "whileFalse:" while: False!


    method lowerToCps: aContinuation in: graph with: worklist
        (aContinuation args size is 2) assert: "WhileLoopImpl#lowerToCps:in:with".
        let ignore1 = graph makeVariable: "$ignore".
        -- valueCont args will be patched with the branch
        let valueCont = graph continuation: "$loopTest"
                              params: [ignore1]
                              target: (aContinuation args at: 1)
                              args: [].
        let bodyCont = graph continuation: "$loopBody"
                             params: []
                             target: (aContinuation args at: 2)
                             args: [valueCont].
        -- Explicit loop exit continuation so we don't need to
        -- pass False as argument to selected continuation each time
        -- through the branch.
        let exitCont = graph continuation: "$loopExit"
                             params: []
                             target: (aContinuation target target)
                             args: [graph ensureConstant: FalseDefinition].
        let cond = graph makeVariable: "$cond".
        let thenElse = while
                           ifTrue: { [bodyCont, exitCont] }
                           ifFalse: { [exitCont, bodyCont] }.
        let branch = graph continuation: "$while{while}"
                           params: [cond]
                           target: (graph select: cond
                                          then: thenElse first
                                          else: thenElse second)
                           args: [].
        valueCont addArgs: [branch].
        let headCont = graph continuation: "$loopHead"
                             params: aContinuation params copy
                             target: valueCont
                             args: [graph ensureConstant: FalseDefinition].
        aContinuation removeArgs.
        aContinuation replaceUsesWith: headCont.
        aContinuation target: INVALID_TARGET.
        aContinuation removeParams.
        worklist push: headCont.
        worklist push: valueCont.
        worklist push: bodyCont.
        worklist push: exitCont!
end



class ClassDefinition { name hostClass ownClassDefinition methodDictionary }
    is Object
    is CpsValue

    -- ClassDefinition itself is used as the ClassDefinition for Class.
    -- Clever, yes? Horrible, maybe!
    direct method name
        "Class"!


    direct method classDefinition
        self!


    direct method name: name
        self
            name: name
            hostClass: False
            methods: []!


    direct method name: name methods: methods
        self
            name: name
            hostClass: False
            methods: methods!


    direct method hostClass: hostClass methods: methods
        self
            name: hostClass name
            hostClass: hostClass
            methods: methods!


    direct method name: name hostClass: hostClass methods: methods
        let instanceMethodDictionary = Dictionary new.
        let directMethodDictionary = Dictionary new.
        let ownClassDefinition = self name: "{name} class"
                                      hostClass: hostClass classOf
                                      ownClassDefinition: ClassDefinition
                                      methodDictionary: directMethodDictionary.
        let classDefinition = self name: name
                                   hostClass: hostClass
                                   ownClassDefinition: ownClassDefinition
                                   methodDictionary: instanceMethodDictionary.
        methods do: { |each|
                      each home: classDefinition.
                      instanceMethodDictionary put: each at: each name }.

        let typecheck = BuiltinMethod home: ownClassDefinition
                                      impl: (TypecheckImpl type: classDefinition).
        directMethodDictionary
            put: typecheck
            at: typecheck name.

        classDefinition!


    method printName
        name!


    method classDefinition
        ownClassDefinition!


    method hostValue
        hostClass is False
            ifTrue: { Error raise: "No host definition for {self}" }
            ifFalse: { hostClass }!


    method findMethod: name::String
        methodDictionary at: name!


    method findMethod: name::String ifNone: block
        methodDictionary at: name ifNone: block!


    method displayString
        name!

    method toString
        name!
end


class Instance { _class::ClassDefinition
                 _datum }
    is Object
    is CpsValue

    direct method class: aClass datum: aDatum
        self _class: aClass
             _datum: aDatum!

    method classDefinition
        _class!

    method hostValue
        _datum!

    method printName
        _datum toString!

    method toString
        "#<Instance {_class} {_datum}>"!

    method displayString
        self toString!

    method == other
        (Instance includes: other)
            ifTrue: { _class is other classDefinition
                          ifTrue: { _datum == other hostValue } }!
end


define BooleanClassDefinition
    (ClassDefinition
         hostClass: Boolean
         methods: [BuiltinMethod new: (IfTrueIfFalseImpl ifTrue: True ifFalse: True),
                   BuiltinMethod new: (IfTrueIfFalseImpl ifTrue: True ifFalse: False),
                   BuiltinMethod new: (IfTrueIfFalseImpl ifTrue: False ifFalse: True)])!


define FalseDefinition
    (Instance
         class: BooleanClassDefinition
         datum: False)!


define FunctionClassDefinition
    (ClassDefinition
         name: "Function"
         hostClass: Closure
         methods: [BuiltinMethod new: WhileLoopImpl newWhileTrue,
                   BuiltinMethod new: WhileLoopImpl newWhileFalse])!


define IntegerClassDefinition
    (ClassDefinition
         hostClass: Integer
         methods: [BuiltinMethod new: IntegerPlusImpl new,
                   BuiltinMethod new: IntegerAddIntegerImpl new,
                   BuiltinMethod new: OpaqueIdentityImpl new])!


define MethodClassDefinition
    (ClassDefinition
         name: "Method"
         methods: [])!


define SelectorClassDefinition
    (ClassDefinition
         name: "Selector"
         methods: [])!


class Set { dict }
    is Object

    direct method new
        self dict: Dictionary new!


    direct method with: node
        let new = self new.
        new add: node.
        new!


    method add: node
        let old = dict at: node.
        dict put: node at: node.
        old is False!


    method remove: node
        dict remove: node!


    method collect: block
        dict keys collect: block!


    method includes: node
        ((dict at: node) is False) not!


    method singular
        dict size is 1
            ifTrue: { dict values first }!


    method size
        dict size!


    method isEmpty
        dict isEmpty!


    method isOnly: node
        node is self singular!


    method replaceUses: node1 with: node2
        dict doKeys: { |each|
                       (each is node1) not assert: "Replacement target is an immediate use".
                       each replaceUses: node1 with: node2 }!


    method do: block
        dict values do: block!

    method doSorted: block
        dict values sort do: block!
end


interface UseTracking
    method isUnused
        self uses isEmpty!


    method addUse: use
        self uses add: use!


    method removeUse: use
        self uses remove: use.
        self debugVerify: "#removeUse"!


    method replaceUsesWith: new
        self uses do: { |each| each replaceUses: self with: new }.
        self debugVerify: "#replaceUsesWith:"!


    method debugVerify: what
        DebugVerify
            ifTrue: { self verify: what }!


    required method uses
    required method replaceUses: expr1 with: expr2
end


class OpMap { list }
    is Object

    direct method new
        self list: List new!


    method kind: kind withArguments: args ifNonePut: block
        kind isFoldable
            ifTrue: { list do: { |each|
                                 each kind is kind
                                     => { (each args == args)
                                              => { return each } } } }.
        let new = block value.
        list push: new.
        new!


    method mergeDuplicates
        -- FIXME: O(N^2) with current OpMap!
        list do: { |each| self tryMerge: each }!


    method tryMerge: operation
        operation isFoldable
            ifFalse: { return False }.
        operation isUnused
            ifTrue: { return False }.
        list do: { |each| self tryMerge: operation with: each }!


    method tryMerge: op1 with: op2
        op1 is op2
            ifTrue: { return False }.
        op2 isUnused
            ifTrue: { return False }.
        op1 kind is op2 kind
            ifTrue: { op1 args == op2 args
                          ifTrue: { op2 replaceUsesWith: op1 } }!


    method reject: block
        Self list: (list reject: block)!


    method select: block
        Self list: (list select: block)!


    method do: block
        list do: block!
end


class Worklist { list dict }
    is Object

    direct method new
        self list: List new
             dict: Dictionary new!


    method push: thing
        dict at: thing
             ifNonePut: { list push: thing.
                          thing }!


    method pushAll: aList
        aList do: { |each| self push: each }!


    method pop
        let thing = list pop.
        dict remove: thing.
        thing!


    method isEmpty
        list isEmpty!
end


define DebugVerify False!


interface Node
    method < other
        self id < other id!
    required method id
end


interface Expression
    is Object
    is UseTracking
    is Node


    method propagateTypes: _
        False!


    method hasKnownClass
        False!


    method simplify
        False!


    method type
        False!


    method verify: _
        False!


    method toString
        "#<{self classOf name} {self printName}>"!


    required method printName
end


interface Childless
    method doChildren: _
        False!
end


class Constant { id::Integer
                 value::CpsValue
                 uses::Set }
    is Expression
    is Childless


    direct method id: id value: value
        self id: id
             value: value
             uses: Set new!


    method hasKnownClass
        True!


    method classDefinition
        value classDefinition!


    method printName
        value printName!


    method replaceUses: expr1 with: expr2
        Error raise: "Constant#replaceUses:with: is invalid"!


    method visitBy: visitor
        visitor visitConstant: self!


    method visitBy: visitor with: arg
        visitor visitConstant: self with: arg!
end


class CpsSelector { name }
    is Object
    is CpsValue

    method printName
        "#{name}"!

    method hostValue
        Selector intern: name!

    method classDefinition
        SelectorClassDefinition!
end


class Global { id::Integer
               name::String
               uses::Set
               definition }
    is Expression
    is Childless

    direct method id: id name: name
        self id: id
             name: name
             uses: Set new
             definition: False!


    method definition: new::ClassDefinition
        definition = new!


    method hasKnownClass
        (definition is False) not!


    method classDefinition
        definition classDefinition!


    method replaceUses: expr1 with: expr2
        Error raise: "Global#replaceUses:with: is invalid"!


    method printName
        "{name}:Global"!


    method visitBy: visitor
        visitor visitGlobal: self!
end


interface ContinuationTarget
    is Node

    method doChildren: block
        self doSuccessors: block.
        self doValues: block!
end


interface AtomicContinuationTarget
    is ContinuationTarget
end


class InvalidTarget {}
    is Object
    is ContinuationTarget
    is UseTracking

    method id
        0!

    method uses
        Set new!

    method replaceUses: _ with: _
        False!

    method printName
        "INVALID"!

    method doSuccessors: _
        False!

    method doValues: _
        False!
end


define INVALID_TARGET InvalidTarget new!


class Variable { id::Integer
                 name
                 type
                 defs::Set
                 uses::Set }
    is Expression
    is Childless
    is AtomicContinuationTarget

    direct method id: id
        self id: id
             name: False
             type: False
             defs: Set new
             uses: Set new!


    direct method id: id name: name
        self id: id
             name: name
             type: False
             defs: Set new
             uses: Set new!


    method addDef: def
        defs add: def!


    method addUse: use
        use is self
            ifFalse: { uses add: use }!


    method removeDef: def
        defs remove: def.
        (defs isEmpty and: uses isEmpty not)
            ifTrue: { Error raise: "Variable {self} lost definitions while still being used by: {self uses collect: #printName}"}!


    method replaceUses: expr1 with: expr2
        Error raise: "Variable#replaceUses:with: is invalid"!


    method type: new
        (type is new)
            ifTrue: { return False }.
        (type is False)
            ifFalse: { Error raise: "Variable already has a type: {self}. Old={type}, New={new}" }.
        type = new!


    method hasKnownClass
        ClassDefinition includes: type!


    method classDefinition
        type :: ClassDefinition!


    method printName
        name is False
            ifTrue: { "$var:{id}" }
            ifFalse: { "{name}:{id}" }!


    method visitBy: visitor
        visitor visitVariable: self!

    method visitBy: visitor with: arg
        visitor visitVariable: self with: arg!
end


interface OperationKind
    direct method isFoldable
        True!
end


class ADDI {}
    is OperationKind


    direct method name
        "addi"!


    direct method visit: operation by: visitor
        visitor visitAddi: operation!


    direct method apply: args
        Instance
            class: IntegerClassDefinition
            datum: (args first hostValue :: Integer +
                    args second hostValue :: Integer)!
end


class CLASS_OF {}
    is OperationKind

    direct method name
        "classOf"!


    direct method visit: operation by: visitor
        visitor visitClassOf: operation!
end


class FIND_METHOD {}
    is OperationKind

    direct method name
        "findMethod"!


    direct method visit: operation by: visitor
        visitor visitFindMethod: operation!

    direct method visit: operation by: visitor with: arg
        visitor visitFindMethod: operation with: arg!
end


class INVALID {}
    is OperationKind

    direct method name
        "invalid"!
end


class Operation { id::Integer
                  kind
                  args::Array
                  uses::Set }
    is Expression

    direct method id: id kind: kind args: args
        let new = self id: id
                       kind: kind
                       args: args
                       uses: Set new.
        args do: { |each| each addUse: new }.
        new!


    method isFoldable
        kind isFoldable!


    method doChildren: block
        args do: block!


    method verify: what
        (args allSatisfy: { |each| each uses includes: self })
            assert: "{self printName} should use its args: {args collect: #printName}"!


    method printName
        StringOutput
            with: { |out|
                    out
                        ; print: kind name
                        ; print: ":"
                        ; print: id
                        ; print: "(".
                    args
                        do: { |each| out print: each printName }
                        interleaving: { out print: ", " }.
                    out print: ")" }!


    method flush
        args do: { |each| each removeUse: self }.
        args = [].
        kind = INVALID!


    method replaceUses: expr1 with: expr2
        expr2 addUse: self.
        args = args replace: expr1 with: expr2.
        expr1 removeUse: self.
        self debugVerify: "Operation#replaceUses:"!


    method visitBy: visitor
        visitor visitOperation: self!


    method visitBy: visitor with: arg
        visitor visitOperation: self with: arg!
end


class Continuation { id::Integer
                     name
                     params::Array
                     target
                     args::Array
                     uses::Set }
    is Expression
    is AtomicContinuationTarget

    direct method id: id name: name params: params target: target args: args
        let new = self id: id
                       name: name
                       params: params
                       target: target
                       args: args asArray
                       uses: Set new.
        params do: { |each| each addDef: new }.
        target is False
            ifFalse: {target addUse: new }.
        args do: { |each| each addUse: new }.
        new!


    method verify: what
        (target is INVALID_TARGET)
            ifFalse: { (target uses includes: self)
                           ifFalse: { Error raise: "{self} does not use its target: {target} ({what})" } }.
        let badParams = params reject: { |each| each defs includes: self }.
        badParams isEmpty assert: "Continuation should define its params".
        let badArgs = args reject: { |each| each uses includes: self }.
        badArgs isEmpty assert: "Continuation should use its args".
        self!


    method renameIfSingleUse: new
        uses size is 1
            => { name = new }.
        self!


    method name: new
        name = new!


    method hasKnownClass
        True!


    method classDefinition
        FunctionClassDefinition!


    method doSuccessors: block
        -- Log println: "   {self printName} target: {target printName}".
        (AtomicContinuationTarget includes: target)
            ifTrue: { block value: target }
            ifFalse: { target doSuccessors: block }!


    method doValues: block
        (AtomicContinuationTarget includes: target)
            ifFalse: { target doValues: block }.
        args do: block!


    method propagateTypes: types
        params with: types
               do: { |param type| param type: type }!


    method propagateTargetType
        (Constant includes: target)
            => { let value = target value .
                 (MethodDefinition includes: value)
                     => { args last propagateTypes: [value returnType] } }!


    method simplify
        -- Log println: "\nSIMPLIFY: {self printName}".
        -- Log println: "   uniqueTarget: {self hasUniqueTarget}".
        -- Log println: "   target: {target classOf name}".
        -- (UseTracking includes: target)
        --     => { Log println: "   uses: {target uses collect: #printName}" }.
        { self hasUniqueTarget }
            whileTrue: { self inlineUniqueTarget }.
        self!


    method hasUniqueTarget
        (Continuation includes: target)
            ifTrue: { target uses isOnly: self }!


    method inlineUniqueTarget
        self args
            with: target params
            do: { |arg param|
                  param replaceUsesWith: arg }.
        self replaceArgsFrom: target.
        target unlink.
        self debugVerify: "Continuation#inlineUniqueTarget"!


    method replaceUses: expr1 with: expr2
        expr2 addUse: self.
        target is expr1
            ifTrue: { target = expr2 }.
        args replace: expr1 with: expr2.
        expr1 removeUse: self.
        self debugVerify: "Continuation#replaceUses:with:"!



    method replaceArgsFrom: other::Continuation
        -- This is more convenient than #args:, since
        -- we usually want to copy the array!
        args do: { |each| each removeUse: self }.
        args = other args copy.
        args do: { |each| each addUse: self }.
        self debugVerify: "Continuation#replaceArgsFrom:"!


    method removeParams
        params do: { |each| each removeDef: self }.
        params = [].
        self debugVerify: "Continuation#removeParams"!


    method removeArgs
        args do: { |each| each removeUse: self }.
        args = [].
        self debugVerify: "Continuation#removeArgs"!


    method addParams: new
        new do: { |each| each addDef: self }.
        params = params append: new.
        self debugVerify: "Continuation#addParams:"!


    method addArgs: new
        new do: { |each| each addUse: self }.
        args = args append: new.
        self debugVerify: "Continuation#addArgs:"!


    method target: new
        -- No copy needed here, so #target: is the way to go.
        target removeUse: self.
        target = new.
        target addUse: self.
        self debugVerify: "Continuation#target:"!


    method unlink
        self removeArgs.
        self replaceUsesWith: target.
        self target: INVALID_TARGET.
        -- args and target may use params, so need to remove last!
        self removeParams.
        self debugVerify: "Continuation#unlink"!


    method printName
        name is False
            ifTrue: { "$cont:{id}" }
            ifFalse: { "{name}:{id}" }!


    method toString
        "#<Continuation {self printName} -> {target printName}>"!


    method visitBy: visitor
        visitor visitContinuation: self!

    method visitBy: visitor with: arg
        visitor visitContinuation: self with: arg!
end


class Application { id::Integer
                    target::AtomicContinuationTarget
                    function
                    uses::Set }
    is Object
    is ContinuationTarget
    is UseTracking

    direct method id: id target: target function: function
        let new = self id: id
                       target: target
                       function: function
                       uses: Set new.
        target addUse: new.
        function addUse: new.
        new!


    method doDeps: block
        block value: target.
        block value: function!


    method doValues: block
        block value: function!


    method replaceUses: node1 with: node2
        node1 removeUse: self.
        target is node1
            => { target = node2 }.
        function is node1
            => { function = node2 }.
        node2 addUse: self!


    method printName
        "apply:{id}({target printName}, {function printName})"!


    method toString
        self printName!


    method visitBy: visitor
        visitor visitApplication: self!

    method visitBy: visitor with: arg
        visitor visitApplication: self with: arg!

    method doSuccessors: block
        block value: target!
end


class Select { id::Integer
               cond::Variable
               then::AtomicContinuationTarget
               else::AtomicContinuationTarget
               uses::Set }
    is Object
    is ContinuationTarget
    is UseTracking

    direct method id: id cond: cond then: then else: else
        let new = self id: id
                       cond: cond
                       then: then
                       else: else
                       uses: Set new.
        cond addUse: new.
        then addUse: new.
        else addUse: new.
        new!


    method printName
        "select:{id}({cond printName}, {then printName}, {else printName})"!


    method replaceUses: node1 with: node2
        node1 removeUse: self.
        cond is node1
            => { cond = node2 }.
        then is node1
            => { then = node2 }.
        else is node1
            => { else = node2 }.
        node2 addUse: self!


    method simplify
        uses singular
            => { |use|
                 (self hasUniqueTarget: then)
                     ifTrue: { self propagateArgsFrom: use to: then }.
                 (self hasUniqueTarget: else)
                     ifTrue: { self propagateArgsFrom: use to: else }.
                 use removeArgs }!


    method hasUniqueTarget: node
        (Continuation includes: node)
            ifTrue: { node uses isOnly: self }!


    method propagateArgsFrom: cont1 to: cont2
        cont1 args
            with: cont2 params
            do: { |arg param|
                  param replaceUsesWith: arg }.
        cont2 removeParams!


    method visitBy: visitor
        visitor visitSelect: self!


    method doSuccessors: block
        block value: then.
        block value: else!


    method doValues: block
        block value: cond!
end


class PreOrder { seen block }
    direct method for: entry do: block
        (self seen: Set new block: block)
            traverse: entry!

    method traverse: cont
        (Continuation includes: cont)
            ifFalse: { return False }.
        (seen includes: cont)
            ifTrue: { return False }.
        seen add: cont.
        block value: cont.
        cont doSuccessors: { |each| self traverse: each }!
end


class PostOrder { seen block }
    direct method for: entry do: block
        (self seen: Set new
              block: block)
            traverse: entry!

    method traverse: cont
        (Continuation includes: cont)
            ifFalse: { return False }.
        (seen includes: cont)
            ifTrue: { return False }.
        seen add: cont.
        cont doSuccessors: { |each| self traverse: each }.
        block value: cont!
end


class ReversePostOrder { seen stack }
    direct method for: entry do: block
        let stack = List new.
        (self seen: Set new stack: stack)
            traverse: entry.
        stack reverse do: block!

    method traverse: cont
        (Continuation includes: cont)
            ifFalse: { return False }.
        (seen includes: cont)
            ifTrue: { return False }.
        seen add: cont.
        cont doSuccessors: { |each| self traverse: each }.
        stack push: cont!
end


class CpsGraph { entry::Continuation
                 exit::Variable
                 lastId::Integer
                 operations::OpMap
                 constants::Dictionary
                 globals::Dictionary
                 selectors::Dictionary
                 continuations::List }
    is Expression

    direct method new
        -- Entry node just binds the exit continuation. ID 1
        -- is reserved for graph itself
        let exit = Variable id: 3
                            name: "$return".
        let entry = Continuation id: 2
                                 name: "$entry"
                                 params: [exit]
                                 target: INVALID_TARGET
                                 args: [].
        let graph = self
                        entry: entry
                        exit: exit
                        lastId: 3
                        operations: OpMap new
                        constants: Dictionary new
                        globals: Dictionary new
                        selectors: Dictionary new
                        continuations: (List with: entry).
        exit addUse: exit.
        entry addUse: graph.
        graph!


    method id
        1!


    method uses
        Set new!


    method printName
        "graph:1"!


    method replaceUses: expr1 with: expr2
        expr1 removeUse: self.
        exit is expr1
            ifTrue: { exit = expr2 }.
        entry is expr1
            ifTrue: { entry = expr2 }.
        expr2 addUse: self!


    method cleanup
        operations mergeDuplicates.
        continuations do: { |each| each verify: "CpsGrapg#cleanup" }.
        let worklist = Worklist new.
        worklist pushAll: (continuations select: #isUnused).
        worklist pushAll: (operations select: #isUnused).
        { worklist isEmpty }
            whileFalse: { let expr = worklist pop.
                          -- Output debug println: "flushing: {expr printName}".
                          expr doChildren: { |each|
                                                   each removeUse: expr.
                                                   each isUnused
                                                       ifTrue: { worklist push: each }} }.
        continuations = continuations reject: #isUnused.
        operations = operations reject: #isUnused!


    method doNodes: block
        continuations do: block.
        operations do: block!


    method entry: target
        entry target: target.
        entry simplify.
        self cleanup.
        self!


    method optimize
        CpsOptimizer optimize: self.
        self cleanup.
        self!


    method continuation: name params: params target: target args: args
        let cont = Continuation id: self nextId
                                name: name
                                params: params
                                target: target
                                args: args.
        continuations push: cont.
        cont!


    method makeVariable: name
        Variable
            id: self nextId
            name: name!


    method makeTemporary
        Variable
            id: self nextId!


    method ensureConstant: value
        constants
            at: value
            ifNonePut: { Constant
                             id: self nextId
                             value: value }!


    method ensureGlobal: name
        globals
            at: name
            ifNonePut: { Global
                             id: self nextId
                             name: name }!


    method addGlobalDefinitions: definitions
        definitions
            do: { |def|
                  let global = self ensureGlobal: def name.
                  global definition: def }!


    method ensureSelector: name
        selectors
            at: name
            ifNonePut: { self ensureConstant: (CpsSelector name: name) }!



    method ensureOperation: kind args: args
        operations
            kind: kind
            withArguments: args
            ifNonePut: { Operation
                             id: self nextId
                             kind: kind
                             args: args }!

    method application: function target: continuation
        -- FIXME: hashcons
        Application
            id: self nextId
            target: continuation
            function: function!


    method select: cond then: then else: else
        -- FIXME: hashcons
        Select
            id: self nextId
            cond: cond
            then: then
            else: else!


    method classOf: recv
           self ensureOperation: CLASS_OF
                args: [recv]!


    method findMethod: name for: recv
        let selector = self ensureSelector: name.
        let classOf = self classOf: recv.
        self ensureOperation: FIND_METHOD
             args: [classOf, selector]!


    method nextId
        lastId = lastId + 1!
end


class CpsConverter { graph var next classes }

    direct method with: classes
        let classMap = Dictionary new.
        classes
            do: { |each|
                  let hostClass = each hostClass.
                  hostClass is False
                      ifFalse: { classMap put: each at: hostClass } }.
        self graph: CpsGraph new
             var: False
             next: False
             classes: classMap!


    direct method convert: syntax with: defs
        let converter = self with: defs.
        converter graph addGlobalDefinitions: defs.
        converter graph
            entry: (syntax visitBy: converter
                           with: converter graph exit).
        converter graph optimize!


    method bindVariable: var
        CpsConverter
            graph: graph
            var: var
            next: self
            classes: classes!


    method bindVariables: vars
        let converter = self.
        vars do: { |each|
                   converter = converter bindVariable: each }.
        converter!


    method findBinding: name
        var is False
            ifTrue: { return graph ensureGlobal: name }.
        var name == name
            ifTrue: { var }
            ifFalse: { self next findBinding: name }!


    method visitBlock: syntax with: cc
        let blockReturn = graph makeVariable: "$ret".
        let blockVars = syntax parameters
                            collect: { |each| graph makeVariable: each name }.
        let block = syntax body
                        visitBy: (self bindVariables: blockVars)
                        with: blockReturn.
        block name: "$block".
        block addParams: (blockVars append: [blockReturn]).
        graph continuation: "$makeClosure"
              params: []
              target: cc
              args: [block simplify]!


    method visitLet: syntax with: cc
        let var = graph makeVariable: syntax variable name.
        let body = syntax body
                       visitBy: (self bindVariable: var)
                       with: cc.
        let bind = graph continuation: "$let"
                         params: [var]
                         target: body
                         args: [].
        (syntax value visitBy: self with: bind simplify)
            simplify!


    method visitLiteral: syntax with: cc
        let value = syntax value.
        let classDef = classes
                           at: value classOf
                           ifNone: { Error raise: "No target class for {value} in: {classes}" }.
        let instance =  Instance
                           class: classDef
                           datum: value.
        let const = graph ensureConstant: instance.
        (graph continuation: "$const_ref"
              params: []
              target: cc
              args: [const])
        simplify!


    method visitReturn: syntax with: _
        syntax value visitBy: self with: graph exit!


    method visitSend: syntax with: cc
        let recv = graph makeVariable: "$recv".
        let args = syntax arguments
                       collect: { |a| graph makeVariable: "$arg" }
                       as: Array.
        let methodFunction = graph findMethod: syntax selector name
                                   for: recv.
        let next = graph continuation: "$send"
                         params: []
                         target: (graph application: methodFunction
                                        target: cc)
                         args: ([recv] append: args).
        syntax arguments reverse
            with: args reverse
            do: { |syntaxArg var|
                  let bind = graph continuation: "$bind_arg"
                                   params: [var]
                                   target: next
                                   args: [].
                  next = (syntaxArg visitBy: self with: bind)
                             simplify }.
        let recvBind = graph continuation: "$bind_recv"
                             params: [recv]
                             target: next
                             args: [].
        syntax receiver visitBy: self with: recvBind simplify!


    method visitSeq: syntax with: cc
        let then = syntax then visitBy: self with: cc.
        let discard = graph continuation: "$seq"
                            params: [graph makeVariable: "$ignore"]
                            target: then
                            args: [].
        syntax first visitBy: self with: discard simplify!


    method visitValueTypeDeclaration: syntax with: cc
        let value = graph makeVariable: "$value".
        let type = graph makeVariable: "$type".
        let typecheck = graph findMethod: "typecheck:" for: type.
        let checkCont = graph continuation: "$typecheck"
                              params: [type]
                              target: (graph application: typecheck
                                             target: cc)
                              args: [type, value].
        let typeCont = syntax type visitBy: self with: checkCont.
        let bindValue = graph continuation: "$bind"
                              params: [value]
                              target: typeCont
                              args: [].
        syntax value visitBy: self with: bindValue!


    method visitVariable: syntax with: cc
        let var = self findBinding: syntax name.
        (Continuation includes: cc)
            => { cc isUnused
                     => { cc params first replaceUsesWith: var.
                          cc removeParams.
                          return cc } }.
        graph continuation: "$var_ref"
              params: []
              target: cc
              args: [var]!
end


class CpsOptimizer { worklist graph }

    direct method optimize: graph
        let worklist = Worklist new.
        graph doNodes: { |each| worklist push: each }.
        (self worklist: worklist graph: graph)
            optimize!


    method optimize
        { worklist isEmpty }
            whileFalse: { let node = worklist pop.
                          -- Was node eliminated while it was on the worklist?
                          node isUnused
                              -- ifTrue: { Log println: "DEAD: {node}" }
                              ifFalse: { node visitBy: self } }!


    method visitContinuation: aCont
        -- Do strictly local simplifications: basically zipping up chains of
        -- of known continuations into a single one.
        aCont simplify.
        -- If target is an operation, let its optimizers kick in. In case
        -- of APPLY the continuation is the user of the arguments, but the
        -- apply is
        let target = aCont target.
        (Application includes: target)
            => { worklist push: target }!


    method visitOperation: anOperation
        anOperation kind visit: anOperation by: self!


    method visitClassOf: aClassOf
        let recv = aClassOf args first.
        (recv hasKnownClass)
            ifTrue: { let const = graph ensureConstant: recv classDefinition.
                      aClassOf uses
                          do: { |each|
                                each replaceUses: aClassOf with: const.
                                worklist push: each }.
                      aClassOf flush }!


    method visitApplication: anApply
        -- Lower constant method functions when possible.
        let func = anApply function.
        (Constant includes: func)
            ifTrue: { let value = func value.
                      (MethodDefinition includes: value)
                          => { anApply uses
                                   do: { |each::Continuation|
                                         value lowerToCps: each in: graph with: worklist } } }!


    method visitFindMethod: aFindMethod
        let classArg = aFindMethod args at: 1.
        (Constant includes: classArg)
            => { let classDef = classArg value.
                 (ClassDefinition includes: classDef)
                     => { let selectorArg = aFindMethod args at: 2.
                          (Constant includes: selectorArg)
                              => { let selector = selectorArg value.
                                   (CpsSelector includes: selector)
                                       => { let methodFunction = classDef findMethod: selector name.
                                            (methodFunction is False) not
                                                => { let constMethod = graph ensureConstant: methodFunction.
                                                     aFindMethod uses
                                                         do: { |each|
                                                               each replaceUses: aFindMethod with: constMethod.
                                                               worklist push: each } } } } } }!


    method visitSelect: aSelect
        aSelect simplify!


    method visitAddi: _
        False!


    method visitTypeInfo: _
        False!


    method visitGlobal: _
        False!


    method visitVariable: _
        False!


    method visitConstant: _
        False!
end


class CpsEvaluator { bound values parent }

    direct method new
        self bound: []
             values: []
             parent: False!


    direct method eval: cps
        -- Log println: (CpsPrinter printToString: cps).
        cps entry
            visitBy: (CpsEvaluator new)
            with: [{ |value| return value }]!


    method bind: params to: args
        CpsEvaluator
            bound: params
            values: args
            parent: self!


    method visitAll: seq
        seq collect: { |each| each visitBy: self }!


    method visitContinuation: aCont with: args
        let params = aCont params.
        params size is args size
            ifFalse: { Error raise: "Argument count mismatch, wanted: {aCont params size}, got {args size}" }.
        let eval = self bind: params
                        to: args.
        aCont target
            visitBy: eval
            with: (eval visitAll: aCont args)!


    method visitVariable: aVar with: args
        (self visitVariable: aVar)
            apply: args!


    method visitVariable: var
        let index = bound positionOf: var.
        index is False
            ifTrue: { parent is False
                          ifTrue: { Error raise: "Unbound variable: {var printName}" }.
                      parent visitVariable: var }
            ifFalse: { values at: index }!


    method visitApplication: app with: args
        app target
            visitBy: self
            with: [(app function visitBy: self with: args)]!


    method visitConstant: constant
        constant value :: CpsValue!


    method visitConstant: constant with: args
        constant value apply: args!


    method visitGlobal: aGlobal
        aGlobal definition!


    method visitOperation: anOp
        anOp kind visit: anOp by: self!


    method visitOperation: anOp with: args
        (anOp kind visit: anOp by: self)
            apply: args!


    method visitClassOf: classOf
        let arg = classOf args first visitBy: self.
        arg classDefinition!


    method visitFindMethod: findMethod
        let theClass :: ClassDefinition
            = (findMethod args first) visitBy: self.
        let theSelector :: CpsSelector
            = (findMethod args second) visitBy: self.
        -- FIXME: CpsSelectors are interned in the CpsGraph,
        -- but since ClassDefinitions are created _outside_ it,
        -- they have their method dictionaries keyd by strings.
        --
        -- The fix is to have a table of pre-interned selectors
        -- for built-in methods, and use that when interning
        -- into CpsGraph.
        theClass findMethod: theSelector name
                 ifNone: { Error raise: "Method missing: {theClass name}#{theSelector name}\nAvailable:\n{theClass methodDictionary}" }!
end


class CpsPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output newline.
        visitor visit: graph entry!


    method visit: other
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitContinuation: aCont
        output
            ; print: aCont printName
            ; print: "(".
        aCont params
            do: { |each| output print: each printName }
            interleaving: { output print: ", " }.
        output println: "):".
        output
            ; print: "    "
            ; print: aCont target printName
            ; print: "(".
        aCont args
            do: { |arg| output print: arg printName }
            interleaving: { output print: ", " }.
        output println: ")".
        aCont args do: { |each| self visit: each }.
        self visit: aCont target!


    method visitConstant: _
        False!


    method visitVariable: _
        False!


    method visitGlobal: _
        False!


    method visitApplication: anApplication
        self visit: anApplication target!


    method visitSelect: aSelect
        self visit: aSelect cond.
        self visit: aSelect then.
        self visit: aSelect else!


    method visitOperation: anOp
        anOp args do: { |each| self visit: each }!
end

class CpsGraphwizOrderPrinter { output }
    direct method printToString: graph in: order
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph in: order to: output
        output writeString: "\nstrict digraph \{\n".
        output writeString: "    \"{graph entry printName}\" [color=red]\n".
        let prev = False.
        order for: graph entry
              do: { |cont|
                    output writeString: "   \"".
                    output writeString: cont printName.
                    output writeString: "\" [shape=box]\n".
                    prev => {
                        output writeString: "    \"".
                        output writeString: prev printName.
                        output writeString: "\" -> \"".
                        output writeString: cont printName.
                        output writeString: "\"\n" }.
                    prev = cont }.
        output writeString: "\}\n"!
end


class CpsGraphwizPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output writeString: "\nstrict digraph \{\n".
        output writeString: "    \"{graph entry printName}\" [color=red]\n".
        visitor visit: graph entry.
        output writeString: "\}\n"!


    method visit: other
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitAll: nodes
        nodes do: { |each| self visit: each }!


    method visitContinuation: aCont
        output writeString: "    \"{aCont printName}\" [shape=box]\n".
        aCont params
            do: { |each|
                  each uses isEmpty
                      ifFalse: { output writeString: "    \"".
                                 output writeString: aCont printName.
                                 output writeString: "\" -> \"".
                                 output writeString: each printName.
                                 output writeString: "\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]\n" } }.
        aCont doValues: { |each|
                          output writeString: "    \"".
                          output writeString: each printName.
                          output writeString: "\" -> \"".
                          output writeString: aCont printName.
                          output writeString: "\" [style=dotted]\n" }.
        aCont doSuccessors: { |each|
                              output writeString: "    \"".
                              output writeString: aCont printName.
                              output writeString: "\" -> \"".
                              output writeString: each printName.
                              output writeString: "\" [arrowhead=vee]\n" }.
        aCont doChildren: { |each|
                            self visit: each }.
        self visitAll: aCont args!


    method visitVariable: aVar
        False!


    method visitConstant: _
        False!


    method visitGlobal: _
        False!


    method visitApplication: _
        False!


    method visitOperation: anOperation
        anOperation uses
            doSorted: { |each| each visitBy: self }.
        anOperation args
            do: { |each|
                  output writeString: "    \"".
                  output writeString: each printName.
                  output writeString: "\" -> \"".
                  output writeString: anOperation printName.
                  output writeString: "\" [style=dotted]\n" }.
        self visitAll: anOperation args!
end


class TestCPS { assert system }
    is TestSuite

    direct method assert: assert
        self assert: assert system: False!

    method system: new
        system = new!

    method convert: source
        self convert: source with: []!


    method convert: source with: defs
        let syntax = Parser parseExpression: source.
        CpsConverter convert: syntax with: defs!


    method test_convert_addition_of_integers_optimizes_to_operation_addi
        let cps = self convert: "let a = X a :: Integer. let b = X b :: Integer. a + b"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:45($bind:40, findMethod:44(classOf:27(X:Global), #a))(X:Global)
$bind:40($value:34):
    apply:38($let:33, Integer class#typecheck:)(Integer:Global, $value:34)
$let:33(a:5):
    apply:29($bind:24, findMethod:28(classOf:27(X:Global), #b))(X:Global)
$bind:24($value:17):
    apply:22($let:16, Integer class#typecheck:)(Integer:Global, $value:17)
$let:16(b:6):
    $return:3(addi:57(a:5, b:6))
"!

    method test_convert_arity_0_block
        let cps = self convert: "\{ 421 }"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3($block:7)
$block:7($ret:5):
    $ret:5(421)
"!


    method test_convert_arity_3_block
        let cps = self convert: "\{ |a b c| a + b + c }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3($block:24)
$block:24(a:5, b:6, c:7, $ret:4):
    apply:21($bind_recv:16, findMethod:20(classOf:19(a:5), #+))(a:5, b:6)
$bind_recv:16($recv:8):
    apply:13($ret:4, findMethod:12(classOf:11($recv:8), #+))($recv:8, c:7)
"!


    method test_convert_boolean_ifFalse
        let cps = self convert: "X :: Boolean ifFalse: \{ 1 }"
                       with: [BooleanClassDefinition,
                              IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:24($bind_recv:18, Boolean class#typecheck:)(Boolean:Global, X:Global)
$bind_recv:18($recv:6):
    select:35($recv:6, $ifTrue:34, $ifFalse:16)()
$ifTrue:34():
    $return:3(False)
$ifFalse:16():
    $return:3(1)
"!


    method test_convert_boolean_ifTrue
        let cps = self convert: "X :: Boolean ifTrue: \{ 1 }"
                       with: [BooleanClassDefinition,
                              IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:24($bind_recv:18, Boolean class#typecheck:)(Boolean:Global, X:Global)
$bind_recv:18($recv:6):
    select:35($recv:6, $ifTrue:16, $ifFalse:34)()
$ifTrue:16():
    $return:3(1)
$ifFalse:34():
    $return:3(False)
"!


    method test_convert_boolean_ifTrueIfFalse
        let cps = self convert: "X :: Boolean ifTrue: \{ 1 } ifFalse: \{ 2 }"
                       with: [BooleanClassDefinition,
                              IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:30($bind_recv:24, Boolean class#typecheck:)(Boolean:Global, X:Global)
$bind_recv:24($recv:6):
    select:38($recv:6, $ifTrue:22, $ifFalse:17)()
$ifTrue:22():
    $return:3(1)
$ifFalse:17():
    $return:3(2)
"!


    method test_convert_closure_whileFalse
        let cps = self convert: "\{ X maybe\} whileFalse: \{ Y something \}".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$loopHead:43($return:3):
    $loopTest:36(False)
$loopTest:36($ignore:35):
    apply:28($whileFalse:42, findMethod:27(classOf:26(X:Global), #maybe))(X:Global)
$whileFalse:42($cond:40):
    select:41($cond:40, $loopExit:39, $loopBody:37)()
$loopExit:39():
    $return:3(False)
$loopBody:37():
    apply:17($loopTest:36, findMethod:16(classOf:15(Y:Global), #something))(Y:Global)
"!


    method test_convert_closure_whileTrue
        let cps = self convert: "\{ X maybe\} whileTrue: \{ X something \}".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$loopHead:42($return:3):
    $loopTest:35(False)
$loopTest:35($ignore:34):
    apply:28($whileTrue:41, findMethod:27(classOf:15(X:Global), #maybe))(X:Global)
$whileTrue:41($cond:39):
    select:40($cond:39, $loopBody:36, $loopExit:38)()
$loopBody:36():
    apply:17($loopTest:35, findMethod:16(classOf:15(X:Global), #something))(X:Global)
$loopExit:38():
    $return:3(False)
"!


    method test_preOrder_whileTrue
        let cps = self convert: "\{ X maybe\} whileTrue: \{ X something \}".
        let order = List new.
        PreOrder for: cps entry
                 do: { |each| order push: each id }.
        assert that: { order asArray }
               equals: [42, 35, 41, 36, 38]!


    method test_postOrder_whileTrue
        let cps = self convert: "\{ X maybe\} whileTrue: \{ X something \}".
        let order = List new.
        PostOrder for: cps entry
                  do: { |each| order push: each id }.
        assert that: { order asArray }
               equals: [36, 38, 41, 35, 42]!


    method test_reversePostOrder_whileTrue
        let cps = self convert: "\{ X maybe\} whileTrue: \{ X something \}".
        let order = List new.
        ReversePostOrder for: cps entry
                         do: { |each| order push: each id }.
        assert that: { order asArray }
               equals: [42, 35, 41, 38, 36]!


    method test_graphwiz_closure_whileTrue
        let cps = self convert: "\{ X maybe\} whileTrue: \{ X something \}".
        (system currentDirectory / "closure_whileTrue.dot")
            truncateExisting forWrite
                createOrOpen: { |dot|
                                CpsGraphwizPrinter
                                    print: cps
                                    to: dot }.
        assert that: { CpsGraphwizPrinter printToString: cps }
               equals: "
strict digraph \{
    \"$loopHead:42\" [color=red]
    \"$loopHead:42\" [shape=box]
    \"$loopHead:42\" -> \"$return:3\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]
    \"False\" -> \"$loopHead:42\" [style=dotted]
    \"$loopHead:42\" -> \"$loopTest:35\" [arrowhead=vee]
    \"$loopTest:35\" [shape=box]
    \"findMethod:27(classOf:15(X:Global), #maybe)\" -> \"$loopTest:35\" [style=dotted]
    \"X:Global\" -> \"$loopTest:35\" [style=dotted]
    \"$loopTest:35\" -> \"$whileTrue:41\" [arrowhead=vee]
    \"$whileTrue:41\" [shape=box]
    \"$whileTrue:41\" -> \"$cond:39\" [dir=both, arrowhead=none, arrowtail=box, style=dotted]
    \"$cond:39\" -> \"$whileTrue:41\" [style=dotted]
    \"$whileTrue:41\" -> \"$loopBody:36\" [arrowhead=vee]
    \"$whileTrue:41\" -> \"$loopExit:38\" [arrowhead=vee]
    \"$loopBody:36\" [shape=box]
    \"findMethod:16(classOf:15(X:Global), #something)\" -> \"$loopBody:36\" [style=dotted]
    \"X:Global\" -> \"$loopBody:36\" [style=dotted]
    \"$loopBody:36\" -> \"$loopTest:35\" [arrowhead=vee]
    \"classOf:15(X:Global)\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"#something\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"classOf:15(X:Global)\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"#something\" -> \"findMethod:16(classOf:15(X:Global), #something)\" [style=dotted]
    \"classOf:15(X:Global)\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
    \"#maybe\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
    \"X:Global\" -> \"classOf:15(X:Global)\" [style=dotted]
    \"$loopExit:38\" [shape=box]
    \"False\" -> \"$loopExit:38\" [style=dotted]
    \"$loopExit:38\" -> \"$return:3\" [arrowhead=vee]
    \"classOf:15(X:Global)\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
    \"#maybe\" -> \"findMethod:27(classOf:15(X:Global), #maybe)\" [style=dotted]
}
"!


    method test_convert_constant_integer
        let cps = self convert: "123"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(123)
"!


    method test_convert_global
        let cps = self convert: "X".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(X:Global)
"!


    method test_convert_let
        let cps = self convert: "let x = 87. x"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(87)
"!


    method test_convert_return
        let cps = self convert: "return 421. X boom"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    $return:3(421)
"!


    method test_convert_seq
        let cps = self convert: "X some: 12 message: 97. Y + Z"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:24($seq:17, findMethod:23(classOf:22(X:Global), #some:message:))(X:Global, 12, 97)
$seq:17($ignore:16):
    apply:10($return:3, findMethod:9(classOf:8(Y:Global), #+))(Y:Global, Z:Global)
"!


    method test_convert_typecheck
        let cps = self convert: "X :: Integer".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:9($return:3, findMethod:8(classOf:7(Integer:Global), #typecheck:))(Integer:Global, X:Global)
"!


    method test_convert_typecheck_gives_type
        let cps = self convert: "X::Integer + Y"
                       with: [(ClassDefinition
                                   name: "Integer"
                                   methods: [(UserMethod name: "+")])].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:20($bind_recv:14, Integer class#typecheck:)(Integer:Global, X:Global)
$bind_recv:14($recv:5):
    apply:10($return:3, Integer#+)($recv:5, Y:Global)
"!


    method test_convert_typecheck_redundancy
        let cps = self convert: "X :: Integer :: Integer"
                       with: [(ClassDefinition name: "Integer")].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:17($bind:12, Integer class#typecheck:)(Integer:Global, X:Global)
$bind:12($value:5):
    $return:3($value:5)
"!

    method test_convert_constant_add
        let cps = self convert: "123 + X::Integer"
                       with: [IntegerClassDefinition].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:2($return:3):
    apply:18($bind_arg:12, Integer class#typecheck:)(Integer:Global, X:Global)
$bind_arg:12($arg:6):
    $return:3(addi:34(123, $arg:6))
"!

    method test_eval_typecheck_literal
        let cps = self convert: "123 :: Integer"
                       with: [IntegerClassDefinition].
        assert that: { (CpsEvaluator eval: cps) hostValue }
               equals: 123!

    method test_eval_send_message
        let cps = self convert: "123 opaqueIdentity + 321"
                       with: [IntegerClassDefinition].
        assert that: { (CpsEvaluator eval: cps) hostValue }
               equals: 444!
end

class Main {}
    direct method run: command in: system
        TestCPS runTests: (Assert reportingTo: system output)
                in: system!
end
