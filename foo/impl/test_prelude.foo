import .test_self_hosting.TestSelfHosting

-- prelude tests numbered so that they sort in order
-- of complexity, roughly.

class TestPrelude01 { system ok onFailure }
    is TestSelfHosting

    method testPrelude_1_Any
        let lang = system files / "foo/lang".
        self without: ["Any"]
             modules: { "lang" -> lang } asFileModules
             load: "import lang.any
                    class Test \{}
                       direct method test
                          any.Any includes: 42!
                    end"
             eval: "Test test"
             expect: True!
end

class TestPrelude02 { system ok onFailure }
    is TestSelfHosting

    method testPrelude_2_Object
        let lang = system files / "foo/lang".
        self without: ["Object", "StringOutput"]
             modules: { "lang" -> lang } asFileModules
             load: "import lang.object
                    class X \{ y }
                        is object.Object
                        method displayOn: out
                           out print: \"X=\".
                           out print: y!
                    end
                    class Test \{}
                       direct method test
                           (X y: 42) displayString!
                    end"
             eval: "Test test"
             expect: "X=42"!
end

class TestPrelude03 { system ok onFailure }
    is TestSelfHosting

    method testPrelude_3_Character
        let lang = system files / "foo/lang".
        self without: ["Character", "Object", "StringOutput"]
             modules: { "lang" -> lang } asFileModules
             load: "import lang.character
                    class X \{ c::character.Character }
                    end
                    class Test \{}
                       direct method testError
                           \{ X c: 42 }
                              on: TypeError
                              do: \{ |e| return #gotcha }!
                       direct method testOk
                           -- Need to take some care to avoid constructing
                           -- a host character!
                           let aCode = \"a\" character code.
                           (X c: (character.Character code: aCode)) c code == 0x61!
                    end"
             eval: "[Test testError, Test testOk]"
             expect: [#gotcha, True]!
end

class TestPrelude04 { system ok onFailure }
    is TestSelfHosting

    method testPrelude_4_Iterable
        let lang = system files / "foo/lang".
        self without: ["Iterable", "Object", "StringOutput"]
             modules: { "lang" -> lang } asFileModules
             load: "import lang.iterable
                    class MyIterable \{}
                        is iterable.Iterable
                        method iterator
                            [1, -2, 3] iterator!
                    end"
             eval: "MyIterable new collect: #abs as: List"
             expect: [1,2,3] asList!
end

class TestPrelude05 { system ok onFailure }
    is TestSelfHosting

    method testPrelude_5_Interval
        let lang = system files / "foo/lang".
        self without: ["Interval", "Object", "StringOutput"]
             modules: { "lang" -> lang } asFileModules
             load: "import lang.interval
                    define ThousandBy10
                        interval.Interval from: 1 to: 1000 by: 10!"
             eval: "ThousandBy10 size"
             expect: 100!
end

class TestPrelude06 { system ok onFailure }
    is TestSelfHosting

    method testPrelude_6_Collection
        let lang = system files / "foo/lang".
        self without: ["Collection", "Iterable", "Object", "StringOutput"]
             modules: { "lang" -> lang } asFileModules
             load: "import lang.collection
                    class MyCollection \{ data }
                        is collection.Collection
                        direct method new
                            self data: List new!
                        method iterator
                            data iterator!
                        method add: elt
                            data add: elt.
                            self!
                        method size
                            data size!
                        method clear
                            data clear.
                            self!
                    end"
             eval: "let coll = MyCollection new.
                    coll addAll: [1,2,3].
                    let res = coll data copy.
                    coll clear.
                    [res, coll isEmpty]"
             expect: [[1,2,3] asList, True]!
end

class TestPrelude07 { system ok onFailure }
    is TestSelfHosting

    method testPrelude_7_Block
        let lang = system files / "foo/lang".
        self without: ["Block", "Object", "StringOutput"]
             modules: { "lang" -> lang } asFileModules
             load: "import lang.block
                    class MyBlock \{ data }
                        is block.Block
                        method apply: arguments
                            data with: arguments collect: \{ |a b| a + b } as: List!
                        method finally: cleanup
                            \{ self value }
                                finally: cleanup!
                        method arity
                            data size!
                        method loop
                            panic \"nope\"!
                    end"
             eval: "let b = MyBlock data: [1,10,100].
                    b value: 1 value: 2 value: 3"
             expect: [2,12,103] asList!
end

class TestPrelude08 { system ok onFailure }
    is TestSelfHosting

    method testPrelude_8_Exception
        let lang = system files / "foo/lang".
        self without: ["Error", "TypeError", "DoesNotUnderstand", "Object", "StringOutput"]
             modules: { "lang" -> lang } asFileModules
             load: "import lang.exception
                    class MyError \{}
                        is exception.Error
                        method _description
                           \"Oops\"!
                    end"
             eval: "(\{ MyError new raise } catch: MyError) value description"
             expect: "Oops"!
end

class TestPrelude09 { system ok onFailure }
    is TestSelfHosting

    method testPrelude_9_Boolean
        let lang = system files / "foo/lang".
        -- FIXME: This warns about False being undefined because StringOutput
        -- uses it, and evaluator has no knowledge about due to the without.
        self without: ["Boolean", "True", "False", "Object", "StringOutput"]
             modules: { "lang" -> lang } asFileModules
             load: "import lang.boolean0
                    class Test \{}
                        direct method test
                           boolean0.True
                               ifTrue: \{ 42 }!
                    end"
             eval: "Test test"
             expect: 42!
end

class TestPrelude10 { system ok onFailure }
    is TestSelfHosting

    method testPrelude_10_Ordered
        let lang = system files / "foo/lang".
        self without: ["Ordered", "Iterable", "Iterator", "Object", "StringOutput"]
             modules: { "lang" -> lang } asFileModules
             load: "import lang.ordered

                    class Triple \{ a b c }
                        is ordered.Ordered
                        method size
                           3!
                        method at: index
                           index is 1
                              ifTrue: \{ return a }.
                           index is 2
                              ifTrue: \{ return b }.
                           index is 3
                              ifTrue: \{ return c }.
                           panic \"oops\"!
                    end"
             eval: "(Triple a: 1 b: 2 c: 3) sum"
             expect: 6!
end

class Main {}
    direct method run: cmd in: system
        let tests = {
            "--prelude-01" -> TestPrelude01,
            "--prelude-02" -> TestPrelude02,
            "--prelude-03" -> TestPrelude03,
            "--prelude-04" -> TestPrelude04,
            "--prelude-05" -> TestPrelude05,
            "--prelude-06" -> TestPrelude06,
            "--prelude-07" -> TestPrelude07,
            "--prelude-08" -> TestPrelude08,
            "--prelude-09" -> TestPrelude09,
            "--prelude-10" -> TestPrelude10,
        }.
        let all = tests keys sort.
        cmd == []
            ifTrue: { cmd = all }.
        cmd == ["--fork-all"]
            ifTrue: { all
                          do: { |test|
                                let next = "cargo run -- foo/impl/test_prelude.foo --use=foo/lib -- {test}".
                                system output println: "TEST: {next}".
                                let command = system command: next.
                                system output println: "--test stdout--".
                                system output println: command stdout.
                                system output println: "--test stderr--".
                                system output println: command stderr.
                                command ok
                                    ifFalse: { system exit: 1 } }.
                      system exit }.
        cmd do: { |name|
                  let result = (tests at: name) runIn: system.
                  result ok
                      ifFalse: { system output println: "Test {name} failed!".
                                 system exit: 1 } }!
end
