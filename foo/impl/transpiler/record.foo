define InstanceMethods
    { #hash
          -> { signature: [], vars: 0,
               body: "struct FooArray* instance = PTR(FooArray, receiver.datum);
                      int64_t hash = 0;
                      for (size_t i = 0; i < instance->size; i++) \{
                           struct Foo slot_hash = foo_class_typecheck(sender, &FooClass_Integer, foo_send(sender, &FOO_hash, instance->data[i], 0));
                           hash = foo_hashmix(hash, slot_hash.datum.int64);
                      }
                      return FOO_INTEGER(MASK_SIGN(hash));" },

         }!

define DirectMethods
    { #keysIn:
          -> { signature: [Record], vars: 0,
               body: "const struct FooClass* class = ctx->frame[0].class;
                      const struct FooMethodTable* table = class->method_table;
                      // Methods originating in the instance's class are reader methods
                      // and correspond to slots, so we can identify them -- except for
                      // #classOf.
                      size_t n = 0;
                      for (size_t i = 0; i < table->size; i++)
                      \{
                          const struct FooSelector* selector = table->methods[i].selector;
                          if (class == table->methods[i].home && selector != &FOO_classOf)
                          \{
                              n++;
                          }
                      }
                      struct FooArray* keys = FooArray_alloc(ctx, n);
                      size_t j = 0;
                      for (size_t i = 0; i < table->size; i++)
                      \{
                          const struct FooSelector* selector = table->methods[i].selector;
                          if (class == table->methods[i].home && selector != &FOO_classOf)
                          \{
                              keys->data[j++] = (struct Foo)\{ .class = &FooClass_Selector,
                                                               .datum = \{ .ptr = (void*)selector }};
                          }
                      }
                      assert(j == n);
                      return (struct Foo)\{ .class = &FooClass_Array,
                                            .datum = \{ .ptr = keys } };" }
}!
