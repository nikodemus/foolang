define InstanceMethods
{
     #name
     -> { signature: [], vars: 0,
          body: "struct FooBytes* name = PTR(FooClass, ctx->receiver.datum)->name;
                 return (struct Foo)\{ .class = &FooClass_String, .datum = \{ .ptr = name } };"
          },

     #classOf
     -> { signature: [], vars: 0,
          body: "struct FooClass* classOf = ctx->receiver.class;
                 return (struct Foo)\{ .class = classOf->metaclass, .datum = \{ .ptr = classOf } };"
          },

     #selectorsOf:do:
     -> { signature: [Any, Any], vars: 0,
          body: "const struct FooClass* class = ctx->frame[0].class;
                 const struct Foo block = ctx->frame[1];
                 const struct FooSelector* seen[1024];
                 size_t n = 0;
                 // First go through own methods, registering them in seen.
                 for (size_t i = 0; i < class->size; i++) \{
                     struct FooSelector* selector = class->methods[i].selector;

                     // Skip private selectors.
                     if (selector->name->data[0] == '_') continue;

                     if (n < sizeof(seen)) \{
                         seen[n++] = selector;
                         foo_send(ctx, &FOO_value_, block, 1,
                                  (struct Foo)\{ .class = &FooClass_Selector,
                                                 .datum = \{ .ptr = selector \}\});
                     \} else \{
                         foo_panicf(ctx, \"Too many selectors in class: %s\", class->name->data);
                     \}
                 \}

                 // Then go through the inherited interfaces
                 const struct FooClassList* interfaces = class->inherited;
                 for (size_t i = 0; i < interfaces->size; i++) \{
                     const struct FooClass* interface = interfaces->data[i];
                     for (size_t j = 0; j < interface->size; j++) \{
                         struct FooSelector* selector = interface->methods[j].selector;

                         // Skip private selectors.
                         if (selector->name->data[0] == '_') continue;

                         // Check if we've seen this one already
                         bool new = true;
                         for (size_t k = 0; k < n; k++) \{
                             if (seen[k] == selector) \{
                                 new = false;
                                 break;
                             \}
                         \}
                         if (new) \{
                             if (n < sizeof(seen)) \{
                                 seen[n++] = selector;
                                 foo_send(ctx, &FOO_value_, block, 1,
                                          (struct Foo)\{ .class = &FooClass_Selector,
                                                         .datum = \{ .ptr = selector \}\});
                             \} else \{
                                 foo_panicf(ctx, \"Too many selectors in class: %s\", class->name->data);
                             \}
                         \}
                     \}
                 \}

                 return ctx->frame[0];" },

     #hash
     -> { signature: [], vars: 0,
          body: "return FOO_INTEGER(foo_identity_hash(receiver.datum.ptr));" },

     #subclass:interfaces:methods:
     -> { signature: [String, Array, Array], vars: 1,
          body: "struct FooArray* methods = PTR(FooArray, ctx->frame[2].datum);
                 struct FooClass* newclass
                   = foo_alloc(ctx, sizeof(struct FooClass)
                               + methods->size * sizeof(struct FooMethod));
                 struct FooClass* super = PTR(FooClass, ctx->receiver.datum);
                 struct FooArray* interfaces = PTR(FooArray, ctx->frame[1].datum);
                 struct FooClassList* inherited = FooClassList_alloc(ctx, interfaces->size + 1);
                 inherited->data[0] = super;
                 for (size_t i = 0; i < interfaces->size; i++) \{
                     struct Foo obj = interfaces->data[i];
                     foo_class_typecheck(ctx, &FooClass_Class, obj);
                     inherited->data[i+1] = obj.datum.ptr;
                 \}

                 if (!super->layout) \{
                     assert(super->name);
                     assert(super->name->data);
                     foo_panicf(ctx, \"Superclass has no layout: %s\", super->name->data);
                 \}

                 newclass->header.allocation = HEAP;
                 newclass->name = PTR(FooBytes, ctx->frame[0].datum);
                 newclass->metaclass = super->metaclass;
                 newclass->inherited = inherited;
                 newclass->layout = super->layout;
                 newclass->mark = super->mark;
                 newclass->size = 0;

                 /* Make the new class visible to GC. */
                 ctx->frame[3] = (struct Foo)
                   \{ .class = newclass->metaclass,
                      .datum = \{ .ptr = newclass } };

                 for (size_t i = 0; i < methods->size; i++) \{
                   struct Foo method_object = methods->data[i];
                   struct Foo method_selector = foo_send(ctx, &FOO_selector, method_object, 0);
                   foo_class_typecheck(ctx, &FooClass_Selector, method_selector);

                   struct Foo selector_arity = foo_send(ctx, &FOO_arity, method_selector, 0);
                   foo_class_typecheck(ctx, &FooClass_Integer, selector_arity);

                   struct FooMethod* m = &newclass->methods[i];
                   m->home = newclass;
                   m->selector = PTR(FooSelector, method_selector.datum);
                   m->function = foo_invoke_on;
                   m->object = method_object;

                   /* Update the size once the method is in place,
                      so GC sees it. */
                   newclass->size++;
                 }
                 return ctx->frame[3];"
        },

     #new:layout:interfaces:methods:
     -> { signature: [String, Layout, Array, Array], vars: 1,
          body: "struct FooArray* methods = PTR(FooArray, ctx->frame[3].datum);
                 struct FooClass* newclass
                   = foo_alloc(ctx, sizeof(struct FooClass)
                               + methods->size * sizeof(struct FooMethod));

                 struct FooArray* interfaces = PTR(FooArray, ctx->frame[2].datum);
                 struct FooClassList* inherited = FooClassList_alloc(ctx, interfaces->size);
                 for (size_t i = 0; i < interfaces->size; i++) \{
                     struct Foo obj = interfaces->data[i];
                     foo_class_typecheck(ctx, &FooClass_Class, obj);
                     inherited->data[i] = obj.datum.ptr;
                 }

                 newclass->header.allocation = HEAP;
                 newclass->name = PTR(FooBytes, ctx->frame[0].datum);
                 newclass->metaclass = PTR(FooClass, ctx->receiver.datum);
                 newclass->inherited = inherited;
                 newclass->layout = PTR(FooLayout, ctx->frame[1].datum);
                 newclass->mark = newclass->layout->mark;
                 newclass->size = 0;

                 /* Make the new class visible to GC. */
                 ctx->frame[4] = (struct Foo)
                   \{ .class = newclass->metaclass,
                      .datum = \{ .ptr = newclass } };

                 for (size_t i = 0; i < methods->size; i++) \{
                   struct Foo method_object = methods->data[i];
                   struct Foo method_selector = foo_send(ctx, &FOO_selector, method_object, 0);
                   foo_class_typecheck(ctx, &FooClass_Selector, method_selector);

                   struct Foo selector_arity = foo_send(ctx, &FOO_arity, method_selector, 0);
                   foo_class_typecheck(ctx, &FooClass_Integer, selector_arity);

                   struct FooMethod* m = &newclass->methods[i];
                   m->home = newclass;
                   m->selector = PTR(FooSelector, method_selector.datum);
                   m->function = foo_invoke_on;
                   m->object = method_object;

                   /* Update the size once the method is in place,
                      so GC sees it. */
                   newclass->size++;
                 }
                 return ctx->frame[4];"
          }
}!
