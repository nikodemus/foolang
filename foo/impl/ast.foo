import .undefinedPolicy.UndefinedPolicy
import .utils.Debug

class Process {}
    is Object
end

class InterpreterContext {
        sender
        receiver
        frame::Array
        returnBlock
    }
    is Object

    direct method new: size
        self new: size
             returnBlock: { |value|
                            Error raise: "Invalid return: {value}" }!

    direct method new: size returnBlock: returnBlock
        self sender: False
             receiver: False
             frame: (Array new: size value: "<unbound>")
             returnBlock: returnBlock!

    method invalidate
        returnBlock = { |value|
                        Error raise: "Cannot return from dead context: {value}" }!

    method slot: index
        -- FIXME: Replace this with Primitive readSlot: index of: receiver.
        -- which breaks encapsulation. Dammit, so it needs to be:
        --
        --    system primitives readSlot: index of: receiver.
        --
        -- so primitives need to be passed down here. Yuck.
        --
        -- Maybe some of the auth should be statically handled?
        -- Like:
        --
        --    import foolang allowing: Primitive
        --
        -- ?
        receiver __slot: (index - 1)!

    method at: index inFrame: frameNumber
        frameNumber > 1
            ifTrue: { sender at: index inFrame: frameNumber - 1 }
            ifFalse: { frame at: index }!

    method put: value at: index inFrame: frameNumber
        frameNumber > 1
            ifTrue: { sender put: value at: index inFrame: frameNumber - 1 }
            ifFalse: { frame put: value at: index }!
end

interface AstNode
    is Object
    method debug
        Debug println: "#<AST {self}>"!
    method evalInEnv: environment
        self
            evalWith: (InterpreterContext new: environment allocation size)
            in: Process new!
end

class AstComment { comment value source }
    is AstNode
    method evalWith: context in: process
        value evalWith: context in: process!
end

class AstUndefinedMarker {}
end

class AstGlobal { name _value }
    is AstNode

    direct method name: name
        self
            name: name
            value: AstUndefinedMarker!

    direct method name: name value: value
        self
            name: name
            _value: value!

    method isUndefined
        _value is AstUndefinedMarker!

    method value
        self isUndefined
            ifTrue: { return UndefinedPolicy resolve: self name }.
        _value!

    method value: newValue
        _value = newValue!

    method evalWith: context in: process
        self value!
end

interface AstObject
end

class AstConstantRef { value }
    is AstNode
    method evalWith: context in: process
        value!
end

class AstIs { left right }
    is AstNode
    method evalWith: context in: process
        (left evalWith: context in: process)
            is (right evalWith: context in: process)!
end

class AstSeq { first then }
    is AstNode
    method evalWith: context in: process
        first evalWith: context in: process.
        then evalWith: context in: process!
end

class AstReturn { value }
    is AstNode
    method evalWith: context in: process
        context returnBlock value: (value evalWith: context in: process)!
end

class AstSend {
        receiver
        selector
        arguments
        source
    }
    is AstNode

    method evalWith: context in: process
        let object = receiver
                         evalWith: context
                         in: process.
        let arguments = arguments
                            collect: { |arg|
                                       arg
                                           evalWith: context
                                           in: process }.
        let $context = context.
        let $process = process.
        -- Debug println: "<- {selector}".
        { selector sendTo: object with: arguments }
            on: DoesNotUnderstand
            do: { |ex|
                  -- Add the source location to the error.
                  (object is ex receiver and: selector == ex selector)
                      ifTrue: { DoesNotUnderstand
                                    raise: selector
                                    with: arguments
                                    on: object
                                    source: source }} !
end

define $DefinitionsInProgress
    False!

class DefinitionsInProgress { this next }
    direct method with: definition do: block
        let old = $DefinitionsInProgress.
        old is False
            ifFalse: { old checkCycle: definition }.
        let $DefinitionsInProgress = DefinitionsInProgress this: definition next: old.
        block value!

    method checkCycle: definition
        this is definition
            ifTrue: { Error raise: "Cyclic definition!" }.
        next is False
            ifFalse: { next checkCycle: definition }!
end

interface AstDefinition
    is AstNode
    required method done
    required method _eval
    method defineIn: environment
        self done
            ifTrue: { (environment globals at: name) value }
            ifFalse: { DefinitionsInProgress
                           with: self
                           do: { { environment define: name value: self _eval }
                                     finally: { done = True } } }!
end

class AstDefine { name body frameSize done }
    is AstDefinition
    direct method name: name body: body frameSize: frameSize
        self name: name body: body frameSize: frameSize done: False!
    method _eval
        -- return inside define should work
        let context = InterpreterContext new: frameSize
                                         returnBlock: { |value| return value }.
        { body evalWith: context in: Process new }
            finally: { context invalidate } !
end

class AstClass { name directMethods slots methods done }
    is AstDefinition
    direct method name: name
                  directMethods: directMethods
                  slots: slots
                  methods: methods
        self
            name: name
            directMethods: directMethods
            slots: slots
            methods: methods
            done: False!
    -- Class methods should be translated in a specific environment
    -- that contains the instance variables.
    method _eval
        Class
            new: name
            interfaces: ["Object"]
            directMethods: (Array from: directMethods)
            slots: (Array from: slots)
            methods: (Array from: methods)!
    method checkEqualInternal: other
        name checkEqual: other name.
        directMethods checkEqual: other directMethods.
        slots checkEqual: other slots.
        methods checkEqual: other methods!
end

define $context
    False!

define $process
    False!

class AstMethod { selector argumentCount body frameSize }
    is Object
    method invoke: arguments on: receiver
        let frame = Array new: frameSize.
        let nArgs = arguments size.
        argumentCount is nArgs
            ifFalse: { Error raise: "Method argument count mismatch!" }.
        1 to: nArgs
          do: { |i| frame put: (arguments at: i) at: i }.
        let context = InterpreterContext
                          sender: $context
                          receiver: receiver
                          frame: frame
                          returnBlock: { |value| return value }.
        { body evalWith: context in: $process }
            finally: { context invalidate } !
end

class AstBlockClosure { context block }
    is AstNode
    method value
        self apply: []!
    method value: arg
        self apply: [arg]!
    method apply: arguments
        let frame = Array new: block frameSize.
        let nArgs = arguments size.
        block argumentCount is nArgs
            ifFalse: { Error raise: "Block argument count mismatch!" }.
        1 to: nArgs
          do: { |i| frame put: (arguments at: i) at: i }.
        block body
            evalWith: (InterpreterContext
                           sender: context
                           receiver: context receiver
                           frame: frame
                           returnBlock: context returnBlock)
            in: $process!
end

class AstBlock { body argumentCount frameSize }
    is AstNode
    method evalWith: context in: process
        AstBlockClosure
            context: context
            block: self!
    method frameSize
        frameSize!
end

class AstSelfRef {}
    is AstNode
    method evalWith: context in: process
        context receiver!
end

class AstSlotRef { name index::Integer }
    is AstNode
    method evalWith: context in: process
        context slot: index!
end

class AstBindLexical { name index value body }
    is AstNode
    method evalWith: context in: process
        let object = value evalWith: context in: process.
        context
            put: object
            at: index
            inFrame: 1.
        body evalWith: context in: process!
end

class AstLexicalRef { name
                      frame::Integer
                      index::Integer }
    is AstNode
    method evalWith: context in: process
        context at: index inFrame: frame!
end

class AstLexicalSet { name
                      frame::Integer
                      index::Integer
                      value }
    is AstNode
    method evalWith: context in: process
        context
            put: (value evalWith: context in: process)
            at: index
            inFrame: frame!
end
