import .utils.Debug
import .astInterpreter.AstInterpreter

interface Ast
    is Object

    method isConstant
        False!

    method debug
        Debug println: "#<AST {self}>"!
end

class AstBuiltin { value }
    is Object

    method eval
        value!

    method isBuiltin
        True!

    method visitBy: visitor
        visitor visitBuiltin: self!

    method __addInterface: anInterface
        value __addInterface: anInterface!

    method __addDirectMethod: aDirectMethod
        value __addDirectMethod: aDirectMethod!

    method __addInstanceMethod: anInstanceMethod
        value __addInstanceMethod: anInstanceMethod!
end

interface AstDefinition
    is Object

    method eval
        Error raise: "{self classOf name}#eval -- should not happend!"!

    method defineIn: env
        Error raise: "{self classOf name}#defineIn: -- should not happen!"!

    method isBuiltin
        False!

    method isDynamic
        False!

    method allocGlobal
        self isDynamic
            ifTrue: { AstDynamic name: name }
            ifFalse: { AstGlobal name: name }!
end

class AstDefinitionList { list }
    is AstDefinition

    direct method new: list
        self
            list: list!

    method allocGlobal
        panic "No global for AstDefinitionList"!

    method defineIn: env
        list do: { |each| each defineIn: env }!
end

class AstDefine { name body frameSize isDynamic }
    is AstDefinition

    method defineIn: env
        env define: name as: self!

    method eval
        AstInterpreter evalDefine: body frameSize: frameSize!

    method toString
        "#<AstDefine {self name}>"!

    method visitBy: visitor
        visitor visitDefine: self!
end

class AstImport { spec }
    is AstDefinition

    method defineIn: env
        self!

    method eval
        self!

    method toString
        "#<AstImport {spec}>"!
end

class AstExtend { type interfaces directMethods instanceMethods }
    is AstDefinition

    method defineIn: env
        -- FIXME: This should use a mirror for host, or
        -- existing metaobjects for self-hosted classes.
        --
        -- FIXME: Does this mean we should resolve name in env instead
        -- of the way it is now done?
        let target = type definition.
        interfaces do: { |each| target __addInterface: each value }.
        directMethods do: { |each| target __addDirectMethod: each }.
        instanceMethods do: { |each| target __addInstanceMethod: each }.
        target!

    method toString
        "#<AstExtend {type name}>"!
end

class AstInterface { name _interfaces _directMethods _instanceMethods }
    is AstDefinition

    direct method name: name
                  interfaces: interfaces
                  directMethods: directMethods
                  instanceMethods: instanceMethods
        self
            name: name
            _interfaces: (Dictionary
                              keys: (interfaces collect: { |each| each name })
                              values: interfaces)
            _directMethods: (Dictionary
                                 keys: (directMethods collect: { |each| each selector name })
                                 values: directMethods)
            _instanceMethods: (Dictionary
                                   keys: (instanceMethods collect: { |each| each selector name })
                                   values: instanceMethods)!

    method eval
        Interface
            new: name
            interfaces: (self interfaces collect: #value as: Array)
            directMethods: self directMethods
            instanceMethods: self instanceMethods!

    method interfaces
        _interfaces values!

    method instanceMethods
        _instanceMethods values!

    method directMethods
        _directMethods values!

    method __addInterface: anInterface
        _interfaces at: anInterface name put: anInterface!

    method __addDirectMethod: aDirectMethod
        _directMethods at: aDirectMethod selector name put: aDirectMethod!

    method __addInstanceMethod: anInstanceMethod
        _instanceMethods at: anInstanceMethod selector name put: anInstanceMethod!

    method defineIn: env
        env define: name as: self!

    method visitBy: visitor
        visitor visitInterfaceDefinition: self!

    method toString
        "#<AstInterface {name}>"!
end

class AstClass { name slots interfaces _directMethods _instanceMethods }
    is AstDefinition

    direct method name: name
                  slots: slots
                  interfaces: interfaces
                  directMethods: directMethods
                  instanceMethods: instanceMethods
        self
            name: name
            slots: slots
            interfaces: interfaces
            _directMethods: directMethods
            _instanceMethods: instanceMethods!

    method __addInterface: anInterface
        interfaces push: anInterface!

    method __addDirectMethod: aDirectMethod
        _directMethods add: aDirectMethod!

    method __addInstanceMethod: anInstanceMethod
        _instanceMethods add: anInstanceMethod!

    method directMethods
        self
            _collectFromInterfaces: #directMethods
            _with: _directMethods!

    method markFunction
        "foo_mark_array"!

    method instanceMethods
        self
            _collectFromInterfaces: #instanceMethods
            _with: self _readerMethods
            _with: _instanceMethods!

    method _readerMethods
        (slots reject: { |each| each name startsWith: "_" })
            collect: { |each|
                       AstReaderMethod slot: each }!

    method _collectFromInterfaces: block _with: local
        self _collectFromInterfaces: block _with: local _with: []!

    method _collectFromInterfaces: block _with: local1 _with: local2
        let all = Dictionary new.
        interfaces do: { |anInterface|
                         self _collectMethods: (block value: anInterface definition)
                              _into: all }.
        self _collectMethods: local1
             _into: all.
        self _collectMethods: local2
             _into: all.
        all values!

    method _collectMethods: methods _into: dict
        methods do: { |each| dict put: each at: each selector name }!

    method defineIn: env
        -- Debug println: "AstClass#defineIn: {name}".
        env define: name as: self!

    method eval
        -- Debug println: "slots: {(slots collect: #type) asArray displayString}".
        Class
            new: name
            slots: (slots
                        collect: { |each|
                                     { name: each name,
                                       type: each type } }
                        as: Array)
            interfaces: (Array from: (interfaces collect: #value))
            directMethods: (Array from: _directMethods)
            instanceMethods: (Array from: _instanceMethods)!

    method constructor
        slots
            ifEmpty: { #new }
            ifNotEmpty: { Selector
                              new: (StringOutput
                                        with: { |out|
                                                slots do: { |each|
                                                            out print: each name.
                                                            out print: ":" } }) }!

    method visitBy: visitor
        visitor visitClassDefinition: self!

    method toString
        "#<AstClass {name}>"!
end

class AstSlot { name index type }
    is Object

    method referenceUpwards: offset
        AstSlotRef slot: self!
end

class AstReaderMethod { slot }
    method selector
        Selector new: slot name!
    method signature
        []!
    method arity
        0!
    method frameSize
        0!
    method isBuiltin
        False!
    method returnType
        -- FIXME: Since setters check the type, the readers don't
        -- need to -- but it would be nice for senders to know the type.
        -- So returnType needs to be split into returnTypeCheck and
        -- declaredReturnType?
        Any!
    method body
        slot referenceUpwards: False!
end

class AstMethod { selector argumentVariables returnType body frameSize isDirect isRequired }
    is Object

    direct method selector: selector
                  argumentVariables: argumentVariables
                  returnType: returnType
                  isDirect: isDirect
                  isRequired: isRequired
        self
            selector: selector
            argumentVariables: argumentVariables
            returnType: returnType
            body: False
            frameSize: False
            isDirect: isDirect
            isRequired: isRequired!

    method body: bodyVal
        body is False assert: "body not set".
        body = bodyVal!

    method frameSize: frameSizeVal
        frameSize is False assert: "frame size not set".
        frameSize = frameSizeVal!

    method addTemp
        let offset = frameSize.
        frameSize = frameSize + 1.
        offset!

    method name
        selector name!

    method invoke: arguments on: receiver
        AstInterpreter
            invokeMethod: self
            on: receiver
            with: arguments!

    method isDefined
        (body is False) not!

    method signature
        argumentVariables collect: { |var| var type }!

    -- FIXME: duplicate methods below

    method arity
        argumentVariables size!

    method argumentCount
        argumentVariables size!

    method isBuiltin
        False!

    method printOn: stream
        stream print: "#<AstMethod {selector}>"!
end

interface AstNode
    is Ast

    required method visitBy: visitor
end

class AstComment { comment value source }
    is AstNode
    is AstDefinition

    method visitBy: visitor
        visitor visitComment: self!

    method defineIn: env
        value defineIn: env!

    method eval
        value eval!

    method parts
        [comment, value]!
end

class AstArray { entries }
    is AstNode

    method visitBy: visitor
        visitor visitArray: self!

    method parts
        entries!
end

class AstTypecheck { value type }
    is AstNode

    method visitBy: visitor
        visitor visitTypecheck: self!

    method parts
        [value, type]!
end

class AstRecord { name entries }
    is AstNode

    method visitBy: visitor
        visitor visitRecord: self!

    method parts
        [name, entries]!
end

class AstDictionary { entries }
    is AstNode

    method visitBy: visitor
        visitor visitDictionary: self!

    method parts
        entries!
end

class AstValueMarker { string }
    is Object
    method toString
        string!
end

define AstUndefined AstValueMarker string: "<undefined>"!
define AstPending AstValueMarker string: "<pending>"!
define AstInProgress AstValueMarker string: "<in-progress>"!

interface AstGlobalVariable
    is AstNode

    direct method name: name
        -- Debug println: "{self name}#name: {name}".
        self
            name: name
            _value: AstUndefined
            _definition: False
            sources: List new!

    direct method name: name definition: definition
        -- Debug println: "{self name}#name: {name} (defined)".
        self
            name: name
            _value: AstPending
            _definition: definition
            sources: List new!

    method isUndefined
        _definition is False!

    method isDefined
        self isUndefined not!

    method definition
        self assertDefined: True.
        _definition!

    method define: definition
        -- Debug println: "AstGlobalVariable#define: {name}".
        self assertDefined: False.
        _value = AstPending.
        _definition = definition.
        self isDefined assert!

    method assertDefined: wanted
        self isDefined is wanted
            ifFalse: { wanted
                           ifTrue: { Error raise: "Undefined global in AST: {name}" }
                           ifFalse: { Error raise: "Global is already defined: {name}" } }!

    method value
        self assertDefined: True.
        _value is AstInProgress
            ifTrue: { Error raise: "Cyclic definition: {self name}" }.
        _value is AstPending
            ifTrue: { _value = AstInProgress.
                      _value = _definition eval }.
        _value!

    method isConstant
        True!

    method referenceUpwards: _offset
        self!

    method toString
        "#<{self classOf name} {self name}: {self _info}>"!

    method _info
        self isUndefined
            ifTrue: { "<undefined>" }.
        _value!

    method warnIfUndefined
        self isUndefined
            ifTrue: { let note = "Undefined variable: {self name}".
                      (sources isEmpty not) assert.
                      Output debug
                          println: "\nWARNING: {note}\n{sources first note: note}" }!

    method withSource: sourceLocation
        sources add: sourceLocation.
        self!
end

class AstGlobal { name::String _value _definition sources }
    is AstGlobalVariable

    method visitBy: visitor
        visitor visitGlobal: self!

    method isDynamic
        False!

    -- KLUDGE: Currently types are either Any or AstGlobals. This is marginally
    -- than the previous mess, but still not nice.
    method typecheck: object
        self value typecheck: object!

    method redefine: newDefinition
        -- FIXME: This is a bit dodgy: the usage is currently for replacing
        -- host definitions of builtins in transpiler, but it seems to me that
        -- value should be updated too if it has been materialized...
        _definition = newDefinition!

end

class AstDynamic { name::String _value _definition sources }
    is AstGlobalVariable

    method bind: newValue in: block
        let oldValue = _value.
        _value = newValue.
        { block value }
            finally: { _value = oldValue }!

    method visitBy: visitor
        visitor visitDynamic: self!

    method isDynamic
        True!
end

class AstConstantRef { value }
    is AstNode

    method visitBy: visitor
        visitor visitConstant: self!

    method isConstant
        True!
end

class AstIs { left right }
    is AstNode

    method visitBy: visitor
        visitor visitIs: self!
end

class AstSeq { first then }
    is AstNode

    method visitBy: visitor
        visitor visitSeq: self!
end

class AstReturn { from value }
    is AstNode

    method visitBy: visitor
        visitor visitReturn: self!
end

class AstPanic { value }
    is AstNode

    method visitBy: visitor
        visitor visitPanic: self!
end

class AstSend {
        receiver
        selector
        arguments
        source
    }
    is AstNode

    method visitBy: visitor
        visitor visitSend: self!
end

class AstBlock { body argumentVariables returnType frameSize }
    is AstNode

    method selector
        self argumentCount is 0
            ifTrue: { return #value }.
        self argumentCount is 1
            ifTrue: { return #value: }.
        self argumentCount is 2
            ifTrue: { return #value:value: }.
        self argumentCount is 3
            ifTrue: { return #value:value:value: }.
        #apply:!

    method visitBy: visitor
        visitor visitBlock: self!

    method addTemp
        let offset = frameSize.
        frameSize = frameSize + 1.
        offset!

    method argumentCount
        argumentVariables size!
end

class AstSelfInstanceRef {}
    is AstNode

    method visitBy: visitor
        visitor visitSelfInstance: self!
end

class AstSelfClassRef {}
    is AstNode

    method visitBy: visitor
        visitor visitSelfClass: self!
end

class AstSlotRef { slot source }
    is AstNode

    direct method slot: slot
        self
            slot: slot
            source: False!

    method visitBy: visitor
        visitor visitSlotRef: self!

    method assign: value
        AstSlotSet
            slot: slot
            value: value!

    method withSource: sourceLocation
        (source is False) assert.
        source = sourceLocation.
        self!
end

class AstSlotSet { slot value }
    is AstNode

    method visitBy: visitor
        visitor visitSlotSet: self!
end

class AstBindLexical { variable value body }
    is AstNode

    method visitBy: visitor
        visitor visitBindLexical: self!
end

class AstBindDynamic { variable value body }
    is AstNode

    method visitBy: visitor
        visitor visitBindDynamic: self!
end

class AstLexicalRef { variable frameOffset::Integer source }
    is AstNode

    direct method variable: variable frameOffset: offset
        self
            variable: variable
            frameOffset: offset
            source: False!

    method withSource: newSource
        (source is False) assert.
        source = newSource.
        self!

    method visitBy: visitor
        visitor visitLexicalRef: self!

    method assign: value
        AstLexicalSet
            variable: variable
            frameOffset: frameOffset
            value: value!
end

class AstLexicalSet { variable frameOffset::Integer value }
    is AstNode

    method visitBy: visitor
        visitor visitLexicalSet: self!
end
