import .utils.Debug
import .astInterpreter.AstInterpreter

class StandardUndefinedPolicy {}
    -- Called during translation when encountering an undefined variable
    -- This particular method gets called when an undefined variable is
    -- encountered outside a definition.
    direct method reference: name in: environment
        Error raise: "Undefined variable: {name}\nAvailable: {environment globals keys sort}"!

    direct method referenceDynamic: name in: environment
        self reference: name in: environment!

    -- Called during evaluation when encountering a lazily resolved undefined
    -- variable. This particilar method should never be called.
    direct method resolve: name for: node
        let locations = StringOutput
                            with: { |out|
                                    node sources
                                        do: { |source|
                                              out newline.
                                              out println: (source note: "here") } }.
        panic "Unresolved undefined variable: `{name}`! This should not happen.{locations}"!
end

define $UndefinedPolicy
    StandardUndefinedPolicy!

class AllowReferenceToUndefined {}
    -- During translation of definitions we allow references to undefined
    -- variables.
    direct method reference: name in: env
        let global = (AstGlobal name: name).
        env globals
            put: global
            at: name.
        return global!

    direct method referenceDynamic: name in: env
        let dynamic = (AstDynamic name: name).
        env globals
            put: dynamic
            at: name.
        return dynamic!

    direct method resolve: name for: node
        StandardUndefinedPolicy resolve: name for: node!

    direct method do: block
        let $UndefinedPolicy = self.
        block value!
end

class ResolveUndefinedsWith { definitions environment }
    direct method definitions: definitions in: environment do: block
        (self definitions: definitions environment: environment)
            do: block!

    method reference: name in: environment
        StandardUndefinedPolicy reference: name in: environment!

    method referenceDynamic: name in: environment
        StandardUndefinedPolicy referenceDynamic: name in: environment!

    -- During evaluation of definition bodies we resolve undefineds to
    -- as-of-yet evaluated definitions.
    method resolve: name for: node
        (definitions
             at: name
             ifNone: { StandardUndefinedPolicy reference: name in: environment })
        defineIn: environment!

    method do: block
        let $UndefinedPolicy = self.
        block value!
end

class UndefinedPolicy {}
    direct method reference: name in: environment
        $UndefinedPolicy reference: name in: environment!
    direct method referenceDynamic: name in: environment
        $UndefinedPolicy referenceDynamic: name in: environment!
    direct method resolve: name for: node
        $UndefinedPolicy resolve: name for: node!
end

interface Ast
    is Object

    method isConstant
        False!

    method debug
        Debug println: "#<AST {self}>"!
end

define $DefinitionsInProgress
    False!

class DefinitionsInProgress { this next }
    direct method with: definition do: block
        let old = $DefinitionsInProgress.
        old is False
            ifFalse: { old checkCycle: definition }.
        let $DefinitionsInProgress = DefinitionsInProgress this: definition next: old.
        block value!

    method checkCycle: definition
        this is definition
            ifTrue: { Error raise: "Cyclic definition!" }.
        next is False
            ifFalse: { next checkCycle: definition }!
end

interface AstDefinition
    is Object

    required method isDefined
    required method markDefined
    required method eval

    method do: block
        block value: self!

    method defineIn: environment
        self isDefined
            ifFalse: { DefinitionsInProgress
                           with: self
                           do: { { -- Debug println: "define: 1 {self name}".
                                   let val = self eval.
                                   -- Debug println: "define: 2 {val}".
                                   environment define: name value: val }
                                     after: { self markDefined } } }.
        (environment globals at: name) value!

end

class AstDefinitionList { list }
    is AstDefinition
    direct method new: list
        self list: list!
    method isDefined
        panic "never"!
    method markDefined
        panic "never"!
    method eval
        panic "never"!
    method do: block
        list do: { |each| each do: block }!
end

class AstDefine { name body frameSize isDynamic isDefined }
    is AstDefinition

    direct method name: name body: body frameSize: frameSize isDynamic: isDynamic
        self
            name: name
            body: body
            frameSize: frameSize
            isDynamic: isDynamic
            isDefined: False!

    method markDefined
        isDefined = True!

    method eval
        AstInterpreter evalDefine: body frameSize: frameSize!

    method isCanonical
        True!

    method toString
        "#<AstDefine {self name}>"!
end

class AstImport { spec isDefined }
    is AstDefinition

    direct method spec: spec
        self
            spec: spec
            isDefined: False!

    method markDefined
        isDefined = True!

    method isCanonical
        False!

    method eval
        self!
end

class AstExtend { type interfaces directMethods instanceMethods isDefined }
    is AstDefinition

    direct method type: type
                  interfaces: interfaces
                  directMethods: directMethods
                  instanceMethods: instanceMethods
        self
            type: type
            interfaces: interfaces
            directMethods: directMethods
            instanceMethods: instanceMethods
            isDefined: False!

    method defineIn: environment
        self isDefined
            ifFalse: { -- FIXME: This should use a mirror for host, or
                       -- existing metaobjects for self-hosted classes.
                       DefinitionsInProgress
                           with: self
                           do: { let target = type value.
                                 interfaces do: { |each| target __addInterface: each value }.
                                 directMethods do: { |each| target __addDirectMethod: each }.
                                 instanceMethods do: { |each| target __addInstanceMethod: each }.
                                 self markDefined } }.
        type value!

    method markDefined
        isDefined = True!

    method isCanonical
        False!

    method eval
        panic "never, extend is different!"!

    method toString
        "#<AstExtend {type name}>"!
end

class AstInterface { name interfaces directMethods instanceMethods isDefined }
    is AstDefinition

    direct method name: name
                  interfaces: interfaces
                  directMethods: directMethods
                  instanceMethods: instanceMethods
        self
            name: name
            interfaces: interfaces
            directMethods: directMethods
            instanceMethods: instanceMethods
            isDefined: False!

    method markDefined
        isDefined = True!

    method eval
        Interface
            new: name
            interfaces: (Array from: (interfaces collect: #value))
            directMethods: (Array from: directMethods)
            instanceMethods: (Array from: instanceMethods)!

    method isCanonical
        True!

    method toString
        "#<AstInterface {name}>"!
end

class AstClass { name slots interfaces directMethods instanceMethods isDefined }
    is AstDefinition

    direct method name: name
                  slots: slots
                  interfaces: interfaces
                  directMethods: directMethods
                  instanceMethods: instanceMethods
        self
            name: name
            slots: slots
            interfaces: interfaces
            directMethods: directMethods
            instanceMethods: instanceMethods
            isDefined: False!

    method markDefined
        isDefined = True!

    method eval
        -- Debug println: "slots: {(slots collect: #type) asArray displayString}".
        Class
            new: name
            slots: (slots
                        collect: { |each|
                                     { name: each name,
                                       type: each type value } }
                        as: Array)
            interfaces: (Array from: (interfaces collect: #value))
            directMethods: (Array from: directMethods)
            instanceMethods: (Array from: instanceMethods)!

    method isCanonical
        True!

    method toString
        "#<AstClass {name}>"!
end

class AstMethod { selector argumentVariables returnType body frameSize isDirect }
    is Object

    method name
        selector name!

    method invoke: arguments on: receiver
        AstInterpreter
            invokeMethod: self
            on: receiver
            with: arguments!

    method isDefined
        (body is False) not!

    method argumentCount
        argumentVariables size!
end

interface AstNode
    is Ast

    required method visitBy: visitor
end

class AstComment { comment value source }
    is AstNode
    is AstDefinition

    method visitBy: visitor
        visitor visitComment: self!

    method eval
        panic "AstComment#eval"!

    method markDefined
        panic "AstComment#markDefined"!

    method isDefined
        panic "AstComment#isDefined"!

    method isCanonical
        panic "AstComment#isCanonical"!

    method do: block
        value do: block!
end

class AstArray { entries }
    is AstNode

    method visitBy: visitor
        visitor visitArray: self!

    method parts
        entries!
end

class AstTypecheck { value type }
    is AstNode

    method visitBy: visitor
        visitor visitTypecheck: self!

    method parts
        [value, type]!
end

class AstRecord { name entries }
    is AstNode

    method visitBy: visitor
        visitor visitRecord: self!

    method parts
        [name, entries]!
end

class AstDictionary { entries }
    is AstNode

    method visitBy: visitor
        visitor visitDictionary: self!

    method parts
        entries!
end

define AstUndefinedMarker
    -- FIXME: When constant coalescing starts happening, this needs
    -- protection.
    ["<AstUndefineMarker>"]!

interface AstGlobalVariable
    is AstNode

    direct method name: name
        self
            name: name
            _value: AstUndefinedMarker
            sources: List new!

    direct method name: name value: value
        self
            name: name
            _value: value
            sources: List new!

    method isUndefined
        _value is AstUndefinedMarker!

    method value
        self isUndefined
            ifTrue: { return UndefinedPolicy resolve: self name for: self }.
        _value!

    method isConstant
        True!

    method value: newValue
        (_value is AstUndefinedMarker) assert.
        _value = newValue!

    method visitBy: visitor
        visitor visitGlobal: self!

    method referenceUpwards: _offset
        self!

    method toString
        "#<{self classOf name} {self name}: {_value}>"!

    method warnIfUndefined
        self isUndefined
            ifTrue: { let note = "Undefined variable: {self name}".
                      (sources isEmpty not) assert.
                      Output debug
                          println: "\nWARNING: {note}\n{sources first note: note}" }!

    method withSource: sourceLocation
        sources add: sourceLocation.
        self!
end

class AstGlobal { name::String _value sources }
    is AstGlobalVariable
end

class AstDynamic { name::String _value sources }
    is AstGlobalVariable

    method bind: newValue in: block
        let oldValue = _value.
        _value = newValue.
        { block value }
            finally: { _value = oldValue }!

end

class AstConstantRef { value }
    is AstNode

    method visitBy: visitor
        visitor visitConstant: self!

    method isConstant
        True!
end

class AstIs { left right }
    is AstNode

    method visitBy: visitor
        visitor visitIs: self!
end

class AstSeq { first then }
    is AstNode

    method visitBy: visitor
        visitor visitSeq: self!
end

class AstReturn { value }
    is AstNode

    method visitBy: visitor
        visitor visitReturn: self!
end

class AstPanic { value }
    is AstNode

    method visitBy: visitor
        visitor visitPanic: self!
end

class AstSend {
        receiver
        selector
        arguments
        source
    }
    is AstNode

    method visitBy: visitor
        visitor visitSend: self!
end

class AstBlock { body argumentVariables returnType frameSize }
    is AstNode

    method selector
        self argumentCount is 0
            ifTrue: { return #value }.
        self argumentCount is 1
            ifTrue: { return #value: }.
        self argumentCount is 2
            ifTrue: { return #value:value: }.
        self argumentCount is 3
            ifTrue: { return #value:value:value: }.
        #apply:!

    method visitBy: visitor
        visitor visitBlock: self!

    method argumentCount
        argumentVariables size!
end

class AstSelfInstanceRef {}
    is AstNode

    method visitBy: visitor
        visitor visitSelfInstance: self!
end

class AstSelfClassRef {}
    is AstNode

    method visitBy: visitor
        visitor visitSelfClass: self!
end

class AstSlotRef { slot source }
    is AstNode

    direct method slot: slot
        self
            slot: slot
            source: False!

    method visitBy: visitor
        visitor visitSlotRef: self!

    method assign: value
        AstSlotSet
            slot: slot
            value: value!

    method withSource: sourceLocation
        (source is False) assert.
        source = sourceLocation.
        self!
end

class AstSlotSet { slot value }
    is AstNode

    method visitBy: visitor
        visitor visitSlotSet: self!
end

class AstBindLexical { variable value body }
    is AstNode

    method visitBy: visitor
        visitor visitBindLexical: self!
end

class AstBindDynamic { variable value body }
    is AstNode

    method visitBy: visitor
        visitor visitBindDynamic: self!
end

class AstLexicalRef { variable frameOffset::Integer source }
    is AstNode

    direct method variable: variable frameOffset: offset
        self
            variable: variable
            frameOffset: offset
            source: False!

    method withSource: newSource
        (source is False) assert.
        source = newSource.
        self!

    method visitBy: visitor
        visitor visitLexicalRef: self!

    method assign: value
        AstLexicalSet
            variable: variable
            frameOffset: frameOffset
            value: value!
end

class AstLexicalSet { variable frameOffset::Integer value }
    is AstNode

    method visitBy: visitor
        visitor visitLexicalSet: self!
end
