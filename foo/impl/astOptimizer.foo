import .astRewriter.AstRewriter
import .ast.*
import .utils.*
import .environment.Argument

class AstOptimizer { ast env continue }

    direct method optimize: ast in: env
        (self ast: ast
              env: env
              continue: True)
            optimize!

    method optimize
        {
            self resolveKnownMethods
                ifTrue: { self inlineTrivialMethods }
                ifFalse: { False }
        }
            whileTrue.
        ast!

    method resolveKnownMethods
        let resolver = KnownMethodResolver new: env.
        ast = ast visitBy: resolver.
        resolver didNothing not!

    method inlineTrivialMethods
        -- Trivial methods are such that inlining them
        -- never blows up code size too much.
        let didSomething = False.
        {
            let inliner = TrivialMethodInliner new.
            ast = ast visitBy: inliner.
            let didNow = inliner didNothing not.
            didSomething = didSomething or: didNow.
            didNow
        }
            whileTrue.
        didSomething!
end

class KnownMethodResolver { env didNothing }
    is AstRewriter

    direct method new: env
        self env: env
             didNothing: True!

    method visitSend: aSend
        let recv = aSend receiver visitBy: self.
        let args = aSend arguments collect: { |each| each visitBy: self }.
        let type = recv type.
        (type findMethod: aSend selector in: env)
            => { |aMethod|
                 didNothing = False.
                 return AstCallMethod
                     target: (aMethod visitBy: self)
                     receiver: recv
                     arguments: args
                     source: aSend source }.
        aSend
            receiver: recv
            arguments: args!
end

---
Trivial methods contain at most one send or call.

We extend selected AST classes with #isTrivial and
#isSimple methods.

#isSimple is stricter than #isTrivial: it is used
to check receiver and arguments or a call or send,
and hence doesn't allow calls or sends.
---
class TrivialMethodInliner { didNothing }
    is AstRewriter

    direct method new
        self didNothing: True!

    method visitCallMethod: aCall
        let recv = aCall receiver visitBy: self.
        let args = aCall arguments collect: { |each| each visitBy: self }.
        Debug println: "tryInline: {aCall}".
        -- Since we're not yet introducing new bindings for arguments
        -- we need to restrict inlining to simple receiver and
        -- arguments.
        (aCall target isTrivial
            and: recv isSimple
            and: (args allSatisfy: #isSimple))
        ifTrue: { didNothing = False.
                  aCall target
                      inlineOn: recv
                      withArguments: args }
        ifFalse: { AstCallMethod
                       target: aCall target
                       receiver: recv
                       arguments: args
                       source: aCall source }!
end

extend Ast
    method isTrivial
        self isSimple!
    method isSimple
        False!
end

extend AstConstantRef
    method isSimple
        True!
    method inlineOn: _receiver withArguments: _arguments
        Debug println: "inlining constant: {self}".
        self!
end

extend AstLexicalRef
    method isSimple
        self frameOffset is 0 and: (Argument includes: self variable)!
    method inlineOn: _receiver withArguments: arguments
        Debug println: "inlining argument: {self} -> {arguments at: self variable index}".
        arguments at: self variable index!
end

extend AstSelfInstanceRef
    method isSimple
        True!
    method inlineOn: receiver withArguments: _arguments
        Debug println: "inlining: self".
        receiver!
end

extend AstMethod
    method isTrivial
        self body isTrivial
            ifTrue: { Debug println: "trivial: {self}".
                      True }
            ifFalse: { Debug println: "non-trivial: {self} == {self body}".
                       False }!

    method inlineOn: receiver withArguments: arguments
        Debug println: "inlining: {self} on: {receiver} with: {arguments}".
        self body
            inlineOn: receiver
            withArguments: arguments!
end

extend AstSend
    method isTrivial
        self receiver isSimple
            ifTrue: { (self arguments allSatisfy: #isSimple)
                          ifTrue: { True }
                          ifFalse: { Debug println: "non-simple arguments: {self arguments reject: #isSimple}".
                                     False } }
            ifFalse: { Debug println: "non-simple receiver: {self receiver}".
                       False }!

    method inlineOn: receiver withArguments: arguments
        Debug println: "inlining: {self} on: {receiver} with: {arguments}".
        AstSend
            receiver: (self receiver
                           inlineOn: receiver
                           withArguments: arguments)
            selector: self selector
            arguments: (self arguments
                            collect: { |each|
                                       each inlineOn: receiver
                                            withArguments: arguments})
            source: self source!
end

extend AstCallMethod
    method isTrivial
        self receiver isSimple
            ifTrue: { (self arguments allSatisfy: #isSimple )
                          ifTrue: { True }
                          ifFalse: { Debug println: "non-simple arguments: {self arguments}".
                                     False } }
            ifFalse: { Debug println: "non-simple receiver: {self receiver}".
                       False }!

    method inlineOn: receiver withArguments: arguments
        Debug println: "inlining: {self} on: {receiver} with: {arguments}".
        AstCallMethod
            target: self target
            receiver: (self receiver
                           inlineOn: receiver
                           withArguments: arguments)
            arguments: (self arguments
                            collect: { |each|
                                       each inlineOn: receiver
                                            withArguments: arguments})
            source: self source!
end
