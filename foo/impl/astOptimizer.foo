import .astRewriter.AstRewriter
import .ast.*
import .utils.*

interface AstOptimizer
    direct method optimize: ast in: env
        {
            let resolver = KnownMethodResolver new: env.
            ast = ast visitBy: resolver.
            resolver didNothing
                => { return ast }.

            -- Trivial methods are such that inlining them
            -- never blows up code size, so we can do this
            -- unconditionally.
            let inliner = TrivialMethodInliner new.
            ast = ast visitBy: inliner.
            inliner didNothing
                => { return ast }

        } loop!
end

class KnownMethodResolver { env didNothing }
    is AstRewriter

    direct method new: env
        self env: env
             didNothing: True!

    method visitSend: aSend
        let recv = aSend receiver visitBy: self.
        let args = aSend arguments collect: { |each| each visitBy: self }.
        let type = recv type.
        (type findMethod: aSend selector in: env)
            => { |aMethod|
                 didNothing = False.
                 return AstCallMethod
                     target: (aMethod visitBy: self)
                     receiver: recv
                     arguments: args
                     source: aSend source }.
        aSend
            receiver: recv
            arguments: args!
end

---
Trivial methods contain at most one send or call.

We extend selected AST classes with #isTrivial and
#isSimple methods.

#isSimple is stricter than #isTrivial: it is used
to check receiver and arguments or a call or send,
and hence doesn't allow calls or sends.
---
class TrivialMethodInliner { didNothing }
    is AstRewriter

    direct method new
        self didNothing: True!

    method visitCallMethod: aCall
        let recv = aCall receiver visitBy: self.
        let args = aCall arguments collect: { |each| each visitBy: self }.
        Debug println: "tryInline: {aCall}".
        aCall target isTrivial
            ifTrue: { didNothing = False.
                      self inline: aCall target
                           on: recv
                           withArguments: args }
            ifFalse: { AstCallMethod
                           target: aCall target
                           receiver: recv
                           arguments: args
                           source: aCall source }!

    method inline: aMethod on: receiver withArguments: arguments
        Debug println: "inline: {aMethod}".
        -- Only constant references are trivial at the moment.
        aMethod body!
end

extend Ast
    method isTrivial
        self isSimple!
    method isSimple
        False!
end

extend AstMethod
    method isTrivial
        self body isTrivial
            ifTrue: { True }
            ifFalse: { Debug println: "nontrivial: {self} == {self body}".
                       False }!
end

extend AstConstantRef
    method isSimple
        True!
end

extend AstCallMethod
    method isTrivial
        self receiver isSimple
            ifTrue: { (self arguments allSatisfy: #isSimple)
                          ifTrue: { True }
                          ifFalse: { Debug println: "nonsimple arguments: {self arguments}".
                                     False } }
            ifFalse: { Debug println: "nonsimple receiver: {self receiver}".
                       False }!
end
