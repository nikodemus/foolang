import .utils.Debug
import .astVisitor.AstVisitor

class Process {}
    is Object
end

class BacktraceFrame { receiver selector::Selector arguments }
    is Object
end

class InterpreterContext {
        sender
        receiver
        theMethod
        frameContext
        frame::Array
        returnBlock
    }
    is Object

    direct method new: size
        self new: size
             returnBlock: { |value|
                            Error raise: "Invalid return: {value}" }!

    direct method new: size returnBlock: returnBlock
        self sender: False
             receiver: False
             theMethod: False
             frameContext: False
             frame: (Array new: size value: "<unbound>")
             returnBlock: returnBlock!

    method invalidate
        returnBlock = { |value|
                        Error raise: "Cannot return from dead context: {value}" }!

    method at: index inFrame: frameNumber
        frameNumber > 0
            ifTrue: { frameContext at: index inFrame: frameNumber - 1 }
            ifFalse: { frame at: index }!

    method put: value at: index inFrame: frameNumber
        frameNumber > 0
            ifTrue: { frameContext put: value at: index inFrame: frameNumber - 1 }
            ifFalse: { frame put: value at: index }!

    method backtrace
        let bt = List new.
        let ctx = self.
        { ctx is False }
            whileFalse: { let m = ctx theMethod.
                          m is False
                              ifFalse: { bt add:
                                             (BacktraceFrame
                                                  receiver: ctx receiver
                                                  selector: m selector
                                                  arguments: (ctx frame from: 1 to: m argumentCount)) }.
                         ctx = ctx sender }.
        bt!

end

class AstBlockClosure { context block }
    is Object
    method value
        self apply: []!
    method value: arg
        self apply: [arg]!
    method apply: arguments
        let frame = Array new: block frameSize.
        let nArgs = arguments size.
        block argumentCount is nArgs
            ifFalse: { Error raise: "Self-hostend block argument count mismatch!" }.
        1 to: nArgs
          do: { |i| frame put: (arguments at: i) at: i }.
        let context = InterpreterContext
                          sender: $context
                          receiver: context receiver
                          theMethod: block
                          frameContext: context
                          frame: frame
                          returnBlock: context returnBlock.
        { AstInterpreter eval: block body with: context }
            finally: { context invalidate } !
end

-- Used to pass process and context through host frames by visitSend
define $process
    False!
define $context
    False!

class AstInterpreter { context process }
    is AstVisitor

    direct method eval: ast inEnv: env
        self
            eval: ast
            with: (InterpreterContext new: env frame size)
            in: Process new!

    direct method eval: ast with: context
        self
            eval: ast
            with: context
            in: $process!

    direct method eval: ast with: context in: process
        ast visitBy: (self
                          context: context
                          process: process)!

    direct method evalDefine: body frameSize: frameSize
        let context = InterpreterContext
                          new: frameSize
                          returnBlock: { |value| return value }.
        { self eval: body with: context in: Process new }
            finally: { context invalidate } !

    direct method invokeMethod: astMethod on: receiver with: arguments
        let frame = Array new: astMethod frameSize.
        let nArgs = arguments size.
        astMethod argumentCount is nArgs
            ifFalse: { Error raise: "Self-hosted method argument count mismatch!" }.
        1 to: nArgs
          do: { |i| frame put: (arguments at: i) at: i }.
        let context = InterpreterContext
                          sender: $context
                          receiver: receiver
                          theMethod: astMethod
                          frameContext: $context
                          frame: frame
                          returnBlock: { |value| return value }.
        { AstInterpreter eval: astMethod body with: context }
            finally: { context invalidate } !

    method visitTypecheck: aNode
        let value = aNode value visitBy: self.
        let type = aNode type visitBy: self.
        type typecheck: value!

    method visitConstant: aConstant
        aConstant value!

    method visitArray: anArray
        let new = Array new: (anArray entries size).
        anArray entries
            doWithIndex: { |each index|
                           new put: (each visitBy: self) at: index }.
        new!

    method visitRecord: aRecord
        aRecord name
            sendTo: Record
            with: (aRecord entries
                       collect: { |each| each visitBy: self })!

    method visitDictionary: aDictionary
        let theDictionary = Dictionary new: (aDictionary entries size).
        aDictionary entries
            do: { |each|
                  -- Note order of evaluation!
                  let key = each key visitBy: self.
                  theDictionary
                      put: (each value visitBy: self)
                      at: key }.
        theDictionary!

    method visitGlobal: aGlobal
        aGlobal value!

    method visitIs: anIs
        (anIs left visitBy: self) is (anIs right visitBy: self)!

    method visitSeq: aSeq
        aSeq first visitBy: self.
        aSeq then visitBy: self!

    method visitReturn: aReturn
        context returnBlock value: (aReturn value visitBy: self)!

    method visitSend: aSend
        let selector = aSend selector.
        let object = aSend receiver visitBy: self.
        let arguments = aSend arguments collect: { |arg| arg visitBy: self }.
        let $context = context.
        let $process = process.
        -- Debug println: "<- {selector}".
        { selector sendTo: object with: arguments }
            on: DoesNotUnderstand
            do: { |ex|
                  -- Add the source location to the error.
                  (object is ex receiver and: selector == ex selector)
                      ifTrue: { DoesNotUnderstand
                                    raise: selector
                                    with: arguments
                                    on: object
                                    source: aSend source
                                    context: context }} !

    method visitComment: aComment
        aComment value visitBy: self!

    method visitBlock: aBlock
        -- Debug println: "\nblock args: {aBlock argumentCount}, size: {aBlock frameSize}".
        AstBlockClosure
            context: context
            block: aBlock!

    method visitSelf: aSelf
        context receiver!

    method visitSlotRef: aSlotRef
        context receiver __atSlot: aSlotRef slot index - 1!

    method visitSlotSet: aSlotSet
        context receiver
            __put: (aSlotSet value visitBy: self)
            __atSlot: aSlotSet slot index - 1!

    method visitBindLexical: aBind
        context
            put: (aBind value visitBy: self)
            at: aBind variable index
            inFrame: 0.
        aBind body visitBy: self!

    method visitLexicalRef: aRef
        -- Debug println: "ref: {aRef variable}".
        context
            at: aRef variable index
            inFrame: aRef frameOffset!

    method visitLexicalSet: aSet
        -- Debug println: "set: {aSet variable}".
        context
            put: (aSet value visitBy: self)
            at: aSet variable index
            inFrame: aSet frameOffset!
end
