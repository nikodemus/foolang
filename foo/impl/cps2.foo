import lib.assert.Assert
import impl.parser.Parser

class Set { dict }
    is Object
    direct method new
        self dict: Dictionary new!
    direct method with: node
        let new = self new.
        new add: node.
        new!
    method add: node
        let old = dict at: node.
        dict put: node at: node.
        old is False!
    method remove: node
        dict remove: node!
    method size
        dict size!
    method isEmpty
        dict isEmpty!
    method isOnly: node
        dict size is 1
            ifTrue: { (dict values first) is node }
            ifFalse: { False }!
    method replace: node1 with: node2
        dict doKeys: { |each|
                       each replace: node1 with: node2 }!
    method do: block
        dict values do: block!
end


class Worklist { list dict }
    direct method new
        self list: List new
             dict: Dictionary new!
    method push: thing
        dict at: thing
             ifNonePut: { list push: thing.
                          thing }!
    method pushAll: aList
        aList do: { |each| self push: each }!
    method pop
        let thing = list pop.
        dict remove: thing.
        thing!
    method isEmpty
        list isEmpty!
end


class ContinuationKind { name visit }
    method visit: node by: visitor
        visit sendTo: visitor with: [node]!
end

define NONE ContinuationKind name: "None" visit: #visitNoContinuation:!
define ENTRY ContinuationKind name: "Entry" visit: #visitEntryContinuation:!
define EXIT ContinuationKind name: "Exit" visit: #visitExitContinuation:!
define CALL ContinuationKind name: "Call" visit: #visitCallContinuation:!
define SEND ContinuationKind name: "Send" visit: #visitSendContinuation:!

class Continuation { _id::Integer
                     kind::ContinuationKind
                     params::Array
                     args::Array
                     uses::Set }
    is Object


    direct method id: id kind: kind params: params args: args
        let new = self _id: id
                       kind: kind
                       params: params
                       args: args
                       uses: Set new.
        params do: { |each| each defs add: new }.
        args do: { |each| each uses add: new }.
        new!


    method replace: node1 with: node2
        node1 uses remove: self.
        node2 uses add: self.
        args doWithIndex: { |each index|
                            each is node1
                                ifTrue: { args put: node2 at: index  } }!


    method replaceArgsFrom: other
        args do: { |each| each uses remove: self }.
        args = other args.
        args do: { |each|
                   each uses add: self.
                   each uses remove: other }!


    method unlink
        self uses replace: self with: args first!


    method printName
        kind is ENTRY
            => { return kind name }.
        kind is EXIT
            => { return kind name }.
        "{kind name}_{_id}"!


    method displayOn: stream
        stream print: "#<Continuation {self printName} params: {params} args: {args}>"!


    method visitBy: visitor
        kind visit: self by: visitor!
end

interface Node
    method visitBy: visitor
        -- Visitors interested in nodes can hook
        -- up to #visitNodeBy: to get the more exact
        -- info.
        visitor visitNode: self!
end

class Parameter { id::Integer
                  defs::Set
                  uses::Set }
    is Node
    direct method id: id
        self id: id
             defs: Set new
             uses: Set new!
    method printName
        "${id}"!
    method toString
        "#<Parameter {id}>"!
    method visitNodeBy: visitor
        visitor visitParameterNode: self!
end


class Discard { id::Integer
                defs::Set}
    is Node
    direct method id: id
        self id: id
             defs: Set new!
    method printName
        "_:{id}"!
    method toString
        "#<Discard {id}>"!
    method visitNodeBy: visitor
        visitor visitDiscardNode: self!
end


class Constant { id::Integer
                 uses::Set
                 value }
    is Node
    direct method id: id value: value
        self id: id
             uses: Set new
             value: value!
    method toString
        "#<Constant {self printName}>"!
    method printName
        value displayString!
    method visitNodeBy: visitor
        visitor visitConstantNode: self!
end

class Variable { id::Integer
                 name::String
                 defs::Set
                 uses::Set }
    is Node
    direct method id: id name: name
        self id: id
             name: name
             defs: Set new
             uses: Set new!
    method printName
        "{name}:{id}"!
    method visitNodeBy: visitor
        visitor visitVariableNode: self!
end

class Global { id::Integer
               name::String
               uses::Set
               definition }
    is Node
    direct method id: id name: name
        self id: id
             name: name
             uses: Set new
             definition: False!
    method printName
        "{name}:G"!
    method visitNodeBy: visitor
        visitor visitGlobalNode: self!
end

define NO_CONTINUATION
    -- ID 0 is a convenient error marker in case
    -- we try to index a bitset with this.
    Continuation
        id: 0
        kind: NONE
        params: []
        args: []!

class CpsGraph { entry::Continuation
                 exit::Continuation
                 lastId::Integer
                 constants::Dictionary
                 globals::Dictionary
                 selectors::Dictionary
                 continuations::List }

    direct method new
        -- We build the graph with the real exit node
        -- ready made: conversion requires a CC.
        --
        -- id=1 is reserved for entry.
        --
        -- Entry node gets replaced when we're done.
        let exitValue = Parameter id: 3
                                  defs: Set new
                                  uses: Set new.
        let exit = Continuation
                       id: 2
                       kind: EXIT
                       params: [exitValue]
                       args: [exitValue].
        self
            entry: NO_CONTINUATION
            exit: exit
            lastId: 2
            constants: Dictionary new
            globals: Dictionary new
            selectors: Dictionary new
            continuations: (List with: exit)!


    method doContinuations: block
        continuations do: block!


    method cleanup
        continuations = continuations
            reject: { |each| each uses isEmpty }.
        self!


    method entry: cont
        -- We create a separate entry continuation for clarity.
        entry is NO_CONTINUATION
            ifTrue: { entry = self makeContinuation: ENTRY
                                   params: []
                                   args: [cont] }
            ifFalse: { Error raise: "CpsGraph already has an entry!" }!


    method makeContinuation: kind params: params args: args
        let cont = Continuation id: self nextId
                                kind: kind
                                params: params
                                args: args.
        continuations push: cont.
        cont!


    method makeVariable: name
        Variable
            id: self nextId
            name: name!


    method makeParameter
        Parameter id: self nextId!


    method makeDiscard
        Discard id: self nextId!


    method ensureConstant: value
        constants
            at: value
            ifNonePut: { Constant
                             id: self nextId
                             value: value }!

    method ensureGlobal: name
        globals
            at: name
            ifNonePut: { Global
                             id: self nextId
                             name: name }!


    method ensureSelector: name
        selectors
            at: name
            ifNonePut: { self ensureConstant: name }!


    method call: target with: value
        self makeContinuation: CALL
             params: []
             args: [target, value]!


    method bind: variable in: target
        self makeContinuation: CALL
             params: [variable]
             args: [target]!

    method send: selector to: recv withArguments: args continuation: cc
        self makeContinuation: SEND
             params: []
             args: ([cc, recv, selector] append: args)!


    method block: body vars: vars continuation: cc
        self makeContinuation: CALL
             params: ([cc] append: vars)
             args: [body]!


    method nextId
        lastId = lastId + 1!
end

class CpsOptimizer { graph worklist }

    direct method optimize: graph
        (self graph: graph
              worklist: Worklist new)
        optimize!


    method optimize
        graph doContinuations: { |each| worklist push: each }.
        { worklist isEmpty }
            whileFalse: { worklist pop visitBy: self }.
        graph cleanup!


    method inline: target in: continuation
        continuation args rest
            with: target params
            do: { |arg param|
                  param uses
                      replace: param
                      with: arg }.
        continuation replaceArgsFrom: target.
        target unlink.
        worklist pushAll: continuation uses.
        worklist push: continuation!


    method tryInlineSuccessorOf: continuation
        let args = continuation args.
        let target = args first.
        -- Inline unique call.
        (Continuation includes: target)
            => { (target kind is CALL)
                     => { (target uses isOnly: continuation)
                              => { self inline: target in: continuation } } }!


    method visitEntryContinuation: entry
        self tryInlineSuccessorOf: entry!


    method visitCallContinuation: call
        self tryInlineSuccessorOf: call!


    method visitExitContinuation: exit
        False!

    method visitSendContinuation: send
        False!

end

class CpsConverter { graph var next }

    direct method new
        self graph: CpsGraph new
             var: False
             next: False!


    direct method convert: syntax
        let converter = self new.
        converter graph
            entry: (syntax visitBy: converter
                           with: converter graph exit).
        CpsOptimizer optimize: converter graph!


    method bindVariable: var
        CpsConverter
            graph: graph
            var: var
            next: self!


    method bindVariables: vars
        let converter = self.
        vars do: { |each|
                   converter = converter bindVariable: each }.
        converter!


    method findBinding: name
        var is False
            ifTrue: { return graph ensureGlobal: name }.
        var name == name
            ifTrue: { var }
            ifFalse: { self next findBinding: name }!


    method visitBlock: syntax with: cc
        let blockReturn = graph makeParameter.
        let blockVars = syntax parameters
                            collect: { |each| graph makeVariable: each name }.
        let blockBody = syntax body
                            visitBy: (self bindVariables: blockVars)
                            with: blockReturn.
        let blockEntry = graph block: blockBody
                               vars: blockVars
                               continuation: blockReturn.
        graph call: cc with: blockEntry!

    method visitLet: syntax with: cc
        let var = graph makeVariable: syntax variable name.
        let body = syntax body
                       visitBy: (self bindVariable: var)
                       with: cc.
        let bind = graph bind: var in: body.
        syntax value visitBy: self with: bind!


    method visitLiteral: syntax with: cc
        graph
            call: cc
            with: (graph ensureConstant: syntax value)!


    method visitSend: syntax with: cc
        let recv = graph makeParameter.
        let argParams = syntax arguments collect: { |a| graph makeParameter }.
        let next = graph
                       send: (graph ensureSelector: syntax selector name)
                       to: recv
                       withArguments: argParams
                       continuation: cc.
        syntax arguments reverse
            with: argParams reverse
            do: { |argSyntax param|
                  let bind = graph bind: param in: next.
                  next = argSyntax visitBy: self with: bind }.
        let recvBind = graph bind: recv in: next.
        syntax receiver visitBy: self with: recvBind!


    method visitSeq: syntax with: cc
        let then = syntax then visitBy: self with: cc.
        let discard = graph bind: graph makeDiscard in: then.
        syntax first visitBy: self with: discard!


    method visitVariable: syntax with: cc
        graph
            call: cc
            with: (self findBinding: syntax name)!
end

class CpsPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output newline.
        visitor visit: graph entry!


    method visit: other
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitCallArgs: args
        let target = args at: 1.
        output
            ; print: "    "
            ; print: target printName
            ; print: "(".
        2 to: args size
          do: { |index|
                output print: (args at: index) printName }.
        output println: ")".
        args do: { |each| self visit: each }.
        self visit: target!


    method visitCallContinuation: aCall
        output
            ; print: aCall printName
            ; print: "(".
        aCall params
            do: { |each|
                  output print: each printName }
            interleaving: { output print: ", " }.
        output println: "):".
        self visitCallArgs: aCall args!


    method visitEntryContinuation: anEntry
        output
            ; print: anEntry printName
            ; println: "():".
        self visitCallArgs: anEntry args!


    method visitSendContinuation: aSend
        let args = aSend args.
        output
            ; print: aSend printName
            ; println: "():"
            ; print: "    "
            ; print: args first printName
            ; print: "("
            ; print: args second printName
            ; print: " #"
            ; print: args third value.
        (args from: 4 to: args size)
             do: { |arg|
                   output
                       ; print: " "
                       ; print: arg printName }.
        output println: ")".
        self visit: args first!


    method visitExitContinuation: _
        -- We don't print the exit.
        False!

    method visitNode: _
        -- We see nodes from visiting call args, but
        -- don't need to print them separately: the arg
        -- to pick up continuations as arguments.
        False!
end

class TestCPS { assert }
    is TestSuite

    method convert: source
        let syntax = Parser parseExpression: source.
        CpsConverter convert: syntax!

    method test_convert_constant_integer
        let cps = self convert: "123".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Exit(123)
"!


    method test_convert_global
        let cps = self convert: "ThisIsGlobal".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Exit(ThisIsGlobal:G)
"!


    method test_convert_let
        let cps = self convert: "let x = 87. x".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Exit(87)
"!


    method test_convert_send
        let cps = self convert: "X some: 12 message: 97".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Send_7()
Send_7():
    Exit(X:G #some:message: 12 97)
"!


    method test_convert_seq
        let cps = self convert: "X some: 12 message: 97. Y + Z".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Send_19()
Send_19():
    Call_14(X:G #some:message: 12 97)
Call_14(_:13):
    Send_6()
Send_6():
    Exit(Y:G #+ Z:G)
"!


    method test_convert_arity_0_block
        let cps = self convert: "\{ 421 }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Exit(Call_6)
Call_6($3):
    $3(421)
"!


    method test_convert_arity_3_block
        let cps = self convert: "\{ |a b c| a + b + c }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Exit(Call_21)
Call_21($3, a:4, b:5, c:6):
    Send_16()
Send_16():
    Call_13(a:4 #+ b:5)
Call_13($7):
    Send_10()
Send_10():
    $3($7 #+ c:6)
"!


end

class Main {}
    direct method run: command in: system
        TestCPS runTests: (Assert reportingTo: system output)
                in: system!
end
