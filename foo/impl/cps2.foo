import lib.assert.Assert
import impl.parser.Parser


class Set { dict }
    is Object

    direct method new
        self dict: Dictionary new!


    direct method with: node
        let new = self new.
        new add: node.
        new!


    method add: node
        let old = dict at: node.
        dict put: node at: node.
        old is False!


    method remove: node
        dict remove: node!


    method collect: block
        dict keys collect: block!


    method size
        dict size!


    method isEmpty
        dict isEmpty!


    method isOnly: node
        dict size is 1
            ifTrue: { (dict values first) is node }
            ifFalse: { False }!


    method replaceUses: node1 with: node2
        dict doKeys: { |each|
                       each replaceUses: node1 with: node2 }!


    method do: block
        dict values do: block!
end


class OpMap { list }
    is Object

    direct method new
        self list: List new!


    method at: op and: args ifNonePut: block
        list do: { |each|
                   each op is op
                       => { (each args == args)
                                => { return each } } }.
        let new = block value.
        list push: new.
        new!
end


class Worklist { list dict }
    is Object

    direct method new
        self list: List new
             dict: Dictionary new!


    method push: thing
        dict at: thing
             ifNonePut: { list push: thing.
                          thing }!


    method pushAll: aList
        aList do: { |each| self push: each }!


    method pop
        let thing = list pop.
        dict remove: thing.
        thing!


    method isEmpty
        list isEmpty!
end


interface Expression
    is Object

    method isUnused
        self uses isEmpty!


    method addUse: use
        self uses add: use!


    method removeUse: use
        self uses remove: use!


    method replaceUsesWith: expr
        self uses do: { |each| each replaceUses: self with: expr }!


    method toString
        "#<{self classOf name} {self printName}>"!


    required method uses
    required method printName
end


class Constant { id::Integer
                 value
                 uses::Set }
    is Expression


    direct method id: id value: value
        self id: id
             value: value
             uses: Set new!


    method printName
        value displayString!


    method visitBy: visitor
        visitor visitConstant: self!
end

class CpsSelector { name }
    method displayString
        "#{name}"!
end

class Variable { id::Integer
                 name
                 defs::Set
                 uses::Set }
    is Expression

    direct method id: id
        self id: id
             name: False
             defs: Set new
             uses: Set new!


    direct method id: id name: name
        self id: id
             name: name
             defs: Set new
             uses: Set new!


    method addDef: def
        defs add: def!


    method removeDef: def
        defs remove: def!


    method printName
        name is False
            ifTrue: { "$var:{id}" }
            ifFalse: { "{name}:{id}" }!


    method visitBy: visitor
        visitor visitVariable: self!
end


class Global { id::Integer
               name::String
               uses::Set }
    is Expression

    direct method id: id name: name
        self id: id
             name: name
             uses: Set new!


    method printName
        "{name}:Global"!


    method visitBy: visitor
        visitor visitGlobal: self!
end



class PrimitiveOperation { name }
end

define FIND_METHOD PrimitiveOperation name: "findMethod"!
define SELECT PrimitiveOperation name: "select"!

class Operation { id::Integer
                  op::PrimitiveOperation
                  args::Array
                  uses::Set }
    is Expression

    direct method id: id op: op args: args
        self id: id
             op: op
             args: args
             uses: Set new!

    method addUse: use
        uses add: use.
        args do: { |each| each addUse: use }!


    method removeUse: use
        uses remove: use.
        args do: { |each| each removeUse: use }!


    method printName
        StringOutput
            with: { |out|
                    out
                        ; print: op name
                        ; print: ":"
                        ; print: id
                        ; print: "(".
                    args
                        do: { |each| out print: each printName }
                        interleaving: { out print: ", " }.
                    out print: ")" }!


    method visitBy: visitor
        visitor visitOperation: self!
end


class Continuation { id::Integer
                     name
                     params::Array
                     target::Expression
                     args::Array
                     uses::Set }
    is Expression

    direct method id: id name: name params: params target: target args: args
        let new = self id: id
                       name: name
                       params: params
                       target: target
                       args: args asArray
                       uses: Set new.
        params do: { |each| each addDef: new }.
        target addUse: new.
        args do: { |each| each addUse: new }.
        new!


    method name: new
        name = new!


    method simplify
        { self hasUniqueTarget }
            whileTrue: { self inlineUniqueTarget }.
        self!


    method hasUniqueTarget
        (Continuation includes: target)
            ifTrue: { target uses isOnly: self }!


    method inlineUniqueTarget
        self args
            with: target params
            do: { |arg param|
                  param replaceUsesWith: arg }.
        self replaceArgsFrom: target.
        target unlink!


    method replaceUses: expr1 with: expr2
        expr1 removeUse: self.
        expr2 addUse: self.
        target is expr1
            ifTrue: { target = expr2 }.
        args replace: expr1 with: expr2!


    method replaceArgsFrom: other
        -- This is more convenient than #args:, since
        -- we usually want to copy the array!
        args do: { |each| each removeUse: self }.
        args = other args copy asArray.
        args do: { |each| each addUse: self }!


    method replaceParamsFrom: other
        -- This is more convenient than #params:, since
        -- we usually want to copy the array!
        params do: { |each| each removeDef: self }.
        params = other params copy.
        params do: { |each| each addDef: self }!


    method removeParams
        params do: { |each| each removeDef: self }.
        params = []!


    method removeArgs
        args do: { |each| each removeUse: self }.
        args = []!


    method addParams: new
        new do: { |each| each addDef: self }.
        params = params append: new!


    method addArgs: new
        new do: { |each| each addUse: self }.
        args = args append: new!


    method target: new
        -- No copy needed here, so #target: is the way to go.
        target removeUse: self.
        target = new.
        target addUse: self!


    method unlink
        self target removeUse: self.
        self args do: { |each| each removeUse: self }.
        self params do: { |each| each removeDef: self }.
        self replaceUsesWith: target!


    method printName
        name is False
            ifTrue: { "$cont:{id}" }
            ifFalse: { "{name}:{id}" }!


    method toString
        "#<Continuation {self printName} -> {target printName}>"!


    method visitBy: visitor
        visitor visitContinuation: self!
end


class CpsGraph { entry::Continuation
                 exit::Variable
                 lastId::Integer
                 operations::OpMap
                 constants::Dictionary
                 globals::Dictionary
                 selectors::Dictionary
                 continuations::List }
    is Object

    direct method new
        -- Entry node just binds the exit continuation, the
        -- initial target of entry is a placeholder that
        -- gets replaced.
        let placeholder = Variable
                           id: 0
                           name: "$<<PLACEHOLDER>>".
        let exit = Variable id: 2
                            name: "$return".
        let entry = Continuation id: 1
                                 name: "$entry"
                                 params: [exit]
                                 target: placeholder
                                 args: []
                                 uses: Set new.
        let graph = self
                        entry: entry
                        exit: exit
                        lastId: 2
                        operations: OpMap new
                        constants: Dictionary new
                        globals: Dictionary new
                        selectors: Dictionary new
                        continuations: (List with: entry).
        entry addUse: graph.
        graph!


    method doContinuations: block
        continuations do: block!


    method cleanup
        constants = constants reject: #isUnused.
        continuations = continuations reject: #isUnused.
        globals = globals reject: #isUnused.
        self!


    method entry: target
        entry target: target.
        entry simplify!


    method continuation: name params: params target: target args: args
        let cont = Continuation id: self nextId
                                name: name
                                params: params
                                target: target
                                args: args.
        continuations push: cont.
        cont!


    method makeVariable: name
        Variable
            id: self nextId
            name: name!


    method makeTemporary
        Variable
            id: self nextId!


    method ensureConstant: value
        constants
            at: value
            ifNonePut: { Constant
                             id: self nextId
                             value: value }!

    method ensureGlobal: name
        globals
            at: name
            ifNonePut: { Global
                             id: self nextId
                             name: name }!


    method ensureSelector: name
        selectors
            at: name
            ifNonePut: { self ensureConstant: (CpsSelector name: name) }!



    method ensureOperation: op args: args
        operations
            at: op
            and: args
            ifNonePut: { Operation
                             id: self nextId
                             op: op
                             args: args }!


    method nextId
        lastId = lastId + 1!
end


class CpsConverter { graph var next }

    direct method new
        self graph: CpsGraph new
             var: False
             next: False!


    direct method convert: syntax
        let converter = self new.
        converter graph
            entry: (syntax visitBy: converter
                           with: converter graph exit).
        converter graph!


    method bindVariable: var
        CpsConverter
            graph: graph
            var: var
            next: self!


    method bindVariables: vars
        let converter = self.
        vars do: { |each|
                   converter = converter bindVariable: each }.
        converter!


    method findBinding: name
        var is False
            ifTrue: { return graph ensureGlobal: name }.
        var name == name
            ifTrue: { var }
            ifFalse: { self next findBinding: name }!


    method visitBlock: syntax with: cc
        let blockReturn = graph makeVariable: "$ret".
        let blockVars = syntax parameters
                            collect: { |each| graph makeVariable: each name }.
        let block = syntax body
                        visitBy: (self bindVariables: blockVars)
                        with: blockReturn.
        block name: "$block".
        block addParams: (blockVars append: [blockReturn]).
        graph continuation: "$makeClosure"
              params: []
              target: cc
              args: [block simplify]!


    method visitLet: syntax with: cc
        let var = graph makeVariable: syntax variable name.
        let body = syntax body
                       visitBy: (self bindVariable: var)
                       with: cc.
        let bind = graph continuation: "$let"
                         params: [var]
                         target: body
                         args: [].
        (syntax value visitBy: self with: bind simplify)
            simplify!


    method visitLiteral: syntax with: cc
        let const = graph ensureConstant: syntax value.
        (graph continuation: "$const_ref"
              params: []
              target: cc
              args: [const])
        simplify!


    method visitSend: syntax with: cc
        let recv = graph makeVariable: "$recv".
        let args = syntax arguments
                       collect: { |a| graph makeVariable: "$arg" }
                       as: Array.
        let selector = graph ensureSelector: syntax selector name.
        let methodFunction = graph ensureOperation: FIND_METHOD
                                   args: [recv, selector].
        let next = graph continuation: "$send"
                         params: []
                         target: methodFunction
                         args: (args append: [cc]).
        syntax arguments reverse
            with: args reverse
            do: { |syntaxArg var|
                  let bind = graph continuation: "$bind_arg"
                                   params: [var]
                                   target: next
                                   args: [].
                  next = (syntaxArg visitBy: self with: bind)
                             simplify }.
        let recvBind = graph continuation: "$bind_recv"
                             params: [recv]
                             target: next
                             args: [].
        syntax receiver visitBy: self with: recvBind simplify!


    method visitSeq: syntax with: cc
        let then = syntax then visitBy: self with: cc.
        let discard = graph continuation: "$seq"
                            params: [graph makeVariable: "$ignore"]
                            target: then
                            args: [].
        syntax first visitBy: self with: discard simplify!


    method visitVariable: syntax with: cc
        graph continuation: "$var_ref"
              params: []
              target: cc
              args: [self findBinding: syntax name]!
end

class CpsPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output newline.
        visitor visit: graph entry!


    method visit: other
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitContinuation: aCont
        output
            ; print: aCont printName
            ; print: "(".
        aCont params
            do: { |each| output print: each printName }
            interleaving: { output print: ", " }.
        output println: "):".
        output
            ; print: "    "
            ; print: aCont target printName
            ; print: "(".
        aCont args
            do: { |arg| output print: arg printName }
            interleaving: { output print: ", " }.
        output println: ")".
        aCont args do: { |each| self visit: each }.
        self visit: aCont target!


    method visitConstant: _
        False!


    method visitVariable: _
        False!


    method visitGlobal: _
        False!


    method visitOperation: anOp
        anOp args do: { |each| self visit: each }!
end


class TestCPS { assert }
    is TestSuite

    method convert: source
        let syntax = Parser parseExpression: source.
        CpsConverter convert: syntax!

    method test_convert_constant_integer
        let cps = self convert: "123".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    $return:2(123)
"!


    method test_convert_global
        let cps = self convert: "X".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    $return:2(X:Global)
"!


    method test_convert_let
        let cps = self convert: "let x = 87. x".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    $return:2(87)
"!


    method test_convert_send
        let cps = self convert: "X some: 12 message: 97".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    findMethod:7($recv:3, #some:message:)(12, 97, $return:2)
"!


    method test_convert_seq
        let cps = self convert: "X some: 12 message: 97. Y + Z".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    findMethod:20($recv:16, #some:message:)(12, 97, $seq:15)
$seq:15($ignore:14):
    findMethod:6($recv:3, #+)(Z:Global, $return:2)
"!


    method test_convert_arity_0_block
        let cps = self convert: "\{ 421 }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    $return:2($block:5)
$block:5($ret:3):
    $ret:3(421)
"!


    method test_convert_arity_3_block
        let cps = self convert: "\{ |a b c| a + b + c }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    $return:2($block:22)
$block:22(a:4, b:5, c:6, $ret:3):
    findMethod:17($recv:15, #+)(b:5, $bind_recv:14)
$bind_recv:14($recv:7):
    findMethod:10($recv:7, #+)(c:6, $ret:3)
"!


end

class Main {}
    direct method run: command in: system
        TestCPS runTests: (Assert reportingTo: system output)
                in: system!
end
