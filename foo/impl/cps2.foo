import lib.assert.Assert
import impl.parser.Parser

class Set { dict }
    is Object
    direct method new
        self dict: Dictionary new!
    direct method with: node
        let new = self new.
        new add: node.
        new!
    method add: node
        dict put: node at: node!
    method remove: node
        dict remove: node!
    method size
        dict size!
    method isEmpty
        dict isEmpty!
    method isOnly: node
        dict size is 1
            ifTrue: { (dict values first) is node }
            ifFalse: { False }!
    method replace: node1 with: node2
        dict doKeys: { |each|
                       each replace: node1 with: node2 }!
    method do: block
        dict values do: block!
end

class ContinuationKind { name visit }
    method visit: node by: visitor
        visit sendTo: visitor with: [node]!
end

define NONE ContinuationKind name: "None" visit: #visitNoContinuation:!
define ENTRY ContinuationKind name: "Entry" visit: #visitEntryContinuation:!
define EXIT ContinuationKind name: "Exit" visit: #visitExitContinuation:!
define CALL ContinuationKind name: "Call" visit: #visitCallContinuation:!

class Continuation { _id::Integer
                     kind::ContinuationKind
                     params::Array
                     args::Array
                     uses::Set }
    direct method id: id kind: kind params: params args: args
        let new = self _id: id
                       kind: kind
                       params: params
                       args: args
                       uses: Set new.
        params do: { |each| each defs add: new }.
        args do: { |each| each uses add: new }.
        new!
    method printName
        kind is ENTRY
            => { return kind name }.
        kind is EXIT
            => { return kind name }.
        "{kind name}_{_id}"!
    method visitBy: visitor
        kind visit: self by: visitor!
end

class Parameter { id::Integer
                  defs::Set
                  uses::Set }
    method visitBy: visitor
        visitor visitParameter: self!
end

class Constant { id::Integer
                 uses::Set
                 value }
    direct method id: id value: value
        self id: id
             uses: Set new
             value: value!
    method printName
        value displayString!
end

class Variable { id::Integer
                 name::String
                 defs::Set
                 uses::Set }
    direct method id: id name: name
        self id: id
             name: name
             defs: Set new
             uses: Set new!
    method printName
        "{name}:{id}"!
end

class Global { id::Integer
               name::String
               uses::Set
               definition }
    direct method id: id name: name
        self id: id
             name: name
             uses: Set new
             definition: False!
    method printName
        "{name}:G"!
end

define NO_CONTINUATION
    -- ID 0 is a convenient error marker in case
    -- we try to index a bitset with this.
    Continuation
        id: 0
        kind: NONE
        params: []
        args: []!

class CpsGraph { entry::Continuation
                 exit::Continuation
                 lastId::Integer
                 constants::Dictionary
                 globals::Dictionary }

    direct method new
        -- We build the graph with the real exit node
        -- ready made: conversion requires a CC.
        --
        -- id=1 is reserved for entry.
        --
        -- Entry node gets replaced when we're done.
        let exitValue = Parameter id: 3
                                  defs: Set new
                                  uses: Set new.
        let exit = Continuation
                       id: 2
                       kind: EXIT
                       params: [exitValue]
                       args: [exitValue].
        self
            entry: NO_CONTINUATION
            exit: exit
            lastId: 2
            constants: Dictionary new
            globals: Dictionary new!


    method entry: cont
        -- We create a separate entry continuation for clarity.
        entry is NO_CONTINUATION
            ifTrue: { entry = Continuation
                          id: 1
                          kind: ENTRY
                          params: []
                          args: [cont] }
            ifFalse: { Error raise: "CpsGraph already has an entry!" }!


    method call: target with: value
        Continuation
            id: self nextId
            kind: CALL
            params: []
            args: [target, value]!


    method makeVariable: name
        Variable
            id: self nextId
            name: name!


    method ensureConstant: value
        constants
            at: value
            ifNonePut: { Constant
                             id: self nextId
                             value: value }!

    method ensureGlobal: name
        globals
            at: name
            ifNonePut: { Global
                             id: self nextId
                             name: name }!


    method bind: variable in: target
        Continuation
            id: self nextId
            kind: CALL
            params: [variable]
            args: [target]!


    method nextId
        lastId = lastId + 1!
end

class CpsConverter { graph var next }

    direct method new
        self graph: CpsGraph new
             var: False
             next: False!


    direct method convert: syntax
        let converter = self new.
        converter graph
            entry: (syntax visitBy: converter
                           with: converter graph exit).
        converter graph!


    method bindVariable: var
        CpsConverter
            graph: graph
            var: var
            next: self!


    method findBinding: name
        var is False
            ifTrue: { return graph ensureGlobal: name }.
        var name == name
            ifTrue: { var }
            ifFalse: { self next findBinding: name }!


    method visitLet: syntax with: cc
        let var = graph makeVariable: syntax variable name.
        let body = syntax body
                       visitBy: (self bindVariable: var)
                       with: cc.
        let bind = graph bind: var in: body.
        syntax value visitBy: self with: bind!


    method visitLiteral: syntax with: cc
        graph
            call: cc
            with: (graph ensureConstant: syntax value)!


    method visitVariable: syntax with: cc
        graph
            call: cc
            with: (self findBinding: syntax name)!
end

class CpsPrinter { output }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!

    direct method print: graph to: output
        output newline.
        graph entry
            visitBy: (self output: output)!

    method visitCallArgs: args
        let target = args at: 1.
        output
            ; print: "    "
            ; print: target printName
            ; print: "(".
        2 to: args size
          do: { |index|
                output print: (args at: index) printName }.
        output println: ")".
        target visitBy: self!

    method visitCallContinuation: aCall
        output
            ; print: aCall printName
            ; print: "(".
        aCall params
            do: { |each|
                  output print: each printName }
            interleaving: { output print: ", " }.
        output println: "):".
        self visitCallArgs: aCall args!

    method visitEntryContinuation: anEntry
        output
            ; print: anEntry printName
            ; println: "():".
        self visitCallArgs: anEntry args!

    method visitExitContinuation: _
        -- We don't print the exit.
        False!
end

class TestCPS { assert }
    is TestSuite

    method convert: source
        let syntax = Parser parseExpression: source.
        CpsConverter convert: syntax!

    method test_convert_constant_integer
        let cps = self convert: "123".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Call_4()
Call_4():
    Exit(123)
"!


    method test_convert_global
        let cps = self convert: "ThisIsGlobal".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Call_4()
Call_4():
    Exit(ThisIsGlobal:G)
"!


    method test_convert_let
        let cps = self convert: "let x = 87. x".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Call_7()
Call_7():
    Call_5(87)
Call_5(x:3):
    Call_4()
Call_4():
    Exit(x:3)
"!


    method test_convert_send
        let cps = self convert: "X some: 12 message: 97".
        assert that: { CpsPrinter printToString: cps }
               equals: "
Entry():
    Call_1()
Call_1():
    Call_2(X:G, 12, 97)
Call_2($1, $2, $3):
    Send(Exit, $1 some: $2 message: 97)
"!

end

class Main {}
    direct method run: command in: system
        TestCPS runTests: (Assert reportingTo: system output)
                in: system!
end
