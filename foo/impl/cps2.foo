import lib.assert.Assert
import impl.parser.Parser


interface MethodDefinition
    method displayString
        "methodFunction({self home name}#{self name})"!


    method returnType
        False!


    method toString
        "#<{self classOf name} {self displayString}>"!
end


class TypecheckMethodDefinition { type home }
    is MethodDefinition


    method returnType
        type!


    method name
        "typecheck:"!
end


class BuiltinMethodDefinition { name home }
    is MethodDefinition

    direct method name: name
        self name: name
             home: False!


    method home: new
        (home is False)
            ifFalse: { Error raise: "BuiltinMethodDefinition already has a home: {self}" }.
        home= new!
end


class ClassDefinition { name ownClassDefinition methodDictionary }

    -- ClassDefinition itself is used as the ClassDefinition for Class.
    -- Clever, yes?
    direct method name
        "Class"!


    direct method classDefinition
        self!


    direct method name: name methods: methods
        let instanceMethodDictionary = Dictionary new.
        let directMethodDictionary = Dictionary new.
        let ownClassDefinition = self name: "{name} class"
                                      ownClassDefinition: ClassDefinition
                                      methodDictionary: directMethodDictionary.
        let classDefinition = self name: name
                                   ownClassDefinition: ownClassDefinition
                                   methodDictionary: instanceMethodDictionary.
        methods do: { |each|
                      each home: classDefinition.
                      instanceMethodDictionary put: each at: each name }.
        directMethodDictionary
            put: (TypecheckMethodDefinition
                      type: classDefinition
                      home: ownClassDefinition)
            at: "typecheck:".
        classDefinition!


    method classDefinition
        ownClassDefinition!


    method findMethod: name
        methodDictionary at: name!


    method displayString
        name!

    method toString
        name!
end


class Set { dict }
    is Object

    direct method new
        self dict: Dictionary new!


    direct method with: node
        let new = self new.
        new add: node.
        new!


    method add: node
        let old = dict at: node.
        dict put: node at: node.
        old is False!


    method remove: node
        dict remove: node!


    method collect: block
        dict keys collect: block!


    method size
        dict size!


    method isEmpty
        dict isEmpty!


    method isOnly: node
        dict size is 1
            ifTrue: { (dict values first) is node }
            ifFalse: { False }!


    method replaceUses: node1 with: node2
        dict doKeys: { |each|
                       (each is node1) not assert: "Replacement target is an immediate use".
                       each replaceUses: node1 with: node2 }!


    method do: block
        dict values do: block!
end


class OpMap { list }
    is Object

    direct method new
        self list: List new!


    method at: op and: args ifNonePut: block
        list do: { |each|
                   each op is op
                       => { (each args == args)
                                => { return each } } }.
        let new = block value.
        list push: new.
        new!


    method reject: block
        Self list: (list reject: block)!


    method do: block
        list do: block!
end


class Worklist { list dict }
    is Object

    direct method new
        self list: List new
             dict: Dictionary new!


    method push: thing
        dict at: thing
             ifNonePut: { list push: thing.
                          thing }!


    method pushAll: aList
        aList do: { |each| self push: each }!


    method pop
        let thing = list pop.
        dict remove: thing.
        thing!


    method isEmpty
        list isEmpty!
end


interface Expression
    is Object

    method isUnused
        self uses isEmpty!


    method isConstant
        False!


    method addUse: use
        self uses add: use!


    method removeUse: use
        self uses remove: use!


    method replaceUsesWith: expr
        self uses do: { |each| each replaceUses: self with: expr }!


    method toString
        "#<{self classOf name} {self printName}>"!


    required method uses
    required method printName
    required method replaceUses: expr1 with: expr2
end


class Constant { id::Integer
                 value
                 uses::Set }
    is Expression


    direct method id: id value: value
        self id: id
             value: value
             uses: Set new!


    method isConstant
        True!


    method printName
        value displayString!


    method replaceUses: expr1 with: expr2
        Error raise: "Constant#replaceUses:with: is invalid"!


    method visitBy: visitor
        visitor visitConstant: self!
end


class CpsSelector { name }
    method displayString
        "#{name}"!
end


class Global { id::Integer
               name::String
               uses::Set
               definition }
    is Expression

    direct method id: id name: name
        self id: id
             name: name
             uses: Set new
             definition: False!


    method definition: new::ClassDefinition
        definition = new!


    method hasClassDefinition
        (definition is False) not!


    method hasDefinition
        (definition is False) not!


    method classDefinition
        definition classDefinition!


    method replaceUses: expr1 with: expr2
        Error raise: "Global#replaceUses:with: is invalid"!


    method printName
        "{name}:Global"!


    method visitBy: visitor
        visitor visitGlobal: self!
end



class Variable { id::Integer
                 name
                 type
                 defs::Set
                 uses::Set }
    is Expression

    direct method id: id
        self id: id
             name: False
             type: False
             defs: Set new
             uses: Set new!


    direct method id: id name: name
        self id: id
             name: name
             type: False
             defs: Set new
             uses: Set new!


    method addDef: def
        defs add: def!


    method removeDef: def
        defs remove: def.
        (defs isEmpty and: uses isEmpty not)
            ifTrue: { Error raise: "Variable lost definitions while still being used."}!


    method replaceUses: expr1 with: expr2
        Error raise: "Variable#replaceUses:with: is invalid"!


    method type: new
        (type is new)
            ifTrue: { return False }.
        (type is False)
            ifFalse: { Error raise: "Variable already has a type: {self}. Old={type}, New={new}" }.
        type = new!


    method hasClassDefinition
        ClassDefinition includes: type!


    method classDefinition
        type!


    method hasDefinition
        -- TODO
        False!


    method printName
        name is False
            ifTrue: { "$var:{id}" }
            ifFalse: { "{name}:{id}" }!


    method visitBy: visitor
        visitor visitVariable: self!
end


interface PrimitiveOperation
end


class CLASS_OF {}
    is PrimitiveOperation

    direct method name
        "classOf"!


    direct method visit: operation by: visitor
        visitor visitClassOf: operation!
end


class FIND_METHOD {}
    is PrimitiveOperation

    direct method name
        "findMethod"!


    direct method visit: operation by: visitor
        visitor visitFindMethod: operation!
end


class SELECT {}
    is PrimitiveOperation

    direct method name
        "select"!

    direct method visit: operation by: visitor
        visitor visitSelect: operation!
end


class Operation { id::Integer
                  op
                  args::Array
                  uses::Set }
    is Expression

    direct method id: id op: op args: args
        let new = self id: id
                       op: op
                       args: args
                       uses: Set new.
        args do: { |each| each addUse: new }.
        new!


    method addUse: use
        uses add: use.
        args do: { |each| each addUse: use }!


    method printName
        StringOutput
            with: { |out|
                    out
                        ; print: op name
                        ; print: ":"
                        ; print: id
                        ; print: "(".
                    args
                        do: { |each| out print: each printName }
                        interleaving: { out print: ", " }.
                    out print: ")" }!


    method removeUse: use
        uses remove: use.
        args do: { |each| each removeUse: use }!


    method replaceUses: expr1 with: expr2
        expr1 removeUse: self.
        expr2 addUse: self.
        args = args replace: expr1 with: expr2!


    method simplifyIn: graph
        op simplify: self in: graph!


    method visitBy: visitor
        visitor visitOperation: self!
end


class Continuation { id::Integer
                     name
                     params::Array
                     target::Expression
                     args::Array
                     uses::Set }
    is Expression

    direct method id: id name: name params: params target: target args: args
        let new = self id: id
                       name: name
                       params: params
                       target: target
                       args: args asArray
                       uses: Set new.
        params do: { |each| each addDef: new }.
        target addUse: new.
        args do: { |each| each addUse: new }.
        new!


    method name: new
        name = new!


    method propagateConstantType: aConstant
        (target is aConstant)
            => { let value = aConstant value .
                 (MethodDefinition includes: value)
                     => { let returnType = value returnType.
                          (returnType is False) not
                              => { let succ = args last.
                                   (Continuation includes: succ)
                                       => { succ params first type: value returnType } } } }!


    method simplify
        { self hasUniqueTarget }
            whileTrue: { self inlineUniqueTarget }.
        self!


    method hasUniqueTarget
        (Continuation includes: target)
            ifTrue: { target uses isOnly: self }!


    method inlineUniqueTarget
        self args
            with: target params
            do: { |arg param|
                  param replaceUsesWith: arg }.
        self replaceArgsFrom: target.
        target unlink!


    method replaceUses: expr1 with: expr2
        expr1 removeUse: self.
        expr2 addUse: self.
        target is expr1
            ifTrue: { target = expr2 }.
        args replace: expr1 with: expr2!


    method replaceArgsFrom: other::Continuation
        -- This is more convenient than #args:, since
        -- we usually want to copy the array!
        args do: { |each| each removeUse: self }.
        args = other args copy asArray.
        args do: { |each| each addUse: self }!


    method replaceParamsFrom: other::Continuation
        -- This is more convenient than #params:, since
        -- we usually want to copy the array!
        params do: { |each| each removeDef: self }.
        params = other params copy.
        params do: { |each| each addDef: self }!


    method removeParams
        params do: { |each| each removeDef: self }.
        params = []!


    method removeArgs
        args do: { |each| each removeUse: self }.
        args = []!


    method addParams: new
        new do: { |each| each addDef: self }.
        params = params append: new!


    method addArgs: new
        new do: { |each| each addUse: self }.
        args = args append: new!


    method target: new
        -- No copy needed here, so #target: is the way to go.
        target removeUse: self.
        target = new.
        target addUse: self!


    method unlink
        self target removeUse: self.
        self args do: { |each| each removeUse: self }.
        self params do: { |each| each removeDef: self }.
        self replaceUsesWith: target!


    method printName
        name is False
            ifTrue: { "$cont:{id}" }
            ifFalse: { "{name}:{id}" }!


    method toString
        "#<Continuation {self printName} -> {target printName}>"!


    method visitBy: visitor
        visitor visitContinuation: self!
end


class CpsGraph { entry::Continuation
                 exit::Variable
                 lastId::Integer
                 operations::OpMap
                 constants::Dictionary
                 globals::Dictionary
                 selectors::Dictionary
                 continuations::List }
    is Object

    direct method new
        -- Entry node just binds the exit continuation, the
        -- initial target of entry is a placeholder that
        -- gets replaced.
        let placeholder = Variable
                           id: 0
                           name: "$<<PLACEHOLDER>>".
        let exit = Variable id: 2
                            name: "$return".
        let entry = Continuation id: 1
                                 name: "$entry"
                                 params: [exit]
                                 target: placeholder
                                 args: []
                                 uses: Set new.
        let graph = self
                        entry: entry
                        exit: exit
                        lastId: 2
                        operations: OpMap new
                        constants: Dictionary new
                        globals: Dictionary new
                        selectors: Dictionary new
                        continuations: (List with: entry).
        entry addUse: graph.
        graph!



    method cleanup
        continuations = continuations reject: #isUnused.
        operations = operations reject: #isUnused!

    method doExpressions: block
        continuations do: { |each| block value: each }.
        operations do: { |each| block value: each }!


    method optimize
        self cleanup.
        CpsOptimizer optimize: self.
        self cleanup.
        self!


    method entry: target
        entry target: target.
        entry simplify!


    method continuation: name params: params target: target args: args
        let cont = Continuation id: self nextId
                                name: name
                                params: params
                                target: target
                                args: args.
        continuations push: cont.
        cont!


    method makeVariable: name
        Variable
            id: self nextId
            name: name!


    method makeTemporary
        Variable
            id: self nextId!


    method ensureConstant: value
        constants
            at: value
            ifNonePut: { Constant
                             id: self nextId
                             value: value }!

    method ensureGlobal: name
        globals
            at: name
            ifNonePut: { Global
                             id: self nextId
                             name: name }!


    method addGlobalDefinitions: definitions
        definitions
            do: { |def|
                  let global = self ensureGlobal: def name.
                  global definition: def }!


    method ensureSelector: name
        selectors
            at: name
            ifNonePut: { self ensureConstant: (CpsSelector name: name) }!



    method ensureOperation: op args: args
        operations
            at: op
            and: args
            ifNonePut: { Operation
                             id: self nextId
                             op: op
                             args: args }!

    method classOf: recv
           self ensureOperation: CLASS_OF
                args: [recv]!


    method findMethod: name for: recv
        let selector = self ensureSelector: name.
        let classOf = self classOf: recv.
        self ensureOperation: FIND_METHOD
             args: [classOf, selector]!


    method nextId
        lastId = lastId + 1!
end


class CpsConverter { graph var next }

    direct method new
        self graph: CpsGraph new
             var: False
             next: False!


    direct method convert: syntax withGlobalDefinitions: defs
        let converter = self new.
        converter graph addGlobalDefinitions: defs.
        converter graph
            entry: (syntax visitBy: converter
                           with: converter graph exit).
        converter graph optimize.
        converter graph!


    method bindVariable: var
        CpsConverter
            graph: graph
            var: var
            next: self!


    method bindVariables: vars
        let converter = self.
        vars do: { |each|
                   converter = converter bindVariable: each }.
        converter!


    method findBinding: name
        var is False
            ifTrue: { return graph ensureGlobal: name }.
        var name == name
            ifTrue: { var }
            ifFalse: { self next findBinding: name }!


    method visitBlock: syntax with: cc
        let blockReturn = graph makeVariable: "$ret".
        let blockVars = syntax parameters
                            collect: { |each| graph makeVariable: each name }.
        let block = syntax body
                        visitBy: (self bindVariables: blockVars)
                        with: blockReturn.
        block name: "$block".
        block addParams: (blockVars append: [blockReturn]).
        graph continuation: "$makeClosure"
              params: []
              target: cc
              args: [block simplify]!


    method visitLet: syntax with: cc
        let var = graph makeVariable: syntax variable name.
        let body = syntax body
                       visitBy: (self bindVariable: var)
                       with: cc.
        let bind = graph continuation: "$let"
                         params: [var]
                         target: body
                         args: [].
        (syntax value visitBy: self with: bind simplify)
            simplify!


    method visitLiteral: syntax with: cc
        let const = graph ensureConstant: syntax value.
        (graph continuation: "$const_ref"
              params: []
              target: cc
              args: [const])
        simplify!


    method visitSend: syntax with: cc
        let recv = graph makeVariable: "$recv".
        let args = syntax arguments
                       collect: { |a| graph makeVariable: "$arg" }
                       as: Array.
        let methodFunction = graph findMethod: syntax selector name
                                   for: recv.
        let next = graph continuation: "$send"
                         params: []
                         target: methodFunction
                         args: ([recv] append: args append: [cc]).
        syntax arguments reverse
            with: args reverse
            do: { |syntaxArg var|
                  let bind = graph continuation: "$bind_arg"
                                   params: [var]
                                   target: next
                                   args: [].
                  next = (syntaxArg visitBy: self with: bind)
                             simplify }.
        let recvBind = graph continuation: "$bind_recv"
                             params: [recv]
                             target: next
                             args: [].
        syntax receiver visitBy: self with: recvBind simplify!


    method visitSeq: syntax with: cc
        let then = syntax then visitBy: self with: cc.
        let discard = graph continuation: "$seq"
                            params: [graph makeVariable: "$ignore"]
                            target: then
                            args: [].
        syntax first visitBy: self with: discard simplify!


    method visitValueTypeDeclaration: syntax with: cc
        let value = graph makeVariable: "$value".
        let type = graph makeVariable: "$type".
        let checkCont = graph continuation: "$typecheck"
                              params: [type]
                              target: (graph findMethod: "typecheck:" for: type)
                              args: [type, value, cc].
        let typeCont = syntax type visitBy: self with: checkCont.
        let bindValue = graph continuation: "$bind"
                              params: [value]
                              target: typeCont
                              args: [].
        syntax value visitBy: self with: bindValue!


    method visitVariable: syntax with: cc
        let var = self findBinding: syntax name.
        (Continuation includes: cc)
            => { cc uses isEmpty
                     => { cc params first replaceUsesWith: var.
                          cc removeParams.
                          return cc } }.
        graph continuation: "$var_ref"
              params: []
              target: cc
              args: [var]!
end


class CpsOptimizer { worklist graph }

    direct method optimize: graph
        let worklist = Worklist new.
        graph doExpressions: { |each| worklist push: each }.
        (self worklist: worklist graph: graph)
            optimize!


    method optimize
        { worklist isEmpty }
            whileFalse: { worklist pop visitBy: self }!


    method visitContinuation: aCont
        aCont target visitBy: self.
        aCont args do: { |each| each visitBy: self }!


    method visitOperation: anOperation
        anOperation op visit: anOperation by: self!


    method visitClassOf: aClassOf
        let recv = aClassOf args first.
        (recv hasClassDefinition)
            ifTrue: { let const = graph ensureConstant: recv classDefinition.
                      aClassOf uses
                          do: { |each|
                                each replaceUses: aClassOf with: const.
                                worklist push: each } }!


    method visitFindMethod: aFindMethod
        let classArg = aFindMethod args at: 1.
        (Constant includes: classArg)
            => { let classDef = classArg value.
                 (ClassDefinition includes: classDef)
                     => { let selectorArg = aFindMethod args at: 2.
                          (Constant includes: selectorArg)
                              => { let selector = selectorArg value.
                                   (CpsSelector includes: selector)
                                       => { let methodFunction = classDef findMethod: selector name.
                                            (methodFunction is False) not
                                                => { let constMethod = graph ensureConstant: methodFunction.
                                                     aFindMethod replaceUsesWith: constMethod.
                                                     constMethod uses do: { |each|
                                                                            each propagateConstantType: constMethod.
                                                                            worklist push: each } } } } } }!


    method visitGlobal: _
        False!


    method visitVariable: _
        False!


    method visitConstant: _
        False!
end


class CpsPrinter { output seen }

    direct method printToString: graph
        StringOutput
            with: { |out|
                    self print: graph to: out }!


    direct method print: graph::CpsGraph to: output
        let visitor = self
                          output: output
                          seen: Set new.
        output newline.
        visitor visit: graph entry!


    method visit: other
        (seen add: other)
            ifTrue: { other visitBy: self }!


    method visitContinuation: aCont
        output
            ; print: aCont printName
            ; print: "(".
        aCont params
            do: { |each| output print: each printName }
            interleaving: { output print: ", " }.
        output println: "):".
        output
            ; print: "    "
            ; print: aCont target printName
            ; print: "(".
        aCont args
            do: { |arg| output print: arg printName }
            interleaving: { output print: ", " }.
        output println: ")".
        aCont args do: { |each| self visit: each }.
        self visit: aCont target!


    method visitConstant: _
        False!


    method visitVariable: _
        False!


    method visitGlobal: _
        False!


    method visitOperation: anOp
        anOp args do: { |each| self visit: each }!
end


class TestCPS { assert }
    is TestSuite

    method convert: source
        self convert: source withGlobalDefinitions: []!


    method convert: source withGlobalDefinitions: defs
        let syntax = Parser parseExpression: source.
        CpsConverter convert: syntax withGlobalDefinitions: defs!


    method test_convert_arity_0_block
        let cps = self convert: "\{ 421 }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    $return:2($block:5)
$block:5($ret:3):
    $ret:3(421)
"!


    method test_convert_arity_3_block
        let cps = self convert: "\{ |a b c| a + b + c }".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    $return:2($block:21)
$block:21(a:4, b:5, c:6, $ret:3):
    findMethod:18(classOf:17(a:4), #+)(a:4, b:5, $bind_recv:14)
$bind_recv:14($recv:7):
    findMethod:11(classOf:10($recv:7), #+)($recv:7, c:6, $ret:3)
"!


    method test_convert_constant_integer
        let cps = self convert: "123".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    $return:2(123)
"!


    method test_convert_global
        let cps = self convert: "X".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    $return:2(X:Global)
"!


    method test_convert_let
        let cps = self convert: "let x = 87. x".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    $return:2(87)
"!


    method test_convert_send
        let cps = self convert: "X some: 12 message: 97".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    findMethod:8(classOf:7(X:Global), #some:message:)(X:Global, 12, 97, $return:2)
"!


    method test_convert_seq
        let cps = self convert: "X some: 12 message: 97. Y + Z".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    findMethod:20(classOf:19(X:Global), #some:message:)(X:Global, 12, 97, $seq:14)
$seq:14($ignore:13):
    findMethod:7(classOf:6(Y:Global), #+)(Y:Global, Z:Global, $return:2)
"!


    method test_convert_typecheck
        let cps = self convert: "X :: Integer".
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    findMethod:7(classOf:6(Integer:Global), #typecheck:)(Integer:Global, X:Global, $return:2)
"!


    method test_convert_typecheck_gives_type
        let cps = self convert: "X::Integer + Y"
                       withGlobalDefinitions: [(ClassDefinition
                                                    name: "Integer"
                                                    methods: [(BuiltinMethodDefinition name: "+")])].
        assert that: { CpsPrinter printToString: cps }
               equals: "
$entry:1($return:2):
    methodFunction(Integer class#typecheck:)(Integer:Global, X:Global, $bind_recv:12)
$bind_recv:12($recv:4):
    methodFunction(Integer#+)($recv:4, Y:Global, $return:2)
"!
end

class Main {}
    direct method run: command in: system
        TestCPS runTests: (Assert reportingTo: system output)
                in: system!
end
