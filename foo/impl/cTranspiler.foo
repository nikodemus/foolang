import .transpiler.record
import .transpiler.array
import .transpiler.boolean
import .transpiler.byte_array
import .transpiler.character
import .transpiler.class
import .transpiler.clock
import .transpiler.closure
import .transpiler.file
import .transpiler.filepath
import .transpiler.filestream
import .transpiler.float
import .transpiler.input
import .transpiler.integer
import .transpiler.layout
import .transpiler.name.Name
import .transpiler.output
import .transpiler.random
import .transpiler.selector
import .transpiler.string
import .transpiler.system
import .transpiler.system_random
import .transpiler.time
import .ast.*
import .utils.*
import .types.*
import .environment.ModuleBinding

define CEscapes
    { "'" -> "\\'",
      "\\" -> "\\\\",
      "\t" -> "\\t",
      "\n" -> "\\n",
      "\r" -> "\\r" }!

-- define Tracer DebugTracer name: "CTranspiler"!
define Tracer NullTracer!

class BuiltinMethod { home selector definition isDirect }
    is AstMethod

    direct method forEach: builtins in: home direct: areDirect
        let dict = Dictionary new.
        builtins
            do: { |selector definition|
                  -- KLUDGE: host dictionaries don't play well
                  -- with selectros.
                  dict at: selector name
                       put: (self
                                 home: home
                                 selector: selector
                                 definition: definition
                                 isDirect: areDirect) }.
        dict!
    method returnType
        { definition returnType }
            on: DoesNotUnderstand
            do: { return Any }!
    method hasNonLocalReturns
        False!
    method stackContext
        -- Closure methods need more care.
        (home value is Closure) not!
    method isBuiltin
        True!
    method arity
        definition signature size!
    method frameSize
        self arity + self definition vars!
    method signature
        definition signature!
    method body
        definition body!
    method printOn: stream
        stream print: "#<BuiltinMethod {selector}>"!
    method displayOn: stream
        self printOn: stream!
    method toString
        StringOutput with: { |out| self printOn: out }!
    method methodFunctionName
        Name mangleMethod: self!
    method methodHomeName
        Name mangleMethodClass: self!
end

define DatumClasses
    [Boolean, Character, Integer, Float]!

class CompilerBuiltin { type value markFunction _interfaces
                        _directMethods _instanceMethods _allInterfaces
                        _global compilerInfo }
    is AstMethodHome

    direct method type: type
                  value: value
                  mark: mark
                  directMethods: directMethods
                  instanceMethods: instanceMethods
        let theClass = self
                           type: type
                           value: value
                           markFunction: mark
                           _interfaces: List new
                           _directMethods: False
                           _instanceMethods: False
                           _allInterfaces: False
                           _global: False
                           compilerInfo: List new.
        theClass _directMethods: directMethods.
        theClass _instanceMethods: instanceMethods.
        theClass!

    method slots
        []!

    method idOr: block
        -- A bit of a KLUDGE: builtin globals have definitions
        -- in main.c, and we want their names to be consistent.
        --
        -- See also: AstGlobal#idOr:
        ""!

    method isClass
        type is Class!

    method eval
        _global is False
            => { Error raise: "CompilerBuiltin#eval called too early." }.
        _global hasValue
            ifTrue: { _global eval }
            ifFalse: { _global value: value }!

    method global: global
        global definition is self
            assert: "Bad global for CompilerBuiltin".
        _global = global!

    method definitionIn: _env
        self!

    method definition
        self!

    method _interfaces
        _interfaces!

    method _directMethods
        _directMethods!

    method _instanceMethods
        _instanceMethods!

    method _readerMethods
        []!

    method _allInterfaces
        _allInterfaces!

    method _allInterfaces: list
        (_allInterfaces is False) assert: "Oops, _allInterfaces already set!".
        _allInterfaces = list asArray!

    method _directMethods: methods
        (self _directMethods is False) assert: "Builtin direct methods already set.".
        _directMethods = BuiltinMethod forEach: methods in: self direct: True!

    method _instanceMethods: methods
        (self _instanceMethods is False) assert: "Builtin instance methods already set.".
        _instanceMethods = BuiltinMethod forEach: methods in: self direct: False!

    method visitBy: visitor
        visitor visitBuiltin: self!

    method name
        value name!

    method isBuiltin
        True!

    method isDynamic
        False!

    method printOn: stream
        stream print: self toString!

    method toString
        "#<CompilerBuiltin {self name} ({type name})>"!
end

class CompilerBuiltins {}
    direct method all
        [ CompilerBuiltin
              type: Class
              value: Array
              mark: "foo_mark_array"
              directMethods: array.DirectMethods
              instanceMethods: array.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Boolean
              mark: "foo_mark_none"
              directMethods: boolean.DirectMethods
              instanceMethods: boolean.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: ByteArray
              mark: "foo_mark_bytes"
              directMethods: byte_array.DirectMethods
              instanceMethods: byte_array.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Character
              mark: "foo_mark_none"
              directMethods: character.DirectMethods
              instanceMethods: character.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Class
              mark: "foo_mark_class"
              directMethods: class.InstanceMethods -- class is its own instance
              instanceMethods: class.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Clock
              mark: "foo_mark_none"
              directMethods: clock.DirectMethods
              instanceMethods: clock.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Closure
              mark: "foo_mark_closure"
              directMethods: Dictionary new
              instanceMethods: closure.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Layout
              mark: "foo_mark_layout"
              directMethods: layout.DirectMethods
              instanceMethods: layout.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: File
              mark: "foo_mark_file"
              directMethods: file.DirectMethods
              instanceMethods: file.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: FilePath
              mark: "foo_mark_bytes"
              directMethods: filepath.DirectMethods
              instanceMethods: filepath.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: FileStream
              mark: "foo_mark_filestream"
              directMethods: filestream.DirectMethods
              instanceMethods: filestream.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Float
              mark: "foo_mark_none"
              directMethods: float.DirectMethods
              instanceMethods: float.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Input
              mark: "foo_mark_none"
              directMethods: input.DirectMethods
              instanceMethods: input.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Integer
              mark: "foo_mark_none"
              directMethods: Dictionary new
              instanceMethods: integer.IntegerMethods,
          CompilerBuiltin
              type: Class
              value: Output
              mark: "foo_mark_none"
              directMethods: output.DirectMethods
              instanceMethods: output.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Random
              mark: "foo_mark_none"
              directMethods: random.DirectMethods
              instanceMethods: random.InstanceMethods,
          CompilerBuiltin
              type: Interface
              value: Record
              mark: "foo_mark_none"
              directMethods: record.DirectMethods
              instanceMethods: record.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Selector
              mark: "foo_mark_none"
              directMethods: selector.DirectMethods
              instanceMethods: selector.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: String
              mark: "foo_mark_bytes"
              directMethods: string.DirectMethods
              instanceMethods: string.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: (Foolang isSelfHosted
                          ifTrue: { System }
                          ifFalse: { { name: "System" } })
              mark: "foo_mark_none"
              directMethods: system.DirectMethods
              instanceMethods: system.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: (Foolang isSelfHosted
                          ifTrue: { SystemRandom }
                          ifFalse: { { name: "SystemRandom" } })
              mark: "foo_mark_none"
              directMethods: system_random.DirectMethods
              instanceMethods: system_random.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Time
              mark: "foo_mark_ptr"
              directMethods: time.DirectMethods
              instanceMethods: time.InstanceMethods
        ]!
end

class SelectorMap { names }
    direct method new
        self names: Dictionary new!

    method map: selector
        names
            at: selector name
            ifNonePut: { Name mangleSelector: selector }!

    method do: block
        names do: block!
end

define AlwaysEmittedSelectors
    [#invoke:on:,
     #perform:with:,
     #selector,
     #writeString:]!

define $home
        False!

class Counter { value }
    direct method new
        self value: 0!
    method increment
        value = value + 1!
end

define $CascadeReceiverTemp
    "<<<not in cascade>>>"!

class CompilerDictionary { list }
    direct method new
        self list: List new!

    method at: global ifNone: block
        (global compilerInfo contains: #inCompilerDictionary)
            ifTrue: { global definition }
            ifFalse: block!

    method ensure: global
        (global compilerInfo contains: #inCompilerDictionary)
            ifFalse: { global compilerInfo add: #inCompilerDictionary.
                       list add: global }!

    method isEmpty
        list isEmpty!

    method do: block
        list do: block!

    method takeAll
        let old = list.
        list = List new.
        old!

    method restoreAll: all
        all do: { |each|
                  (each compilerInfo contains: #inCompilerDictionary)
                      assert: "Restoring new things to CompilerDictionary!" }.
        list isEmpty
            assert: "CompilerDictionary not empty on restore.".
        list = all!
end

class CTranspiler { output selectorMap closureFunctions
                    constants variables tmpCounter
                    globals globalsCounter
                    recordClasses
                    generatedMethods env builtins }

    direct method transpile: string in: env with: prelude
        let builtins = CompilerBuiltins all.
        env replaceBuiltins: builtins.
        -- FIXME: move "target class map" to environment?
        prelude is False
            ifFalse: { env importPrelude: prelude }.
        env load: string.
        self transpileMainIn: env with: builtins!

    direct method transpileMainIn: env with: builtins
        let visitor = CTranspiler
                          output: StringOutput new
                          selectorMap: SelectorMap new
                          closureFunctions: List new
                          constants: List new
                          variables: Dictionary new
                          tmpCounter: 0
                          globals: CompilerDictionary new
                          globalsCounter: Counter new
                          recordClasses: Dictionary new
                          generatedMethods: Dictionary new
                          env: env
                          builtins: builtins.
        visitor output println: "#include \"foo.h\"".
        -- KLUDGE: ensure selectors with references from C code
        AlwaysEmittedSelectors
            do: { |each| visitor selectorMap map: each }.
        let builtins = visitor generateBuiltins.
        let main = env global: "Main".
        visitor declare: main.
        visitor writeDefinitions.
        visitor writeMain: main.
        { main: visitor output,
          builtins: builtins,
          closures: visitor generateClosures,
          constants: visitor generateConstants,
          declarations: visitor generateDeclarations,
          selectors: visitor generateSelectors }!

    method addTemp
        $home addTemp!

    method mangleGlobal: global
        let id = global idOr: { globalsCounter increment }.
        -- Debug println: "{id}: {global}".
        Name mangleGlobal: global
             id: id!

    method mangleMetaclass: aClass
        Name mangleMetaclass: aClass!

    method _visitWithOutputToString: value
        let oldOutput = output.
        let newOutput = StringOutput new.
        { output = newOutput.
          value visitBy: self }
        finally: { output = oldOutput }.
        newOutput content!

    method _visitTemp: value
        value isImmediate
            ifTrue: { return self _visitWithOutputToString: value }.
        let tmp = self addTemp.
        output print: "ctx->frame[{tmp}] = ".
        value visitBy: self.
        output print: ";".
        "ctx->frame[{tmp}]"!

    method declare: global
        globals ensure: global!

    method declareDynamic: var
        self declare: var.
        variables at: var name ifNonePut: { variables size }!

    method genTemp: name
        tmpCounter = tmpCounter + 1.
        "tmp{tmpCounter}_{name}"!

    method forwardDeclarationFor: aGlobal
        (AstBuiltin includes: aGlobal)
            ifTrue: { return False }.
        (aGlobal compilerInfo contains: #declared)
            ifTrue: { return False }.
        aGlobal compilerInfo add: #declared.
        -- Debug println: "declare: {aGlobal}".
        (CompilerBuiltin includes: aGlobal)
            ifTrue: { self _classDeclarations: aGlobal }.
        (AstClass includes: aGlobal)
            ifTrue: { self _classDeclarations: aGlobal }.
        (AstInterface includes: aGlobal)
            ifTrue: { self _interfaceDeclarations: aGlobal }.
        aGlobal isDynamic
            ifTrue: { self declareDynamic: aGlobal.
                      output println: "struct Foo {Name mangleDynamic: aGlobal};" }
            ifFalse: {  output println: "struct Foo {self mangleGlobal: aGlobal};" }!

    method _classDeclarations: aClass
        -- Class is it's own metaclass, declare only once.
        ((CompilerBuiltin includes: aClass) and: aClass name == "Class")
            ifFalse: { output println: "struct FooClass {Name mangleMetaclass: aClass};" }.
        output println: "struct FooClass {Name mangleClass: aClass};".
        let isOwnDefinition
                = { |def| def home is aClass }.
        (aClass directMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }.
        (aClass instanceMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }!

    method _interfaceDeclarations: anInterface
        output println: "struct FooClass {Name mangleMetaclass: anInterface};".
        output println: "struct FooClass {Name mangleClass: anInterface};".
        let isOwnDefinition
                = { |def| def home is anInterface and: def isRequired not }.
        (anInterface directMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }.
        (anInterface instanceMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }!

    method _methodDeclaration: aMethod
        output print: "struct Foo ".
        output print: (Name mangleMethod: aMethod).
        output println: "(const struct FooMethod*, const struct FooSelector*, struct FooContext*, struct Foo, size_t, va_list);"!

    method writeDefinitions
        -- Processing a definition can produce new global references. Visit
        -- each definition only once, finish with the full collection.
        let allGlobals = List new.
        { globals isEmpty }
            whileFalse: { globals takeAll
                              do: { |global|
                                    (global compilerInfo contains: #inAllGlobals)
                                        ifFalse: { global compilerInfo add: #inAllGlobals.
                                                   allGlobals add: global.
                                                   global definition visitBy: self } } }.
        globals restoreAll: allGlobals!

    method writeMain: main
        output println: "int main".
        output println: "    (int argc, char** argv)".
        output println: "\{".
        output println: "    fooinit();".
        output println: "    struct FooArray* vars = FooArray_alloc(NULL, {variables size});".
        variables
            do: { |name offset|
                  let var = {name: name}.
                  output print: "vars->data[{offset}] = ".
                  output print: (Name mangleDynamic: var).
                  output println: ";" }.
        output println: "    struct FooContext* ctx = foo_context_new_main(vars);".
        output println: "    struct FooArray* array = FooArray_alloc(NULL, argc-1);".
        output println: "    for (size_t i = 0; i < array->size; i++)".
        output println: "        array->data[i] = foo_String_new_from(NULL, argv[i+1]);".
        output println: "    struct Foo args = \{ .class = &FooClass_Array, .datum = \{ .ptr = array } };".
        output println: "    struct Foo system = \{ .class = &FooClass_System, .datum = \{ .ptr = NULL } };".
        output println: "    foo_send(ctx, &{Name mangleSelector: #run:in:}, {self mangleGlobal: main}, 2, args, system);".
        output println: "    return 0;".
        output println: "}"!

    method generateSelectors
        let output = StringOutput new.
        let prev = "NULL".
        selectorMap do: { |name cname|
                         output print: "struct FooSelector ".
                         output print: cname.
                         output print: " = \{ .name = FOO_CSTRING(".
                         output display: name.
                         output print: "), .next = ".
                         output print: prev.
                         output print: " };\n".
                         prev = "&{cname}" }.
        output println: "struct FooSelector* FOO_InternedSelectors = {prev};".
        output!

    method compileMethodBody: aMethod
        aMethod isBuiltin
            ifTrue: { return aMethod body }.
        let $home = aMethod.
        let newOutput = StringOutput new.
        newOutput print: "return ".
        let methodVisitor = CTranspiler
                                 output: newOutput
                                 selectorMap: selectorMap
                                 closureFunctions: closureFunctions
                                 constants: constants
                                 variables: variables
                                 tmpCounter: tmpCounter
                                 globals: globals
                                 globalsCounter: globalsCounter
                                 recordClasses: recordClasses
                                 generatedMethods: generatedMethods
                                 env: env
                                 builtins: builtins.
        methodVisitor
            _generateTypecheck: aMethod returnType
            _for: aMethod body.
        newOutput content!

    method generateDeclarations
        -- Debug println: "      #generateDeclarations".
        let output = StringOutput new.
        let builtinVisitor = CTranspiler
                                 output: output
                                 selectorMap: selectorMap
                                 closureFunctions: closureFunctions
                                 constants: constants
                                 variables: variables
                                 tmpCounter: tmpCounter
                                 globals: globals
                                 globalsCounter: globalsCounter
                                 recordClasses: recordClasses
                                 generatedMethods: generatedMethods
                                 env: env
                                 builtins: builtins.
        builtinVisitor output println: "#include \"foo.h\"".
        -- FIXME: visit only referenced builtins
        builtins
            do: { |each| builtinVisitor forwardDeclarationFor: each }.
        globals
            do: { |each|
                  builtinVisitor forwardDeclarationFor: each definition }.
        closureFunctions
            do: { |closure|
                  output print: closure declaration.
                  output println: ";" }.
        output!

    method generateBuiltins
        -- Debug println: "      #generateBuiltins:".
        let output = StringOutput new.
        let builtinVisitor = CTranspiler
                                 output: output
                                 selectorMap: selectorMap
                                 closureFunctions: closureFunctions
                                 constants: constants
                                 variables: variables
                                 tmpCounter: tmpCounter
                                 globals: globals
                                 globalsCounter: globalsCounter
                                 recordClasses: recordClasses
                                 generatedMethods: generatedMethods
                                 env: env
                                 builtins: builtins.
        builtinVisitor output println: "#include \"foo.h\"".
        -- FIXME: used builtins only
        builtins
            do: { |each|
                  builtinVisitor visitClassDefinition: each }.
        output!

    method generateClosures
        self generateClosuresOn: StringOutput new!

    method generateClosuresOn: out
        closureFunctions do: { |closure|
                             out println: closure definition }.
        out!

    method generateConstants
        self generateConstantsOn: StringOutput new!

    method generateConstantsOn: out
        constants do: { |each| out println: each declaration }.
        constants do: { |each|
                        out println: each definition }.
        out!

    method selectorCName: selector
        self selectorMap map: selector!

    method constantCName: value
        -- Tracer constantCName: value.
        (Selector includes: value)
            ifTrue: { return self selectorCName: value }.
        (Object includes: value)
            ifTrue: { constants
                          do: { |each|
                                -- Debug println: "constantCName == {each}".
                                value == each value
                                    ifTrue: { return each cname } } }
            ifFalse: { constants
                           do: { |each|
                                -- Debug println: "constantCName is {each}".
                                value is each value
                                   ifTrue: { return each cname } } }.
        ((Class includes: value) or: (Interface includes: value))
            ifTrue: { self declare: (self _astClassOf: value).
                      let cname = Name mangleClass: value.
                      constants add: { value: value,
                                       cname: cname,
                                       declaration: "",
                                       definition: "" }.
                      return cname }
            ifFalse: { let index = constants size + 1.
                       let cname = "fooconst_{Name mangleName: value classOf name}_{index}".
                       -- Placeholder in case of recursive entry.
                       constants add: { value: value, cname: cname }.
                       constants at: index
                                 put: (self _constantDefinition: value
                                            _called: cname).
                       return cname }!

    method _isPtr: value
        let theClass = value classOf.
        (DatumClasses contains: theClass)
            ifTrue: { return False }.
        True!

    method _writeDatum: value _to: out
        -- Tracer visitDatum: value.
        (self _isPtr: value)
            ifTrue: { return out print: ".ptr = &{self constantCName: value}" }.
        (Boolean includes: value)
            ifTrue: { let bit = value ifTrue: { 1 } ifFalse: { 0 }.
                      return out print: ".boolean = {bit}" }.
        (Character includes: value)
            ifTrue: { return out print: ".int64 = {value code}" }.
        (Float includes: value)
            ifTrue: { return out print: ".float64 = {value}" }.
        (Integer includes: value)
            ifTrue: { return out print: ".int64 = {value}" }.
        Error raise: "Don't know how to transpile constant `{value}` into C."!

    method _astClassOf: value
        (Record includes: value)
            ifTrue: { let recordClass = env _recordClassFromRecord: value.
                      self declare: recordClass.
                      return recordClass definition }.
        -- KLUDGE: Dictionary is builtin on bootstrap host, so
        -- env classes don't know about it. Instead of this
        -- should somehow include it it compiler builtins,
        -- maybe with a "redefined: True" flag?
        (Dictionary includes: value)
            ifTrue: { return env global: "Dictionary" }.
        -- FIXME: WTF? Why?
        let theClass = ((Class includes: value) or: (Interface includes: value))
                         ifTrue: { value }
                         ifFalse: { value classOf }.
        return env classes
            at: theClass
            ifNone: { env findBuiltinFor: theClass
                          ifNone: { panic "No 'ast class' for: {value} ({theClass})\nenv classes: {env classes keys}\nbuiltins: {builtins}" } }!

    method _writeValue: value _to: out
        -- Tracer _writeValue: value.
        ((Class includes: value) or: (Interface includes: value))
            ifTrue: { out print: "(struct Foo)\{ .class = &{Name mangleMetaclass: (self _astClassOf: value)}, .datum = \{ " }
            ifFalse: { out print: "(struct Foo)\{ .class = &{Name mangleClass: (self _astClassOf: value)}, .datum = \{ " }.
        self _writeDatum: value _to: out.
        out println: " } }"!

    method _constantDefinition: value _called: cname
        -- Tracer _constantDefinition: value.
        (Array includes: value)
            ifTrue: { return
                          { value: value,
                            cname: cname,
                            declaration: "struct FooArray {cname};",
                            definition: (self _arrayDefinition: value
                                              _called: cname) } }.
        (Dictionary includes: value)
            ifTrue: { return
                          { value: value,
                            cname: cname,
                            declaration: "struct FooArray {cname};",
                            definition: (self _dictionaryDefinition: value
                                              _called: cname) } }.
        (Record includes: value)
            ifTrue: { return
                          { value: value,
                            cname: cname,
                            declaration: "struct FooArray {cname};",
                            definition: (self _recordDefinition: value
                                              _called: cname) } }.
        (String includes: value)
            ifTrue: { return
                          { value: value,
                            cname: cname,
                            declaration: "struct FooBytes {cname};",
                            definition: (self _stringDefinition: value
                                              _called: cname) } }.
        { value: value,
          cname: cname,
          declaration: "struct FooArray {cname};",
          definition: (self _instanceDefinition: value
                            _called: cname) }!

    method _arrayDefinition: value _called: cname
        StringOutput
            with: { |out|
                    out println: "struct FooArray {cname} =".
                    out println: "\{".
                    out println: "    .header = \{ .allocation = STATIC },".
                    out println: "    .size = {value size},".
                    out print: "    .data = \{ ".
                    value do: { |each|
                                self _writeValue: each
                                     _to: out.
                                out print: "," }.
                    out println: " }".
                    out println: "};" }!

    -- Dictionary is special cases because it is builtin
    -- on bootstrap host.
    method _dictionaryDefinition: value _called: cname
        -- Tracer _instanceDefinition: value _called: cname
        let theClass = self _astClassOf: value.
        self declare: theClass.
        let slots = theClass definition slots
                        collect: { |each| each name toSelector }
                        as: Array.
        slots == [#size, #_keys, #_values]
            assert: "Dictionary layout has changed! Got: {slots}".
        StringOutput
            with: { |out|
                    out println: "struct FooArray {cname} =".
                    out println: "\{".
                    out println: "    .header = \{ .allocation = STATIC },".
                    out println: "    .size = {slots size},".
                    out print: "    .data = \{ ".
                    [#size, #keys, #values]
                        do: { |each|
                              self _writeValue: (each sendTo: value)
                                   _to: out.
                              out print: "," }.
                    out println: " }".
                    out println: "};" }!

    method _instanceDefinition: value _called: cname
        -- Tracer _instanceDefinition: value _called: cname
        let theClass = self _astClassOf: value.
        self declare: theClass.
        let slots = theClass definition slots.
        StringOutput
            with: { |out|
                    out println: "struct FooArray {cname} =".
                    out println: "\{".
                    out println: "    .header = \{ .allocation = STATIC },".
                    out println: "    .size = {slots size},".
                    out print: "    .data = \{ ".
                    slots
                        do: { |each|
                              self _writeValue: (each at: value)
                                   _to: out.
                              out print: "," }.
                    out println: " }".
                    out println: "};" }!

    method _recordDefinition: value _called: cname
        StringOutput
            with: { |out|
                    out println: "struct FooArray {cname} =".
                    out println: "\{".
                    out println: "    .header = \{ .allocation = STATIC },".
                    out println: "    .size = {Record sizeOf: value},".
                    out print: "    .data = \{ ".
                    value do: { |each|
                                self _writeValue: each
                                     _to: out.
                                out print: "," }.
                    out println: " }".
                    out println: "};" }!

    method _printStringAsComment: s0 to: out
        -- KLUDGE ARRGH do this properly FIXME
        let s1 = s0 replace: "\\" with: "\\\\".
        let s2 = s1 replace: "\n" with: "\\n".
        let s3 = s2 replace: "\r" with: "\\r".
        let s4 = s3 replace: "\"" with: "\\\"".
        let s5 = s4 replace: "\{" with: "\\\{".
        out println: "// \"{s5}\""!

    method _stringDefinition: value _called: cname
        StringOutput
            with: { |out|
                    value lines
                        do: { |each| self _printStringAsComment: each to: out }.
                    out println: "struct FooBytes {cname} =".
                    out println: "\{".
                    out println: "    .header = \{ .allocation = STATIC },".
                    out println: "    .size = {value size},".
                    out print: "    .data = \{ ".
                    value do: { |each|
                                out print: "'".
                                out print: (CEscapes at: each ifNone: { each }).
                                out print: "'," }.
                    out print: "0".
                    out println: " }".
                    out println: "};" }!

    method closureCName: closure
        let $home = closure.
        let output = StringOutput new.
        -- Placeholder so that recursive entry by visitor doesn't grab the
        -- same id.
        closureFunctions add: False.
        let index = closureFunctions size.
        let cname = "fooclosure_id{index}".
        let signature = StringOutput new.
        signature print: "struct Foo ".
        signature print: cname.
        signature print: "(struct FooContext* ctx)".
        output print: signature.
        output println: " \{".
        -- FIXME: Given that we need to check types here, should also put the args
        -- in frame here, same as in methods.
        closure argumentVariables
            do: { |var|
                  let type = var type.
                  type is Any
                      ifFalse: { output println: "    foo_class_typecheck(ctx, &{Name mangleClass: type}, ctx->frame[{var index-1}]);" } }.
        output print: "    return ".
        let closureVisitor = CTranspiler
                               output: output
                               selectorMap: selectorMap
                               closureFunctions: closureFunctions
                               constants: constants
                               variables: variables
                               tmpCounter: tmpCounter
                               globals: globals
                               globalsCounter: globalsCounter
                               recordClasses: recordClasses
                               generatedMethods: generatedMethods
                               env: env
                               builtins: builtins.
        closureVisitor _generateTypecheck: closure returnType
                     _for: closure body.
        output println: ";\n}".
        closureFunctions
            put: { declaration: signature, definition: output }
            at: index.
        cname!

    method visitBuiltin: aClass
        -- Tracer trace: #visitBuiltin:.
        self!

    method visitDefine: aDefine
        (aDefine compilerInfo contains: #visited)
            ifTrue: { return False }.
        aDefine compilerInfo add: #visited.
        Tracer visitDefine: aDefine.
        aDefine isDynamic
            ifTrue: { output println: "struct Foo {Name mangleDynamic: aDefine} = " }
            ifFalse: { output println: "struct Foo {self mangleGlobal: aDefine} = " }.
        self _writeValue: aDefine eval _to: output.
        output println: ";".
        output newline!

    method visitRecord: aRecord
        -- Tracer visitRecord: aRecord.
        let recordClass = env ensureRecordClass: aRecord.
        self declare: recordClass.
        output print: "(\{ ".
        let args = aRecord values
                       collect: { |each| self _visitTemp: each }.
        output print: "foo_send(ctx".
        output print: ", &{Name mangleSelector: aRecord name}".
        output print: ", {self mangleGlobal: recordClass definition}".
        output print: ", ".
        output print: args size.
        args
            do: { |each|
                  output print: ", {each}" }.
        output print: "); })"!

    method visitDictionary: aDictionary
        -- Tracer visitDictionary: aDictionary
        output print: "(\{".
        let new = self selectorCName: #new.
        let dict = self addTemp.
        output print: "ctx->frame[{dict}] = foo_send(ctx, &{new}, ".
        self visitGlobal: (env global: "Dictionary").
        output print: ", 0);".
        let putAt = self selectorCName: #put:at:.
        aDictionary entries
            do: { |each|
                  let k = self _visitTemp: each key.
                  let v = self _visitTemp: each value.
                  output print: "foo_send(ctx, &{putAt}, ctx->frame[{dict}], 2, {v}, {k}); " }.
        output print: "ctx->frame[{dict}]; })"!

    method _generateLayout: aClass
        -- Tracer _generateLayout: aClass.
        aClass isBuiltin
            ifTrue: { return "NULL" }. -- FIXME: proper builtin layouts
        -- FIXME: Since user doesn't have access to these layouts,
        -- could/should intern them.
        let name = "FooLayout_{aClass name}".
        output println: "struct FooLayout {name} = \{".
        output println: "    .header = \{ .allocation = STATIC },".
        output println: "    .mark = foo_mark_oops,".
        output println: "    .size = {aClass slots size}".
        output println: "};".
        return "&{name}"!

    method _generateInheritance: anObject forMetaclass: forMetaclass
        let inheritance = forMetaclass
                              ifTrue: { "FooMetaclassInheritance_{anObject name}" }
                              ifFalse: { "FooClassInheritance_{anObject name}" }.
        let mangle = forMetaclass
                         ifTrue: { { |x| Name mangleMetaclass: x} }
                         ifFalse: { { |x| Name mangleClass: x } }.
        let interfaces = anObject interfaceGlobals asList.
        forMetaclass
            ifTrue: { interfaces add: (env global: "Class") }.
        output println: "struct FooClassList {inheritance} = \{".
        output println: "    .header = \{ .allocation = STATIC },".
        output println: "    .size = {interfaces size},".
        output println: "    .data = \{".
        interfaces
            do: { |each|
                  self declare: each.
                  output println: "        &{mangle value: each}," }.
        output println: "    }".
        output println: "};".
        output newline.
        inheritance!

    method visitInterfaceDefinition: anInterface
        (anInterface compilerInfo contains: #visited)
            ifTrue: { return False }.
        anInterface compilerInfo add: #visited.
        Tracer visitInterfaceDefinition: anInterface name.
        output println: "/**
* {anInterface name} (an interface)
*
*/".
        let metaclassName = Name mangleMetaclass: anInterface.
        let className = Name mangleClass: anInterface.
        let globalName = self mangleGlobal: anInterface.
        let directMethods = (anInterface directMethods reject: #isRequired)
                                asList.
        (directMethods anySatisfy: { |each| each selector toSelector == #includes: })
            ifFalse: { Error raise: "Every interface must have an #includes: method, {anInterface} didn't:\n{directMethods}." }.
        directMethods
            do: { |each| self _writeMethod: each _for: anInterface }.
        let instanceMethods = anInterface instanceMethods reject: #isRequired.
        instanceMethods
            do: { |each| self _writeMethod: each _for: anInterface }.
        -- Interface metaclass
        -- FIXME: name says 'Foo interface', should be 'Foo class'!
        let metaclassInheritance
            = self _generateInheritance: anInterface forMetaclass: True.
        let classInheritance
            = self _generateInheritance: anInterface forMetaclass: False.
        let metaclassNameString = "{anInterface name} interface".
        output println: "struct FooClass {metaclassName} = ".
        output println: "\{".
        output println: "    .header = \{ .allocation = STATIC },".
        output println: "    .name = &{self constantCName: metaclassNameString}, // {metaclassNameString}".
        output println: "    .metaclass = &FooClass_Class,".
        output println: "    .inherited = &{metaclassInheritance},".
        output println: "    .layout = &TheClassLayout,".
        output println: "    .mark = foo_mark_none,".
        output println: "    .size = {directMethods size},".
        output println: "    .methods = \{".
        directMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .home = &{each methodHomeName},".
                  output println: "                            .function = &{each methodFunctionName},".
                  output println: "                            .object = (struct Foo)\{ .class = NULL, .datum = \{ .ptr = NULL } } }," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Interface class (empty, used for identity only)!
        -- FIXME: for runtime instantiation of classes we need to add the instance methods here!
        output println: "struct FooClass {className} = ".
        output println: "\{".
        output println: "    .header = \{ .allocation = STATIC },".
        output println: "    .name = &{self constantCName: anInterface name}, // {anInterface name}".
        output println: "    .metaclass = &{metaclassName},".
        output println: "    .inherited = &{classInheritance},".
        output println: "    .layout = NULL,". -- FIXME
        output println: "    .mark = foo_mark_none,".
        output println: "    .size = {instanceMethods size},".
        output println: "    .methods = \{".
        instanceMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .home = &{each methodHomeName},".
                  output println: "                            .function = &{each methodFunctionName},".
                  output println: "                            .object = (struct Foo)\{ .class = NULL, .datum = \{ .ptr = NULL \}\}\}," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Interface object
        output println: "struct Foo {globalName} =".
        output println: "\{".
        output println: "    .class = &{metaclassName},".
        output println: "    .datum = \{ .ptr = &{className} }".
        output println: "};".
        output newline!

    method _writeConstructor: ctor for: aClass
        -- Awkward: we need the proto to mangle the names...
        output print: "struct Foo ".
        output println: ctor methodFunctionName.
        output println: "    (const struct FooMethod* method,".
        output println: "     const struct FooSelector* selector,".
        output println: "     struct FooContext* sender,".
        output println: "     struct Foo receiver,".
        output println: "     size_t nargs, va_list arguments) /* CTOR */".
        output println: "\{".
        output println: "    (void)selector;".
        output println: "    (void)nargs;".
        output println: "    struct FooArray* new = FooInstance_alloc(sender, {aClass slots size});".
        aClass slots
            doWithIndex: { |each index|
                           let type = each type. -- FIXME: visit the type
                           type is Any
                               ifTrue: { output println: "new->data[{index-1}] = va_arg(arguments, struct Foo);" }
                               ifFalse: { output println: "new->data[{index-1}] = foo_class_typecheck_argument(sender, &{Name mangleClass: type}, va_arg(arguments, struct Foo), method);" } }.
        output println: "    return (struct Foo)\{ .class = PTR(FooClass, receiver.datum), .datum = \{ .ptr = new } };".
        output println: "}".
        output newline!

    method _generateInstanceClassOf: aClass
        { selector: #classOf,
          methodHomeName: (Name mangleClass: aClass),
          methodFunctionName: "foo_method_classOf" }!

    method visitClassDefinition: aClass
        (aClass compilerInfo contains: #visited)
            ifTrue: { return False }.
        aClass compilerInfo add: #visited.
        Tracer visitClassDefinition: aClass name.
        let classNote = aClass isBuiltin
                       ifTrue: { "{aClass name} (builtin)" }
                       ifFalse: { aClass name }.
        output println: "/**
 * {aClass name}
 *
 */".
        let isTheClass = aClass isBuiltin and: aClass name == "Class".
        let className = Name mangleClass: aClass.
        let metaclassName = Name mangleMetaclass: aClass.
        let globalName = self mangleGlobal: aClass.
        let directMethods = aClass directMethods asList.
        -- Debug println: "{aClass name} direct methods:".
        -- directMethods do: { |each| Debug println: "- {each selector}" }.
        directMethods
            do: { |each| self _writeMethod: each _for: aClass }.
        -- Augmented later with #classOf.
        let instanceMethods = aClass instanceMethods asList.
        -- Debug println: "{aClass name} methods:".
        -- instanceMethods do: { |each| Debug println: "- {each selector}" }.
        instanceMethods
            do: { |each| self _writeMethod: each _for: aClass }.
        let classMethods = isTheClass
                               ifTrue: { instanceMethods }
                               ifFalse:{ directMethods }.
        (classMethods anySatisfy: { |each| each selector toSelector == #includes: })
            ifFalse: { Error raise: "Every class must have an #includes: method, {aClass} didn't:\n{classMethods}." }.
        instanceMethods add: (self _generateInstanceClassOf: aClass).
        isTheClass
            ifFalse: { -- Class metaclass, not needed for Class which
                       -- is its own metaclass.
                       let metaclassInheritance
                           = self _generateInheritance: aClass forMetaclass: True.
                       let metaclassNameString = "{aClass name} classOf".
                       output println: "struct FooClass {metaclassName} = ".
                       output println: "\{".
                       output println: "    .header = \{ .allocation = STATIC },".
                       output println: "    .name = &{self constantCName: metaclassNameString}, // {metaclassNameString}".
                       output println: "    .metaclass = &FooClass_Class,".
                       output println: "    .inherited = &{metaclassInheritance},".
                       output println: "    .layout = &TheClassLayout,".
                       output println: "    .mark = foo_mark_class,".
                       output println: "    .size = {directMethods size},".
                       output println: "    .methods = \{".
                       directMethods
                           do: { |each|
                                 output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                                 output println: "                            .home = &{each methodHomeName},".
                                 output println: "                            .function = &{each methodFunctionName},".
                                 output println: "                            .object = (struct Foo)\{ .class = NULL, .datum = \{ .ptr = NULL } } }," }.
                       output println: "    }".
                       output println: "};".
                       output newline }.
        -- Instance Class
        let classInheritance = self _generateInheritance: aClass forMetaclass: False.
        let layout = isTheClass
                         ifTrue: { "&TheClassLayout" }
                         ifFalse: { self _generateLayout: aClass }.
        -- Debug println: "{aClass} => {aClass markFunction}".
        output println: "struct FooClass {className} = ".
        output println: "\{".
        output println: "    .header = \{ .allocation = STATIC },".
        output println: "    .name = &{self constantCName: aClass name}, // {aClass name}".
        output println: "    .metaclass = &{metaclassName},".
        output println: "    .inherited = &{classInheritance},".
        output println: "    .layout = {layout},".
        output println: "    .mark = {aClass markFunction},".
        output println: "    .size = {instanceMethods size},".
        output println: "    .methods = \{".
        instanceMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .home = &{each methodHomeName},".
                  output println: "                            .function = &{each methodFunctionName},".
                  output println: "                            .object = (struct Foo)\{ .class = NULL, .datum = \{ .ptr = NULL \}\}\}," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Class object
        output println: "struct Foo {globalName} =".
        output println: "\{".
        output println: "    .class = &{metaclassName},".
        output println: "    .datum = \{ .ptr = &{className} }".
        output println: "};".
        output newline.
        True!

    method _writeMethod: aMethod _for: aClass
        -- Tracer _writeMethod: aMethod _for: type.
        -- Debug println: "_writeMethod: {aMethod}".
        aMethod isStandard
            ifTrue: { return False }.
        let name = Name mangleMethod: aMethod.
        generatedMethods
            at: name
            ifNonePut: { aMethod isConstructor
                             ifTrue: { self _writeConstructor: aMethod for: aClass }
                             ifFalse: { self _actuallyGenerateMethod: aMethod _as: name _for: aClass } }!

    method generateMethodFunctionHeader: name
        output print: "struct Foo ".
        output println: name.
        output println: "    (const struct FooMethod* method,".
        output println: "     const struct FooSelector* selector,".
        output println: "     struct FooContext* sender,".
        output println: "     struct Foo receiver,".
        output println: "     size_t nargs,".
        output println: "     va_list arguments) /* MF-header */"!

    method generateStackContextFor: aMethod
        -- Debug println: "stack: {aMethod home name}#{aMethod selector name}".
        aMethod signature
            doWithIndex: { |type index|
                           type is Any
                               ifTrue: { output println: "    struct Foo arg{index} = va_arg(arguments, struct Foo);" }
                               ifFalse: { output println: "    struct Foo arg{index} = foo_class_typecheck_argument(sender, &{Name mangleClass: type}, va_arg(arguments, struct Foo), method);" } }.
        output println: "    struct FooContext* ctx = FOOCONTEXT_OF_SIZE({aMethod frameSize}) \{".
        output println: "        .header = \{ .allocation = STACK },".
        output println: "        .type = METHOD_CONTEXT,".
        output println: "        .depth = sender->depth + 1,".
        output println: "        .method = method,".
        output println: "        .receiver = receiver,".
        output println: "        .sender = sender,".
        output println: "        .outer_context = NULL,".
        output println: "        .vars = sender->vars,".
        output println: "        .cleanup = NULL,".
        output println: "        .return_value = FOO_INTEGER(0),".
        output println: "        .ret = NULL,".
        output println: "        .size = {aMethod frameSize},".
        output println: "        .frame = \{".
        1 to: aMethod arity
          do: { |index| output println: "            arg{index}," }.
        aMethod frameSize - aMethod arity
            times: { output println: "            FOO_INTEGER(0)," }.
        output println: "\n        }".
        output println: "    };".
        output println: "    (void)ctx;"!

    method generateHeapContextFor: aMethod
        output println: "    struct FooContext* ctx".
        output println: "        = foo_context_new_method_va(method, sender, selector, receiver, {aMethod frameSize}, nargs, arguments);".
        output println: "    (void)ctx;".
        aMethod signature
            doWithIndex: { |type index|
                           type is Any
                               ifFalse: { output println: "    foo_class_typecheck(ctx, &{Name mangleClass: type}, ctx->frame[{index-1}ul]);" } }!

    method generateUnwindFor: aMethod with: body
        output println: "    jmp_buf ret;".
        output println: "    ctx->ret = &ret;".
        output println: "    if (setjmp(ret)) \{".
        output println: "        return ctx->return_value;".
        output println: "    } else \{".
        output print: "          ".
        output print: body.
        output println: ";".
        output println: "    }"!

    method _actuallyGenerateMethod: aMethod _as: name _for: aClass
        -- Tracer _actuallyGenerateMethod: aMethod _as: name _for: type.
        -- Debug println: "_actuallyGenerateMethod: {aMethod}".
        aMethod isRequired
            ifTrue: { Error raise: "Required method missing: {aMethod} for: {aClass}." }.
        self generateMethodFunctionHeader: name.
        output println: "\{".
        -- Need to compile the body before we know how big the frame is, this
        -- MUST be before context generation.
        let body = self compileMethodBody: aMethod.
        aMethod stackContext
            ifTrue: { self generateStackContextFor: aMethod }
            ifFalse: { self generateHeapContextFor: aMethod }.
        aMethod hasNonLocalReturns
            ifTrue: { self generateUnwindFor: aMethod with: body }
            ifFalse: { output print: "    ".
                       output print: body.
                       output println: ";" }.
        output println: "}".
        -- Debug println: "  => method done".
        output newline.
        aMethod!

    method _generateTypecheck: type _for: value
        -- Tracer _generateTypecheck: type _for: value.
        -- Debug println: "_generateTypecheck: {type} _for: {value}".
        type is Any
            ifTrue: { return value visitBy: self }.
        let type = type::AstGlobal.
        self declare: type.
        output print: "foo_class_typecheck(ctx, &".
        output print: (Name mangleClass: type).
        output print: ", ".
        value visitBy: self.
        output print: ")"!

    method visitGlobal: aVar
        -- Tracer visitGlobal: aVar.
        self declare: aVar.
        output print: (self mangleGlobal: aVar)!

    method visitDynamic: aVar
        -- Tracer trace: #visitDynamic:.
        let index = self declareDynamic: aVar.
        output print: "ctx->vars->data[{index}]"!

    method visitTypecheck: aCheck
        -- Tracer visitTypecheck: aCheck.
        self _generateTypecheck: aCheck assertType
             _for: aCheck value!

    method visitIs: anIs
        -- Tracer trace: #visitIs:.
        output print: "(\{".
        let left = self _visitTemp: anIs left.
        let right = self _visitTemp: anIs right.
        output print: "FOO_BOOLEAN(foo_eq({left}, {right})); ".
        output print: "})"!

    method visitSeq: seq
        -- Tracer trace: #visitSeq:.
        output print: "(\{ ".
        seq first visitBy: self.
        output print: "; ".
        seq then visitBy: self.
        output print: "; })"!

    method visitSlotSet: set
        -- Tracer trace: #visitSlotSet:.
        output print: "(PTR(FooArray, foo_check_modification(ctx, ctx->receiver.datum))->data[".
        output print: (set slot index - 1).
        output print: "] = ".
        self _generateTypecheck: set slot type
             _for: set value.
        output print: ")"!

    method visitSlotRef: ref
        -- Tracer trace: #visitSlotRef:.
        output print: "PTR(FooArray, ctx->receiver.datum)->data[".
        output print: (ref slot index - 1).
        output print: "]"!

    method visitReturn: ret
        -- Tracer trace: #visitReturn:.
        ret isLocal
            ifFalse: { output print: "foo_return(ctx, ".
                       self _generateTypecheck: ret from returnType
                            _for: ret value.
                       output print: ")".
                       return False }.
        ret isTail
            ifFalse: { output print: "(\{ return ".
                       self _generateTypecheck: ret from returnType
                            _for: ret value.
                       -- The False never happens, but keeps the C-compiler
                       -- happy.
                       output print: "; /* never */ FOO_BOOLEAN(false); \})".
                       return False }.
        self _generateTypecheck: ret from returnType
             _for: ret value!

    method visitConstant: aConstant
        -- Tracer visitConstant: aConstant.
        self _writeValue: aConstant value _to: output!

    method visitCascade: aCascade
        output print: "(\{".
        let $CascadeReceiverTemp = self _visitTemp: aCascade receiver.
        aCascade messages
            do: { |each|
                  each visitBy: self.
                  output print: ";" }.
        output print: "})"!

    method visitCascadeReceiver: _
        output print: $CascadeReceiverTemp!

    method generateKnownSend: aSend using: aMethod
        -- These are never #perform:with: or object methods, thanks to #findMethod:in:
        let methodFunction = Name mangleMethod: aMethod.
        let selector = self selectorCName: aMethod selector.
        output print: "(\{ ".
        let receiver = self _visitTemp: aSend receiver.
        let args = aSend arguments
                       collect: { |each| self _visitTemp: each }.
        output
            ; print: "foo_call_known_method(ctx, &"
            ; print: aMethod methodHomeName
            ; print: ", &"
            ; print: selector
            ; print: ", "
            ; print: aMethod methodFunctionName
            ; print: ", "
            ; print: receiver
            ; print: ", "
            ; print: args size.
        args do: { |each|
                   output
                       ; print: ", "
                       ; print: each }.
        output print: "); })"!

    method visitSend: aSend
        -- Tracer visitSend: aSend selector.
        (aSend receiver type findMethod: aSend selector in: env)
            => { |aMethod|
                 -- Debug println: "HIT {aSend selector} -> {aSend receiver type} ({aSend receiver})".
                 return self generateKnownSend: aSend using: aMethod }.
        -- Debug println: "MISS {aSend selector} -> {aSend receiver type} ({aSend receiver})".
        output print: "(\{ ".
        let receiver = self _visitTemp: aSend receiver.
        let args = aSend arguments
                          collect: { |each| self _visitTemp: each }.
        output print: "foo_send(ctx, &".
        output print: (self selectorCName: aSend selector).
        output print: ", {receiver}, ".
        output print: args size.
        args
            do: { |each|
                  output print: ", {each}" }.
        output print: "); })"!

    method visitSelfInstance: aSelf
        -- Tracer visitSelfInstance: aSelf.
        output print: "ctx->receiver"!

    method visitSelfClass: aSelf
        -- Tracer trace: #visitSelfClass:.
        output print: "(struct Foo)\{ .class = ctx->receiver.class->metaclass, .datum = \{ .ptr = ctx->receiver.class }}"!

    method visitBindDynamic: aBind
        -- Tracer trace: #visitBindDynamic:.
        let name = aBind variable name.
        let index = self declareDynamic: aBind variable.
        let unbind = self genTemp: "unbind".
        output print: "(\{ struct FooUnbind {unbind} = \{ .cleanup = \{ .function = foo_unbind, .next = ctx->cleanup }, .index = {index}, .value = ctx->vars->data[{index}] };".
        output print: " ctx->cleanup = &{unbind}.cleanup;".
        output print: " ctx->vars->data[{index}] = ".
        aBind value visitBy: self.
        output print: ";".
        let res = self _visitTemp: aBind body.
        output print: " assert(&{unbind}.cleanup == ctx->cleanup);".
        output print: " ctx->cleanup = ctx->cleanup->next;".
        output print: " foo_unbind(ctx, &{unbind}.cleanup);".
        output print: " {res}; })"!

    method visitBindLexical: aBind
        -- Tracer trace: #visitBindLexical:.
        output print: "(\{ ctx->frame[{aBind variable index - 1}] = ".
        self _generateTypecheck: aBind variable type
             _for: aBind value.
        output print: ";".
        aBind body visitBy: self.
        output print: "; })"!

    method visitVariable: aVar
        output print: "ctx->frame[{aVar index - 1}]"!

    method visitArgument: anArg
        output print: "ctx->frame[{anArg index - 1}]"!

    method visitLexicalRef: aRef
        -- Tracer trace: #visitLexicalRef:.
        aRef frameOffset is 0
            ifTrue: { aRef variable visitBy: self }
            ifFalse: { output print: "ctx".
                       aRef frameOffset
                           times: { output print: "->outer_context" }.
                       output print: "->frame[{aRef variable index - 1}]" }!

    method visitLexicalSet: aSet
        -- Tracer trace: #visitLexicalSet:.
        output print: "(".
        aSet frameOffset is 0
            ifTrue: { aSet variable visitBy: self }
            ifFalse: { output print: "ctx".
                       aSet frameOffset
                           times: { output print: "->outer_context" }.
                       output print: "->frame[{aSet variable index - 1}]" }.
        output print: " = ".
        self _generateTypecheck: aSet variable type
             _for: aSet value.
        output print: ")"!

    method visitBlock: aBlock
        -- Tracer trace: #visitBlock:.
        output print: "foo_closure_new(ctx, ".
        output print: (self closureCName: aBlock).
        output print: ", ".
        output print: aBlock argumentCount.
        output print: ", ".
        output print: aBlock frameSize.
        output print: ")"!

    method visitArray: anArray
        -- Tracer trace: #visitArray:.
        let entries = anArray entries.
        let array = self addTemp.
        output print: "(\{ ctx->frame[{array}] = foo_Array_alloc(ctx, {entries size}); ".
        entries isEmpty
            ifFalse: { let p = self genTemp: "arrayPtr".
                       output print: "struct FooArray* {p} = PTR(FooArray, ctx->frame[{array}].datum);".
                       entries
                           doWithIndex: { |each index|
                                          output print: "{p}->data[{index-1}] = ".
                                          each visitBy: self.
                                          output print: "; " } }.
        output print: "ctx->frame[{array}]; })"!

    method visitPanic: aPanic
        -- Tracer trace: #visitPanic:.
        output println: "foo_panic(ctx, ".
        aPanic value visitBy: self.
        output println: ")"!
end
