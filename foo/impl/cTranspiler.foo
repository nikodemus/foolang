import .transpiler.name.Name
import .transpiler.integer
import .transpiler.block
import .transpiler.boolean
import .transpiler.float
import .transpiler.output
import .transpiler.string
import .transpiler.array
import .ast.AstClass
import .ast.AstInterface

define CEscapes
    { "'" -> "\\'",
      "\n" -> "\\n",
      "\r" -> "\\r" }!

class BuiltinMethod { selector definition }
    direct method forEach: builtins
        let list = List new.
        builtins
            do: { |selector definition|
                  list push: (self
                                  selector: selector
                                  definition: definition) }.
        list!
    method isBuiltin
        True!
    method arity
        definition signature size!
    method frameSize
        self arity + self definition vars!
    method signature
        definition signature!
    method body
        definition body!
end

class BuiltinClass { host markFunction directMethods instanceMethods }
    direct method new: host
                  mark: mark
                  directMethods: directMethods
                  instanceMethods: instanceMethods
        self host: host
             markFunction: mark
             directMethods: (BuiltinMethod forEach: directMethods)
             instanceMethods: (BuiltinMethod forEach: instanceMethods)!
    method name
        host name!
    method eval
        host!
    method __addDirectMethod: aMethod
        directMethods add: aMethod!
    method __addInstanceMethod: aMethod
        instanceMethods add: aMethod!
    method isBuiltin
        True!
    method interfaces
        []!
    method isDynamic
        False!
end

define BuiltinClasses [
     BuiltinClass
         new: Array
         mark: "foo_mark_array"
         directMethods: array.DirectMethods
         instanceMethods: array.InstanceMethods,
     BuiltinClass
         new: Block
         mark: "foo_mark_block"
         directMethods: []
         instanceMethods: block.InstanceMethods,
     BuiltinClass
         new: Boolean
         mark: "foo_mark_noop"
         directMethods: boolean.DirectMethods
         instanceMethods: boolean.InstanceMethods,
     BuiltinClass
         new: Float
         mark: "foo_mark_noop"
         directMethods: []
         instanceMethods: float.FloatMethods,
     BuiltinClass
         new: Integer
         mark: "foo_mark_noop"
         directMethods: []
         instanceMethods: integer.IntegerMethods,
     BuiltinClass
         new: Output
         mark: "foo_mark_noop"
         directMethods: output.DirectMethods
         instanceMethods: [],
     BuiltinClass
         new: String
         mark: "foo_mark_noop"
         directMethods: string.DirectMethods
         instanceMethods: string.InstanceMethods
]!

class SelectorMap { names }
    direct method new
        self names: Dictionary new!

    method map: selector
        names
            at: selector name
            ifNonePut: { Name mangleSelector: selector }!

    method do: block
        names do: block!
end

define $home
    False!

class CTranspiler { output selectorMap blockFunctions constants variables tmpCounter }

    direct method transpile: globals in: env
        Debug println: "    #transpile: (0)".
        let visitor = self
                          output: StringOutput new
                          selectorMap: SelectorMap new
                          blockFunctions: List new
                          constants: List new
                          variables: Dictionary new
                          tmpCounter: 0.
        Debug println: "    #transpile: additional selectors".
        -- KLUDGE: add #writeString: to the selectors.
        visitor selectorMap map: #writeString:.
        Debug println: "    #transpile: replace builtins".
        env replaceBuiltins: BuiltinClasses.
        Debug println: "    #transpile: generate declarations".
        let declarations = visitor generateDeclarations: globals.
        Debug println: "    #transpile: globals".
        globals do: { |each| each definition visitBy: visitor }.
        Debug println: "    #transpile: main".
        visitor generateMain.
        Debug println: "    #transpile: finish".
        { declarations: declarations,
          main: visitor output content,
          blocks: visitor generateBlocks,
          constants: visitor generateConstants,
          builtins: visitor generateBuiltins,
          selectors: visitor generateSelectors }!

    method addTemp
        $home addTemp!

    method genTemp: name
        tmpCounter = tmpCounter + 1.
        "tmp{tmpCounter}_{name}"!

    method forwardDeclarationFor: aGlobal
        -- Debug println: "declare: {aGlobal}".
        (BuiltinClass includes: aGlobal)
            ifTrue: { self _classDeclarations: aGlobal }.
        (AstClass includes: aGlobal)
            ifTrue: { self _classDeclarations: aGlobal }.
        (AstInterface includes: aGlobal)
            ifTrue: { self _interfaceDeclarations: aGlobal }.
        aGlobal isDynamic
            ifTrue: {  variables put: (variables size) at: aGlobal name.
                       output println: "struct Foo {Name mangleDynamic: aGlobal};" }
            ifFalse: {  output println: "struct Foo {Name mangleGlobal: aGlobal};" }!

    method _classDeclarations: aClass
        output println: "struct FooVtable {Name mangleClassVtable: aClass};".
        output println: "struct FooVtable {Name mangleInstanceVtable: aClass};"!

    method _interfaceDeclarations: anInterface
        output println: "struct FooVtable {Name mangleInterfaceVtable: anInterface};".
        output println: "struct FooVtable {Name mangleInstanceVtable: anInterface};"!

    method generateMain
        output println: "int main".
        output println: "    (int argc, char** argv)".
        output println: "\{".
        output println: "    fooinit();".
        output println: "    struct FooArray* vars = FooArray_alloc({variables size});".
        variables
            do: { |name offset|
                  let var = {name: name}.
                  output println: "vars->data[{offset}] = {Name mangleDynamic: var};" }.
        output println: "    struct FooContext* ctx = foo_context_new_main(vars);".
        let main = Name mangleGlobal: {name: "Main"}.
        output println: "    foo_send(ctx, &{Name mangleSelector: #run}, {main}, 0);".
        output println: "    return 0;".
        output println: "}"!

    method generateSelectors
        let output = StringOutput new.
        let prev = "NULL".
        selectorMap do: { |name cname|
                         output print: "struct FooSelector ".
                         output print: cname.
                         output print: " = \{ .name = &FOO_CSTRING(".
                         output display: name.
                         output print: "), .next = ".
                         output print: prev.
                         output print: " };\n".
                         prev = "&{cname}" }.
        output println: "struct FooSelector* FOO_InternedSelectors = {prev};".
        output!

    method generateDeclarations: globals
        Debug println: "      #generateDeclarations:".
        StringOutput
            with: { |out|
                    let builtinVisitor = CTranspiler
                                             output: out
                                             selectorMap: selectorMap
                                             blockFunctions: blockFunctions
                                             constants: constants
                                             variables: variables
                                             tmpCounter: tmpCounter.
                    -- FIXME: visit Main, and it's dependencies only
                    BuiltinClasses
                        do: { |each|
                              builtinVisitor forwardDeclarationFor: each }.
                    globals
                        do: { |each|
                              builtinVisitor forwardDeclarationFor: each definition } }!

    method generateBuiltins
        Debug println: "      #generateBuiltins:".
        StringOutput
            with: { |out|
                    let builtinVisitor = CTranspiler
                                             output: out
                                             selectorMap: selectorMap
                                             blockFunctions: blockFunctions
                                             constants: constants
                                             variables: variables
                                             tmpCounter: tmpCounter.
                    -- FIXME: used builtins only
                    BuiltinClasses
                        do: { |each|
                              builtinVisitor visitClassDefinition: each } }!

    method generateBlocks
        StringOutput with: { |out| self generateBlocksOn: out }!

    method generateBlocksOn: out
        blockFunctions do: { |block|
                             out println: block declaration }.
        out newline.
        blockFunctions do: { |block|
                             out println: block definition }!

    method generateConstants
        StringOutput with: { |out| self generateConstantsOn: out }!

    method generateConstantsOn: out
        constants do: { |each| out println: each }!

    method selectorCName: selector
        self selectorMap map: selector!

    method stringCName: string
        let index = constants size + 1.
        let cname = "foostring_id{index}".
        constants
            add: (StringOutput
                      with: { |out|
                              out println: "struct FooBytes {cname}_bytes =".
                              out println: "\{".
                              out println: "    .size = {string size},".
                              out print: "    .data = \{ ".
                              string do: { |each|
                                           out print: "'".
                                           out print: (CEscapes at: each ifNone: { each }).
                                           out print: "'," }.
                              out print: "0".
                              out println: " }".
                              out println: "};".
                              out newline.
                              out println: "struct Foo {cname} =".
                              out println: "\{".
                              out println: "    .vtable = &{Name mangleInstanceVtable: String},".
                              out println: "    .datum = \{ .ptr = &{cname}_bytes }".
                              out println: "};".
                              out newline }).
        cname!

    method blockCName: block
        let $home = block.
        let output = StringOutput new.
        -- Placeholder so that recursive entry by visitor doesn't grab the
        -- same id.
        blockFunctions add: False.
        let index = blockFunctions size.
        let cname = "fooblock_id{index}".
        let signature = StringOutput with: { |out|
                                             out print: "struct Foo ".
                                             out print: cname.
                                             out print: "(struct FooContext* ctx)" }.
        output print: signature.
        output println: " \{".
        -- FIXME: Given that we need to check types here, should also put the args
        -- in frame here, same as in methods.
        block argumentVariables
            do: { |var|
                  let type = var type value.
                  type is Any
                      ifFalse: { output println: "    foo_vtable_typecheck(&{Name mangleInstanceVtable: type}, ctx->frame[{var index-1}]);" } }.
        output print: "    return ".
        let blockVisitor = CTranspiler
                               output: output
                               selectorMap: selectorMap
                               blockFunctions: blockFunctions
                               constants: constants
                               variables: variables
                               tmpCounter: tmpCounter.
        blockVisitor _generateTypecheck: block returnType value
                     _for: block body.
        output println: ";\n}".
        blockFunctions
            put: {declaration: "{signature};", definition: output content}
            at: index.
        cname!

    method visitDefine: aDefine
        let value = aDefine eval.
        aDefine isDynamic
            ifTrue: { output println: "struct Foo {Name mangleDynamic: aDefine} = " }
            ifFalse: { output println: "struct Foo {Name mangleGlobal: aDefine} = " }.
        self visitConstant: {value: value}.
        output println: ";".
        output newline!

    method visitInterfaceDefinition: anInterface
        output println: "/**
* {anInterface name}
*
*/".
        let interfaceVtableName = Name mangleInterfaceVtable: anInterface.
        let instanceVtableName = Name mangleInstanceVtable: anInterface.
        let globalName = Name mangleGlobal: anInterface.
        anInterface directMethods
            do: { |each|
                  self
                      _generateMethod: each
                      _in: anInterface
                      _as: (Name mangleDirectMethod: each selector in: anInterface) }.
        anInterface instanceMethods
            do: { |each|
                  self
                      _generateMethod: each
                      _in: anInterface
                      _as: (Name mangleInstanceMethod: each selector in: anInterface) }.
        -- Interface Vtable
        output println: "struct FooVtable {interfaceVtableName} = ".
        output println: "\{".
        output println: "    .name = &FOO_CSTRING({anInterface name displayString}\" interface\"),".
        output println: "    .inherited = \{ .size = 0, .data = NULL },".
        output println: "    .size = {anInterface directMethods size},".
        output println: "    .mark = foo_mark_noop,".
        output println: "    .methods = \{".
        anInterface directMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{Name mangleDirectMethod: each selector in: anInterface} }," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Instance Vtable (empty, used for identity only)!
        output println: "struct FooVtable {instanceVtableName} = ".
        output println: "\{".
        output println: "    .name = &FOO_CSTRING({anInterface name displayString}),".
        output println: "    .classptr = NULL,". -- FIXME
        output println: "    .inherited = \{ .size = 0, .data = NULL },".
        output println: "    .mark = foo_mark_noop,".
        output println: "    .size = 0,".
        output println: "    .methods = \{}".
        output println: "};".
        output newline.
        -- Interface struct
        let interfaceName = "FooInterface_{anInterface name}".
        output println: "struct FooInterface {interfaceName} = \{};".
        output newline.
        -- Interface object
        output println: "struct Foo {globalName} =".
        output println: "\{".
        output println: "    .vtable = &{interfaceVtableName},".
        output println: "    .datum = \{ .ptr = &{interfaceName} }".
        output println: "};".
        output newline!

    method visitClassDefinition: aClass
        -- Debug println: "#visitClassDefinition: {aClass name}".
        let classNote = aClass isBuiltin
                       ifTrue: { "{aClass name} (builtin)" }
                       ifFalse: { aClass name }.
        output println: "/**
 * {classNote}
 *
 */".
        let instanceVtableName = Name mangleInstanceVtable: aClass.
        let classVtableName = Name mangleClassVtable: aClass.
        let globalName = Name mangleGlobal: aClass.
        let directMethods = aClass directMethods copy. -- Augmented later with ctor
        directMethods
            do: { |each|
                  self
                      _generateMethod: each
                      _in: aClass
                      _as: (Name mangleDirectMethod: each selector in: aClass) }.
        aClass instanceMethods
            do: { |each|
                  self
                      _generateMethod: each
                      _in: aClass
                      _as: (Name mangleInstanceMethod: each selector in: aClass) }.
        aClass isBuiltin
            ifFalse: {
                -- Layout
                let layoutName = "FooLayout_{aClass name}".
                output println: "struct FooLayout {layoutName} =".
                output println: "\{".
                output println: "    .size = {aClass slots size},".
                output println: "    .slots = \{".
                aClass slots
                    do: { |each|
                          output println: "        \{ .name = &FOO_CSTRING({each name displayString}) }," }.
                output println: "    }".
                output println: "};".
                output newline.
                -- Constructor
                let ctor = aClass constructor.
                directMethods push: { selector: ctor, arity: aClass slots size, frameSize: aClass slots size }.
                let ctorName = Name mangleDirectMethod: ctor in: aClass.
                output newline.
                output print: "struct Foo ".
                output println: ctorName.
                output println: "    (struct FooContext* ctx)".
                output println: "\{".
                output println: "    (void)ctx;".
                output println: "    struct FooArray* new = FooArray_alloc({aClass slots size} * sizeof(struct Foo));".
                aClass slots
                    doWithIndex: { |each index|
                                   let type = each type value.
                                   type is Any
                                       ifTrue: { output println: "new->data[{index-1}] = ctx->frame[{index-1}];" }
                                       ifFalse: { output println: "new->data[{index -1}] = foo_vtable_typecheck(&{Name mangleInstanceVtable: type}, ctx->frame[{index-1}]);" } }.
                output println: "    return (struct Foo)\{ .vtable = &{instanceVtableName}, .datum = \{ .ptr = new } };".
                output println: "}".
                output newline
            }.
        -- Interfaces
        let classInterfacesName = "FooClassInterfaces_{aClass name}".
        output println: "struct FooVtable* {classInterfacesName}[] = \{".
        aClass interfaces
            do: { |each|
                  output println: "    &{Name mangleInterfaceVtable: each}," }.
        output println: "};".
        output newline.
        let instanceInterfacesName = "FooInstanceInterfaces_{aClass name}".
        output println: "struct FooVtable* {instanceInterfacesName}[] = \{".
        aClass interfaces
            do: { |each|
                  output println: "    &{Name mangleInstanceVtable: each}," }.
        output println: "};".
        output newline.
        -- Class Vtable
        output println: "struct FooVtable {classVtableName} = ".
        output println: "\{".
        output println: "    .name = &FOO_CSTRING({aClass name displayString}\" class\"),".
        output println: "    .classptr = NULL,". -- FIXME
        output println: "    .inherited = \{ .size = {aClass interfaces size}, .data = {classInterfacesName} },".
        output println: "    .mark = foo_mark_noop,".
        output println: "    .size = {directMethods size},".
        output println: "    .methods = \{".
        directMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{Name mangleDirectMethod: each selector in: aClass} }," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Instance Vtable
        output println: "struct FooVtable {instanceVtableName} = ".
        output println: "\{".
        output println: "    .name = &FOO_CSTRING({aClass name displayString}),".
        output println: "    .classptr = &{globalName},".
        output println: "    .inherited = \{ .size = {aClass interfaces size}, .data = {instanceInterfacesName} },".
        output println: "    .mark = {aClass markFunction},".
        output println: "    .size = {aClass instanceMethods size},".
        output println: "    .methods = \{".
        aClass instanceMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{Name mangleInstanceMethod: each selector in: aClass} }," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Class struct
        let className = "FooClass_{aClass name}".
        output println: "struct FooClass {className} = ".
        output println: "\{".
        output println: "    .instanceVtable = &{instanceVtableName}".
        output println: "};".
        output newline.
        -- Class object
        output println: "struct Foo {globalName} =".
        output println: "\{".
        output println: "    .vtable = &{classVtableName},".
        output println: "    .datum = \{ .ptr = &{className} }".
        output println: "};".
        output newline!

    method _generateMethod: aMethod _in: aClass _as: mangledName
        let $home = aMethod.
        output print: "struct Foo ".
        output println: mangledName.
        output println: "    (struct FooContext* ctx)".
        output println: "\{".
        output println: "    (void)ctx;".
        aMethod signature
            doWithIndex: { |type index|
                           type is Any
                               ifFalse: { output println: "    foo_vtable_typecheck(&{Name mangleInstanceVtable: type}, ctx->frame[{index-1}ul]);" } }.
        aMethod isBuiltin
            ifTrue: {  output print: "    ".
                       output println: (aMethod body replace: "\n" with: "\n    ").
                       output println: "}" }
            ifFalse: { output print: "    return ".
                       self _generateTypecheck: aMethod returnType value
                            _for: aMethod body.
                       output println: ";".
                       output println: "}" }.
        output newline!

    method visitGlobal: aVar
        output print: (Name mangleGlobal: aVar)!

    method visitDynamic: aVar
        let index = variables
                        at: aVar name
                        ifNone: { Error raise: "No index for: {aVar}" }.
        output print: "ctx->vars->data[{index}]"!

    method _generateTypecheck: type _for: value
        type is Any
            ifTrue: { return value visitBy: self }.
        output print: "foo_vtable_typecheck(&".
        output print: (Name mangleInstanceVtable: type).
        output print: ", ".
        value visitBy: self.
        output print: ")"!

    method visitTypecheck: aCheck
        self _generateTypecheck: aCheck type
             _for: aCheck value!

    method visitIs: anIs
        let left = self addTemp.
        output print: "(\{ ctx->frame[{left}] = ".
        anIs left visitBy: self.
        output print: "; ".
        let right = self addTemp.
        output print: "ctx->frame[{right}] = ".
        anIs right visitBy: self.
        output print: "; ".
        output print: "foo_Boolean_new(ctx->frame[{left}].vtable == ctx->frame[{right}].vtable && ctx->frame[{left}].datum.int64 == ctx->frame[{right}].datum.int64); ".
        output print: "})"!

    method visitSeq: seq
        output print: "(\{ ".
        seq first visitBy: self.
        output print: "; ".
        seq then visitBy: self.
        output print: "; })"!

    method visitSlotSet: set
        output print: "(PTR(FooArray, ctx->receiver.datum)->data[".
        output print: (set slot index - 1).
        output print: "] = ".
        self _generateTypecheck: set slot type value
             _for: set value.
        output print: ")"!

    method visitSlotRef: ref
        output print: "PTR(FooArray, ctx->receiver.datum)->data[".
        output print: (ref slot index - 1).
        output print: "]"!

    method visitReturn: ret
        output print: "foo_return(ctx, ".
        self _generateTypecheck: ret from returnType value
            _for: ret value.
        output print: ")"!

    method visitComment: aComment
        -- FIXME: Include comments in generated source.
        aComment value visitBy: self!

    method generateConstantDatum: value
        (Integer includes: value)
            ifTrue: { return output print: ".int64 = {value}" }.
        (Float includes: value)
            ifTrue: { return output print: ".float64 = {value}" }.
        (String includes: value)
            ifTrue: { return output print: ".ptr = &{self stringCName: value}_bytes" }.
        (Boolean includes: value)
            ifTrue: { let bit = value ifTrue: { 1 } ifFalse: { 0 }.
                      return output print: ".boolean = {bit}" }.
        Error raise: "Don't know how to transpile constant `{value}` into C."!

    method visitConstant: aConstant
        let value = aConstant value.
        output print: "(struct Foo)\{ .vtable = &{Name mangleInstanceVtable: value classOf}, .datum = \{ ".
        self generateConstantDatum: value.
        output println: " } }".
        output newline!

    method visitSend: aSend
        output print: "(\{ ".
        let argVars = aSend arguments
                          collect: { |each|
                                     let index = self addTemp.
                                     output print: "ctx->frame[{index}] = ".
                                     each visitBy: self.
                                     output print: "; ".
                                     index }.
        output print: "foo_send(ctx, &".
        output print: (self selectorCName: aSend selector).
        output print: ", ".
        aSend receiver visitBy: self.
        output print: ", ".
        output print: aSend arguments size.
        output print: "ul".
        argVars
            do: { |index|
                  output print: ", ctx->frame[{index}]" }.
        output print: "); })"!

    method visitSelfInstance: aSelf
        output print: "ctx->receiver"!

    method visitSelfClass: aSelf
        output print: "*ctx->receiver.vtable->classptr"!

    method visitBindDynamic: aBind
        let name = aBind variable name.
        let index = variables at: name.
        let unbind = self genTemp: "unbind".
        output print: "(\{ struct FooUnbind {unbind} = \{ .cleanup = \{ .function = foo_unbind, .next = ctx->cleanup }, .index = {index}, .value = ctx->vars->data[{index}] };".
        output print: " ctx->cleanup = &{unbind}.cleanup;".
        output print: " ctx->vars->data[{index}] = ".
        aBind value visitBy: self.
        output print: ";".
        let res = self addTemp.
        output print: " ctx->frame[{res}] = ".
        aBind body visitBy: self.
        output print: ";".
        output print: " assert(&{unbind}.cleanup == ctx->cleanup);".
        output print: " ctx->cleanup = ctx->cleanup->next;".
        output print: " foo_unbind(ctx, &{unbind}.cleanup);".
        output print: " ctx->frame[{res}]; })"!

    method visitBindLexical: aBind
        output print: "(\{ ctx->frame[{aBind variable index - 1}ul] = ".
        self _generateTypecheck: aBind variable type value
             _for: aBind value.
        output print: ";".
        aBind body visitBy: self.
        output print: "; })"!

    method visitLexicalRef: aRef
        output print: "foo_lexical_ref(ctx, {aRef variable index - 1}ul, {aRef frameOffset}ul)"!

    method visitLexicalSet: aSet
        output print: "foo_lexical_set(ctx, {aSet variable index - 1}ul, {aSet frameOffset}u, ".
        self _generateTypecheck: aSet variable type value
             _for: aSet value.
        output print: ")"!

    method visitBlock: aBlock
        output print: "foo_block_new(ctx, ".
        output print: (self blockCName: aBlock).
        output print: ", ".
        output print: aBlock argumentCount.
        output print: ", ".
        output print: aBlock frameSize.
        output print: ")"!

    method visitArray: anArray
        let entries = anArray entries.
        let array = self addTemp.
        output print: "(\{ ctx->frame[{array}] = foo_Array_alloc({entries size}); ".
        entries isEmpty
            ifFalse: { let p = self genTemp: "arrayPtr".
                       output print: "struct FooArray* {p} = PTR(FooArray, ctx->frame[{array}].datum);".
                       entries
                           doWithIndex: { |each index|
                                          output print: "{p}->data[{index-1}] = ".
                                          each visitBy: self.
                                          output print: "; " } }.
        output print: "ctx->frame[{array}]; })"!

    method visitPanic: aPanic
        output println: "foo_panic(".
        aPanic value visitBy: self.
        output println: ")"!
end
