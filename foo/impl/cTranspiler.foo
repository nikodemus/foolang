import .transpiler.record
import .transpiler.array
import .transpiler.boolean
import .transpiler.byte_array
import .transpiler.character
import .transpiler.closure
import .transpiler.float
import .transpiler.integer
import .transpiler.name.Name
import .transpiler.output
import .transpiler.selector
import .transpiler.string
import .transpiler.system
import .ast.*
import .utils.*

define CEscapes
    { "'" -> "\\'",
      "\\" -> "\\\\",
      "\t" -> "\\t",
      "\n" -> "\\n",
      "\r" -> "\\r" }!

-- define Tracer DebugTracer name: "CTranspiler"!
define Tracer NullTracer!

class BuiltinMethod { home selector definition isDirect }
    direct method forEach: builtins in: home direct: areDirect
        let dict = Dictionary new.
        builtins
            do: { |selector definition|
                  dict at: selector name
                       put: (self
                                 home: home
                                 selector: selector
                                 definition: definition
                                 isDirect: areDirect) }.
        dict!
    method isBuiltin
        True!
    method isRequired
        False!
    method arity
        definition signature size!
    method frameSize
        self arity + self definition vars!
    method signature
        definition signature!
    method body
        definition body!
    method printOn: stream
        stream print: "#<BuiltinMethod {selector}>"!
    method displayOn: stream
        self printOn: stream!
    method toString
        StringOutput with: { |out| self printOn: out }!
end

define DatumClasses
    [Boolean, Character, Integer, Float]!

class Builtin { type value markFunction _interfaces
                _builtinDirectMethods _builtinInstanceMethods
                _directMethods _instanceMethods _allInterfaces }
    is AstMethodHome

    direct method type: type
                  value: value
                  mark: mark
                  directMethods: directMethods
                  instanceMethods: instanceMethods
        let theClass = self
                           type: type
                           value: value
                           markFunction: mark
                           _interfaces: List new
                           _builtinDirectMethods: directMethods
                           _builtinInstanceMethods: instanceMethods
                           _directMethods: False
                           _instanceMethods: False
                           _allInterfaces: False.
        theClass _directMethods: directMethods.
        theClass _instanceMethods: instanceMethods.
        theClass!

    -- FIXME/KLUDGE: This is a terrible hack borne out of bootstrap
    -- host globals being mutable. If they weren't, then CTranspiler
    -- would have to do the right thing instead of mutating static
    -- objects...
    method reset
        _interfaces = List new.
        _allInterfaces = False.
        self _directMethods: _builtinDirectMethods.
        self _instanceMethods: _builtinInstanceMethods.
        self!

    method _interfaces
        _interfaces!

    method _directMethods
        _directMethods!

    method _instanceMethods
        _instanceMethods!

    method _readerMethods
        []!

    method _allInterfaces
        _allInterfaces!

    method _allInterfaces: list
        (_allInterfaces is False) assert: "Oops, _allInterfaces already set!".
        _allInterfaces = list asArray!

    method _directMethods: methods
        _directMethods = BuiltinMethod forEach: methods in: self direct: True!

    method _instanceMethods: methods
        _instanceMethods = BuiltinMethod forEach: methods in: self direct: False!

    method visitBy: visitor
        visitor visitBuiltin: self!

    method name
        value name!

    method eval
        value!

    method isBuiltin
        True!

    method isDynamic
        False!

    method printOn: stream
        stream print: self toString!

    method toString
        "#<Builtin{type name} {self name}>"!
end

class System {}
end

define Builtins [
     Builtin
         type: Class
         value: Array
         mark: "foo_mark_array"
         directMethods: array.DirectMethods
         instanceMethods: array.InstanceMethods,
     Builtin
         type: Class
         value: Boolean
         mark: "foo_mark_raw"
         directMethods: boolean.DirectMethods
         instanceMethods: boolean.InstanceMethods,
     Builtin
         type: Class
         value: ByteArray
         mark: "foo_mark_bytes"
         directMethods: byte_array.DirectMethods
         instanceMethods: byte_array.InstanceMethods,
     Builtin
         type: Class
         value: Character
         mark: "foo_mark_raw"
         directMethods: character.DirectMethods
         instanceMethods: character.InstanceMethods,
     Builtin
         type: Class
         value: Closure
         mark: "foo_mark_closure"
         directMethods: Dictionary new
         instanceMethods: closure.InstanceMethods,
     Builtin
         type: Class
         value: Float
         mark: "foo_mark_raw"
         directMethods: Dictionary new
         instanceMethods: float.FloatMethods,
     Builtin
         type: Class
         value: Integer
         mark: "foo_mark_raw"
         directMethods: Dictionary new
         instanceMethods: integer.IntegerMethods,
     Builtin
         type: Class
         value: Output
         mark: "foo_mark_raw"
         directMethods: output.DirectMethods
         instanceMethods: Dictionary new,
     Builtin
         type: Interface
         value: Record
         mark: "foo_mark_raw"
         directMethods: record.DirectMethods
         instanceMethods: record.InstanceMethods,
     Builtin
         type: Class
         value: Selector
         mark: "foo_mark_raw"
         directMethods: selector.DirectMethods
         instanceMethods: selector.InstanceMethods,
     Builtin
         type: Class
         value: String
         mark: "foo_mark_bytes"
         directMethods: string.DirectMethods
         instanceMethods: string.InstanceMethods,
    Builtin
         type: Class
         value: System
         mark: "foo_mark_raw"
         directMethods: system.DirectMethods
         instanceMethods: system.InstanceMethods
]!

class SelectorMap { names }
    direct method new
        self names: Dictionary new!

    method map: selector
        names
            at: selector name
            ifNonePut: { Name mangleSelector: selector }!

    method do: block
        names do: block!
end

define AlwaysEmittedSelectors
    [#__doSelectors:,
     #perform:with:,
     #writeString:]!

define $home
    False!

class CTranspiler { output selectorMap closureFunctions
                    constants variables tmpCounter
                    globals generatedMethods env }

    direct method transpile: string in: env
        -- Clean up from previous run.
        Builtins do: #reset.
        env removeBuiltins: [
            "Any",
            "DoesNotUnderstand",
            "Error",
            "List",
            "Object",
            "StringOutput",
            "TypeError"
        ].
        env replaceBuiltins: Builtins.
        env load: string.
        self transpileMain: (env global: "Main") in: env!

    direct method transpileMain: main in: env
        let visitor = CTranspiler
                          output: StringOutput new
                          selectorMap: SelectorMap new
                          closureFunctions: List new
                          constants: List new
                          variables: Dictionary new
                          tmpCounter: 0
                          globals: Dictionary new
                          generatedMethods: Dictionary new
                          env: env.
        -- KLUDGE: ensure selectors with references from C code
        AlwaysEmittedSelectors
            do: { |each| visitor selectorMap map: each }.
        let builtins = visitor generateBuiltins.
        visitor declare: main.
        visitor writeDefinitions.
        visitor writeMain.
        { main: visitor output,
          builtins: builtins,
          closures: visitor generateClosures,
          constants: visitor generateConstants,
          declarations: visitor generateDeclarations,
          selectors: visitor generateSelectors }!

    method addTemp
        $home addTemp!

    method declare: global
        -- Debug println: "#declare: {global}".
        globals at: (global name)
                ifNonePut: { global definition }!

    method declareDynamic: var
        self declare: var.
        variables at: var name ifNonePut: { variables size }!

    method genTemp: name
        tmpCounter = tmpCounter + 1.
        "tmp{tmpCounter}_{name}"!

    method forwardDeclarationFor: aGlobal
        -- Debug println: "declare: {aGlobal}".
        (Builtin includes: aGlobal)
            ifTrue: { self _classDeclarations: aGlobal }.
        (AstClass includes: aGlobal)
            ifTrue: { self _classDeclarations: aGlobal }.
        (AstInterface includes: aGlobal)
            ifTrue: { self _interfaceDeclarations: aGlobal }.
        (AstBuiltin includes: aGlobal)
            ifTrue: { return False }.
        aGlobal isDynamic
            ifTrue: { self declareDynamic: aGlobal.
                      output println: "struct Foo {Name mangleDynamic: aGlobal};" }
            ifFalse: {  output println: "struct Foo {Name mangleGlobal: aGlobal};" }!

    method _classDeclarations: aClass
        output println: "struct FooVtable {Name mangleDirectVtable: aClass};".
        output println: "struct FooVtable {Name mangleInstanceVtable: aClass};".
        let isOwnDefinition
                = { |def| def home is aClass }.
        (aClass directMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }.
        (aClass instanceMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }!

    method _interfaceDeclarations: anInterface
        output println: "struct FooVtable {Name mangleDirectVtable: anInterface};".
        output println: "struct FooVtable {Name mangleInstanceVtable: anInterface};".
        let isOwnDefinition
                = { |def| def home is anInterface and: def isRequired not }.
        (anInterface directMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }.
        (anInterface instanceMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }!

    method _methodDeclaration: aMethod
        output print: "struct Foo ".
        output print: (Name mangleMethod: aMethod).
        output println: "(struct FooContext*);"!

    method writeDefinitions
        -- Processing a definition can produce new global references. Visit
        -- each definition only once, finish with the full collection.
        let allGlobals = Dictionary new.
        { globals isEmpty }
            whileFalse: { let old = globals.
                          globals = Dictionary new.
                          old do: { |name def|
                                    allGlobals at: name
                                               ifNone: { allGlobals put: def at: name.
                                                         def visitBy: self } } }.
        globals = allGlobals!

    method writeMain
        output println: "int main".
        output println: "    (int argc, char** argv)".
        output println: "\{".
        output println: "    fooinit();".
        output println: "    struct FooArray* vars = FooArray_alloc({variables size});".
        variables
            do: { |name offset|
                  let var = {name: name}.
                  output print: "vars->data[{offset}] = ".
                  output print: (Name mangleDynamic: var).
                  output println: ";" }.
        output println: "    struct FooContext* ctx = foo_context_new_main(vars);".
        let main = Name mangleGlobal: {name: "Main"}.
        output println: "    struct Foo system = \{ .vtable = &FooInstanceVtable_System, .datum = \{ .ptr = NULL } };".
        output println: "    foo_send(ctx, &{Name mangleSelector: #runIn:}, {main}, 1, system);".
        output println: "    return 0;".
        output println: "}"!

    method generateSelectors
        let output = StringOutput new.
        let prev = "NULL".
        selectorMap do: { |name cname|
                         output print: "struct FooSelector ".
                         output print: cname.
                         output print: " = \{ .name = &FOO_CSTRING(".
                         output display: name.
                         output print: "), .next = ".
                         output print: prev.
                         output print: " };\n".
                         prev = "&{cname}" }.
        output println: "struct FooSelector* FOO_InternedSelectors = {prev};".
        output!

    method generateDeclarations
        -- Debug println: "      #generateDeclarations".
        let output = StringOutput new.
        let builtinVisitor = CTranspiler
                                 output: output
                                 selectorMap: selectorMap
                                 closureFunctions: closureFunctions
                                 constants: constants
                                 variables: variables
                                 tmpCounter: tmpCounter
                                 globals: globals
                                 generatedMethods: generatedMethods
                                 env: env.
        -- FIXME: visit only referenced builtins
        Builtins
            do: { |each|
                  builtinVisitor forwardDeclarationFor: each }.
        globals
            doValues: { |each|
                        builtinVisitor forwardDeclarationFor: each }.
        closureFunctions
            do: { |closure|
                  output print: closure declaration.
                  output println: ";" }.
        output!

    method generateBuiltins
        -- Debug println: "      #generateBuiltins:".
        let output = StringOutput new.
        let builtinVisitor = CTranspiler
                                 output: output
                                 selectorMap: selectorMap
                                 closureFunctions: closureFunctions
                                 constants: constants
                                 variables: variables
                                 tmpCounter: tmpCounter
                                 globals: globals
                                 generatedMethods: generatedMethods
                                 env: env.
        -- FIXME: used builtins only
        Builtins
            do: { |each|
                  builtinVisitor visitClassDefinition: each }.
        output!

    method generateClosures
        self generateClosuresOn: StringOutput new!

    method generateClosuresOn: out
        closureFunctions do: { |closure|
                             out println: closure definition }.
        out!

    method generateConstants
        self generateConstantsOn: StringOutput new!

    method generateConstantsOn: out
        constants do: { |each| out println: each declaration }.
        constants do: { |each| out println: each definition }.
        out!

    method selectorCName: selector
        self selectorMap map: selector!

    method constantCName: value in: env
        -- Tracer constantCName: value.
        (Selector includes: value)
            ifTrue: { return self selectorCName: value }.
        constants
            do: { |each|
                  each value == value
                      ifTrue: { return each cname } }.
        let index = constants size + 1.
        let cname = "fooconst_{Name mangleName: value classOf name}_{index}".
        -- Placeholder in case of recursive entry.
        constants add: { value: value, cname: cname }.
        constants at: index
                  put: (self _constantDefinition: value
                             _in: env
                             _called: cname).
        cname!

    method _isPtr: value
        let theClass = value classOf.
        (DatumClasses contains: theClass)
            ifTrue: { return False }.
        True!

    method _writeDatum: value _in: env _to: out
        -- Tracer visitDatum: value.
        (self _isPtr: value)
            ifTrue: { return out print: ".ptr = &{self constantCName: value in: env}" }.
        (Boolean includes: value)
            ifTrue: { let bit = value ifTrue: { 1 } ifFalse: { 0 }.
                      return out print: ".boolean = {bit}" }.
        (Character includes: value)
            ifTrue: { return out print: ".int64 = {value code}" }.
        (Float includes: value)
            ifTrue: { return out print: ".float64 = {value}" }.
        (Integer includes: value)
            ifTrue: { return out print: ".int64 = {value}" }.
        Error raise: "Don't know how to transpile constant `{value}` into C."!

    method _targetClassOf: value _in: env
        -- Tracer _targetClassOf: value.
        (Record includes: value)
            ifTrue: { return self _recordClassFromRecord: value }.
        (Class includes: value)
            ifTrue: { return env global: value name }.
        env global: value classOf name!

    method _recordClassFromRecord: aRecord
        let keys = (Record keysIn: aRecord) sorted.
        let name = Selector
                       new: (StringOutput
                                 with: { |out|
                                         keys do: { |each| out print: "{each}:" }}).
        self _ensureRecordClass: { name: name,
                                   slots: keys }!

    method _writeValue: value _in: env _to: out
        (Class includes: value)
            ifTrue: { out print: "(struct Foo)\{ .vtable = &{Name mangleDirectVtable: (self _targetClassOf: value _in: env)}, .datum = \{ " }
            ifFalse: { out print: "(struct Foo)\{ .vtable = &{Name mangleInstanceVtable: (self _targetClassOf: value _in: env)}, .datum = \{ " }.
        self _writeDatum: value _in: env _to: out.
        out println: " } }"!

    method _constantDefinition: value _in: env _called: cname
        -- Tracer _constantDefinition: value.
        (Array includes: value)
            ifTrue: { return
                          { value: value,
                            cname: cname,
                            declaration: "struct FooArray {cname};",
                            definition: (self _arrayDefinition: value
                                              _in: env
                                              _called: cname) } }.
        (Record includes: value)
            ifTrue: { return
                          { value: value,
                            cname: cname,
                            declaration: "struct FooArray {cname};",
                            definition: (self _recordDefinition: value
                                              _in: env
                                              _called: cname) } }.
        (String includes: value)
            ifTrue: { return
                          { value: value,
                            cname: cname,
                            declaration: "struct FooBytes {cname};",
                            definition: (self _stringDefinition: value
                                              _called: cname) } }.
        { value: value,
          cname: cname,
          declaration: "struct FooArray {cname};",
          definition: (self _instanceDefinition: value
                            _in: env
                            _called: cname) }!

    method _arrayDefinition: value _in: env _called: cname
        StringOutput
            with: { |out|
                    out println: "struct FooArray {cname} =".
                    out println: "\{".
                    out println: "    .gc = false,".
                    out println: "    .size = {value size},".
                    out print: "    .data = \{ ".
                    value do: { |each|
                                self _writeValue: each
                                     _in: env
                                     _to: out.
                                out print: "," }.
                    out println: " }".
                    out println: "};" }!

    method _instanceDefinition: value _in: env _called: cname
        -- Tracer _instanceDefinition: value _in: env.
        -- Debug println: "XXX: {value} IN:\n {env globals}".
        let theClass = self _targetClassOf: value _in: env.
        self declare: theClass.
        let slots = theClass definition slots.
        StringOutput
            with: { |out|
                    out println: "struct FooArray {cname} =".
                    out println: "\{".
                    out println: "    .gc = false,".
                    out println: "    .size = {slots size},".
                    out print: "    .data = \{ ".
                    slots
                        do: { |each|
                              self _writeValue: ((Selector new: each name)
                                                     sendTo: value)
                                   _in: env
                                   _to: out.
                              out print: "," }.
                    out println: " }".
                    out println: "};" }!

    method _recordDefinition: value _in: env _called: cname
        StringOutput
            with: { |out|
                    out println: "struct FooArray {cname} =".
                    out println: "\{".
                    out println: "    .gc = false,".
                    out println: "    .size = {Record sizeOf: value},".
                    out print: "    .data = \{ ".
                    value do: { |each|
                                self _writeValue: each _in: env _to: out.
                                out print: "," }.
                    out println: " }".
                    out println: "};" }!

    method _stringDefinition: value _called: cname
        StringOutput
            with: { |out|
                    out println: "struct FooBytes {cname} =".
                    out println: "\{".
                    out println: "    .gc = false,".
                    out println: "    .size = {value size},".
                    out print: "    .data = \{ ".
                    value do: { |each|
                                out print: "'".
                                out print: (CEscapes at: each ifNone: { each }).
                                out print: "'," }.
                    out print: "0".
                    out println: " }".
                    out println: "};" }!

    method closureCName: closure
        let $home = closure.
        let output = StringOutput new.
        -- Placeholder so that recursive entry by visitor doesn't grab the
        -- same id.
        closureFunctions add: False.
        let index = closureFunctions size.
        let cname = "fooclosure_id{index}".
        let signature = StringOutput new.
        signature print: "struct Foo ".
        signature print: cname.
        signature print: "(struct FooContext* ctx)".
        output print: signature.
        output println: " \{".
        -- FIXME: Given that we need to check types here, should also put the args
        -- in frame here, same as in methods.
        closure argumentVariables
            do: { |var|
                  let type = var type.
                  type is Any
                      ifFalse: { output println: "    foo_vtable_typecheck(ctx, &{Name mangleInstanceVtable: type}, ctx->frame[{var index-1}]);" } }.
        output print: "    return ".
        let closureVisitor = CTranspiler
                               output: output
                               selectorMap: selectorMap
                               closureFunctions: closureFunctions
                               constants: constants
                               variables: variables
                               tmpCounter: tmpCounter
                               globals: globals
                               generatedMethods: generatedMethods
                               env: env.
        closureVisitor _generateTypecheck: closure returnType
                     _for: closure body.
        output println: ";\n}".
        closureFunctions
            put: { declaration: signature, definition: output }
            at: index.
        cname!

    method visitBuiltin: aClass
        -- Tracer trace: #visitBuiltin:.
        self!

    method visitDefine: aDefine
        Tracer visitDefine: aDefine.
        aDefine isDynamic
            ifTrue: { output println: "struct Foo {Name mangleDynamic: aDefine} = " }
            ifFalse: { output println: "struct Foo {Name mangleGlobal: aDefine} = " }.
        -- FIXME: harmonize #eval vs #value
        self _writeValue: aDefine eval _in: aDefine env _to: output.
        output println: ";".
        output newline!

    method _ensureRecordClass: aRecord
        globals at: aRecord name name -- Selector don't play nice in tables yet!
                ifNonePut: { self _createRecordClass: aRecord }!

    method _createRecordClass: aRecord
        let theClass = AstClass
                           name: (String concat: ["Record_", aRecord name name replace: ":" with: "$"])
                           slots: (aRecord slots
                                       collectWithIndex: { |each index|
                                                           AstSlot name: each
                                                                   index: index
                                                                   type: Any })
                           interfaces: [env global: "Record"].
        theClass directMethods: [].
        theClass instanceMethods: [].
        theClass!

    method visitRecord: aRecord
        -- Tracer visitRecord: aRecord.
        let recordClass = self _ensureRecordClass: aRecord.
        output print: "foo_send(ctx".
        output print: ", &{Name mangleSelector: aRecord name}".
        output print: ", {Name mangleGlobal: recordClass}".
        output print: ", {aRecord values size}".
        output print: ", ".
        aRecord values
            do: { |each| each visitBy: self }
            interleaving: { output print: ", " }.
        output print: ")"!

    method visitInterfaceDefinition: anInterface
        Tracer visitInterfaceDefinition: anInterface name.
        -- Debug println: "interface: {anInterface name}".
        output println: "/**
* {anInterface name} (an interface)
*
*/".
        let interfaceVtableName = Name mangleDirectVtable: anInterface.
        let instanceVtableName = Name mangleInstanceVtable: anInterface.
        let globalName = Name mangleGlobal: anInterface.
        -- Augmented with #includes:
        let directMethods = (anInterface directMethods reject: #isRequired) asList.
        directMethods
            do: { |each| self _generateMethod: each _for: anInterface name }.
        -- FIXME: Currently Any has it's own definition
        (directMethods find: { |each| each selector == #includes: }) is False
            ifTrue: { let includes = { home: anInterface,
                                       selector: #includes:,
                                       arity: 1,
                                       frameSize: 1,
                                       isDirect: True }.
                      directMethods push: includes.
                      output print: "struct Foo ".
                      output println: (Name mangleMethod: includes).
                      output println: "    (struct FooContext* ctx)".
                      output println: "\{".
                      output println: "    return foo_vtable_includes(ctx, &{Name mangleInstanceVtable: anInterface}, ctx->frame[0]);".
                      output println: "}".
                      output newline }.
        (anInterface instanceMethods reject: #isRequired)
            do: { |each| self _generateMethod: each _for: anInterface name }.
        -- Interface Vtable
        output println: "struct FooVtable {interfaceVtableName} = ".
        output println: "\{".
        output println: "    .name = &FOO_CSTRING({anInterface name displayString}\" interface\"),".
        output println: "    .inherited = \{ .size = 0, .data = NULL },".
        output println: "    .size = {directMethods size},".
        output println: "    .mark = foo_mark_raw,".
        output println: "    .methods = \{".
        directMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .vtable = &{Name mangleMethodVtable: each},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{Name mangleMethod: each} }," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Instance Vtable (empty, used for identity only)!
        output println: "struct FooVtable {instanceVtableName} = ".
        output println: "\{".
        output println: "    .name = &FOO_CSTRING({anInterface name displayString}),".
        output println: "    .classptr = NULL,". -- FIXME
        output println: "    .inherited = \{ .size = 0, .data = NULL },".
        output println: "    .mark = NULL,".
        output println: "    .size = 0,".
        output println: "    .methods = \{}".
        output println: "};".
        output newline.
        -- Interface struct
        let interfaceName = "FooInterface_{anInterface name}".
        output println: "struct FooInterface {interfaceName} = \{};".
        output newline.
        -- Interface object
        output println: "struct Foo {globalName} =".
        output println: "\{".
        output println: "    .vtable = &{interfaceVtableName},".
        output println: "    .datum = \{ .ptr = &{interfaceName} }".
        output println: "};".
        output newline!

    method visitClassDefinition: aClass
        Tracer visitClassDefinition: aClass name.
        -- Debug println: "class: {aClass name}".
        let classNote = aClass isBuiltin
                       ifTrue: { "{aClass name} (builtin)" }
                       ifFalse: { aClass name }.
        output println: "/**
 * {classNote}
 *
 */".
        let instanceVtableName = Name mangleInstanceVtable: aClass.
        let classVtableName = Name mangleDirectVtable: aClass.
        let globalName = Name mangleGlobal: aClass.
        -- Augmented later with ctor and typetest
        -- Debug println: "/class direct methods".
        let directMethods = aClass directMethods asList.
        directMethods
            do: { |each| self _generateMethod: each _for: aClass name }.
        -- Debug println: "/class instance methods".
        let instanceMethods = aClass instanceMethods.
        instanceMethods
            do: { |each| self _generateMethod: each _for: aClass name }.
        aClass isBuiltin
            ifFalse: {
                -- Layout
                let layoutName = "FooLayout_{aClass name}".
                output println: "struct FooLayout {layoutName} =".
                output println: "\{".
                output println: "    .size = {aClass slots size},".
                output println: "    .slots = \{".
                aClass slots
                    do: { |each|
                          output println: "        \{ .name = &FOO_CSTRING({each name displayString}) }," }.
                output println: "    }".
                output println: "};".
                output newline.
                -- Constructor
                let ctor = { home: aClass,
                             selector: aClass constructor,
                             arity: aClass slots size,
                             frameSize: aClass slots size,
                             isDirect: True }.
                directMethods push: ctor.
                output print: "struct Foo ".
                output println: (Name mangleMethod: ctor).
                output println: "    (struct FooContext* ctx)".
                output println: "\{".
                output println: "    (void)ctx;".
                output println: "    struct FooArray* new = FooArray_alloc({aClass slots size} * sizeof(struct Foo));".
                aClass slots
                    doWithIndex: { |each index|
                                   let type = each type.
                                   -- FIXME: visit the type
                                   type is Any
                                       ifTrue: { output println: "new->data[{index-1}] = ctx->frame[{index-1}];" }
                                       ifFalse: { output println: "new->data[{index -1}] = foo_vtable_typecheck(ctx, &{Name mangleInstanceVtable: type}, ctx->frame[{index-1}]);" } }.
                output println: "    return (struct Foo)\{ .vtable = &{instanceVtableName}, .datum = \{ .ptr = new } };".
                output println: "}".
                output newline
            }.
        -- #includes: (typetest)
        let includes = { home: aClass,
                         selector: #includes:,
                         arity: 1,
                         frameSize: 1,
                         isDirect: True }.
        directMethods push: includes.
        output print: "struct Foo ".
        output println: (Name mangleMethod: includes).
        output println: "    (struct FooContext* ctx)".
        output println: "\{".
        output println: "    return foo_Boolean_new(&{Name mangleInstanceVtable: aClass} == ctx->frame[0].vtable);".
        output println: "}".
        output newline.
        -- Interfaces
        let interfaces = aClass interfaceGlobals.
        let classInterfacesName = "FooClassInterfaces_{aClass name}".
        output println: "struct FooVtable* {classInterfacesName}[] = \{".
        interfaces
            do: { |each|
                  self declare: each.
                  output println: "    &{Name mangleDirectVtable: each}," }.
        output println: "};".
        output newline.
        let instanceInterfacesName = "FooInstanceInterfaces_{aClass name}".
        output println: "struct FooVtable* {instanceInterfacesName}[] = \{".
        interfaces
            do: { |each|
                  output println: "    &{Name mangleInstanceVtable: each}," }.
        output println: "};".
        output newline.
        -- Class Vtable
        output println: "struct FooVtable {classVtableName} = ".
        output println: "\{".
        output println: "    .name = &FOO_CSTRING({aClass name displayString}\" class\"),".
        output println: "    .classptr = NULL,". -- FIXME
        output println: "    .inherited = \{ .size = {interfaces size}, .data = {classInterfacesName} },".
        output println: "    .mark = foo_mark_raw,".
        output println: "    .size = {directMethods size},".
        output println: "    .methods = \{".
        directMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .vtable = &{Name mangleMethodVtable: each},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{Name mangleMethod: each} }," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Instance Vtable
        output println: "struct FooVtable {instanceVtableName} = ".
        output println: "\{".
        output println: "    .name = &FOO_CSTRING({aClass name displayString}),".
        output println: "    .classptr = &{globalName},".
        output println: "    .inherited = \{ .size = {interfaces size}, .data = {instanceInterfacesName} },".
        output println: "    .mark = {aClass markFunction},".
        output println: "    .size = {instanceMethods size + 1},".
        output println: "    .methods = \{".
        instanceMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .vtable = &{Name mangleMethodVtable: each},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{Name mangleMethod: each} }," }.
        -- #__doSelectors
        output println: "        (struct FooMethod)\{ .selector = &FOO_____doSelectors_,".
        output println: "                            .vtable = NULL,".
        output println: "                            .argCount = 1,".
        output println: "                            .frameSize = 1,".
        output println: "                            .function = &foo_do_selectors }".
        output println: "    }".
        output println: "};".
        output newline.
        -- Class struct
        let className = "FooClass_{aClass name}".
        output println: "struct FooClass {className} = ".
        output println: "\{".
        output println: "    .instanceVtable = &{instanceVtableName}".
        output println: "};".
        output newline.
        -- Class object
        output println: "struct Foo {globalName} =".
        output println: "\{".
        output println: "    .vtable = &{classVtableName},".
        output println: "    .datum = \{ .ptr = &{className} }".
        output println: "};".
        output newline!

    method _generateMethod: aMethod _for: type
        -- Tracer _generateMethod: aMethod _for: type.
        -- Debug println: "_generateMethod: {aMethod}".
        let name = Name mangleMethod: aMethod.
        generatedMethods
            at: name
            ifNonePut: { self _actuallyGenerateMethod: aMethod _as: name _for: type }!

    method _actuallyGenerateMethod: aMethod _as: name _for: type
        -- Tracer _actuallyGenerateMethod: aMethod _as: name _for: type.
        -- Debug println: "_actuallyGenerateMethod: {aMethod}".
        aMethod isRequired
            ifTrue: { Error raise: "Cannot generate required method: {aMethod} for: {type}." }.
        let $home = aMethod.
        output print: "struct Foo ".
        output println: name.
        output println: "    (struct FooContext* ctx)".
        output println: "\{".
        output println: "    (void)ctx;".
        aMethod signature
            doWithIndex: { |type index|
                           -- FIXME: visit the type
                           type is Any
                               ifFalse: { output println: "    foo_vtable_typecheck(ctx, &{Name mangleInstanceVtable: type}, ctx->frame[{index-1}ul]);" } }.
        aMethod isBuiltin
            ifTrue: { -- Debug println: "  - builtin method".
                      output print: "    ".
                      output println: (aMethod body replace: "\n" with: "\n    ").
                      output println: "}" }
            ifFalse: { -- Debug println: "  - normal method".
                       output print: "    return ".
                       self _generateTypecheck: aMethod returnType
                            _for: aMethod body.
                       output println: ";".
                       output println: "}" }.
        -- Debug println: "  => method done".
        output newline.
        aMethod!

    method _generateTypecheck: type _for: value
        -- Tracer _generateTypecheck: type _for: value.
        -- Debug println: "_generateTypecheck: {type} _for: {value}".
        type is Any
            ifTrue: { return value visitBy: self }.
        let type = type::AstGlobal.
        self declare: type.
        output print: "foo_vtable_typecheck(ctx, &".
        output print: (Name mangleInstanceVtable: type).
        output print: ", ".
        value visitBy: self.
        output print: ")"!

    method visitGlobal: aVar
        -- Tracer visitGlobal: aVar name.
        self declare: aVar.
        output print: (Name mangleGlobal: aVar)!

    method visitDynamic: aVar
        -- Tracer trace: #visitDynamic:.
        let index = self declareDynamic: aVar.
        output print: "ctx->vars->data[{index}]"!

    method visitTypecheck: aCheck
        -- Tracer visitTypecheck: aCheck.
        self _generateTypecheck: aCheck type
             _for: aCheck value!

    method visitIs: anIs
        -- Tracer trace: #visitIs:.
        let left = self addTemp.
        output print: "(\{ ctx->frame[{left}] = ".
        anIs left visitBy: self.
        output print: "; ".
        let right = self addTemp.
        output print: "ctx->frame[{right}] = ".
        anIs right visitBy: self.
        output print: "; ".
        output print: "foo_Boolean_new(foo_eq(ctx->frame[{left}], ctx->frame[{right}])); ".
        output print: "})"!

    method visitSeq: seq
        -- Tracer trace: #visitSeq:.
        output print: "(\{ ".
        seq first visitBy: self.
        output print: "; ".
        seq then visitBy: self.
        output print: "; })"!

    method visitSlotSet: set
        -- Tracer trace: #visitSlotSet:.
        output print: "(PTR(FooArray, ctx->receiver.datum)->data[".
        output print: (set slot index - 1).
        output print: "] = ".
        self _generateTypecheck: set slot type
             _for: set value.
        output print: ")"!

    method visitSlotRef: ref
        -- Tracer trace: #visitSlotRef:.
        output print: "PTR(FooArray, ctx->receiver.datum)->data[".
        output print: (ref slot index - 1).
        output print: "]"!

    method visitReturn: ret
        -- Tracer trace: #visitReturn:.
        output print: "foo_return(ctx, ".
        self _generateTypecheck: ret from returnType
             _for: ret value.
        output print: ")"!

    method visitComment: aComment
        -- Tracer trace: #visitComment:.
        -- FIXME: Include comments in generated source.
        aComment value visitBy: self!

    method visitConstant: aConstant
        -- Tracer visitConstant: aConstant.
        self _writeValue: aConstant value _in: aConstant env _to: output!

    method visitSend: aSend
        -- Tracer visitSend: aSend selector.
        output print: "(\{ ".
        let argVars = aSend arguments
                          collect: { |each|
                                     let index = self addTemp.
                                     output print: "ctx->frame[{index}] = ".
                                     each visitBy: self.
                                     output print: "; ".
                                     index }.
        output print: "foo_send(ctx, &".
        output print: (self selectorCName: aSend selector).
        output print: ", ".
        aSend receiver visitBy: self.
        output print: ", ".
        output print: aSend arguments size.
        output print: "ul".
        argVars
            do: { |index|
                  output print: ", ctx->frame[{index}]" }.
        output print: "); })"!

    method visitSelfInstance: aSelf
        -- Tracer visitSelfInstance: aSelf.
        output print: "ctx->receiver"!

    method visitSelfClass: aSelf
        -- Tracer trace: #visitSelfClass:.
        output print: "*ctx->receiver.vtable->classptr"!

    method visitBindDynamic: aBind
        -- Tracer trace: #visitBindDynamic:.
        let name = aBind variable name.
        let index = self declareDynamic: aBind variable.
        let unbind = self genTemp: "unbind".
        output print: "(\{ struct FooUnbind {unbind} = \{ .cleanup = \{ .function = foo_unbind, .next = ctx->cleanup }, .index = {index}, .value = ctx->vars->data[{index}] };".
        output print: " ctx->cleanup = &{unbind}.cleanup;".
        output print: " ctx->vars->data[{index}] = ".
        aBind value visitBy: self.
        output print: ";".
        let res = self addTemp.
        output print: " ctx->frame[{res}] = ".
        aBind body visitBy: self.
        output print: ";".
        output print: " assert(&{unbind}.cleanup == ctx->cleanup);".
        output print: " ctx->cleanup = ctx->cleanup->next;".
        output print: " foo_unbind(ctx, &{unbind}.cleanup);".
        output print: " ctx->frame[{res}]; })"!

    method visitBindLexical: aBind
        -- Tracer trace: #visitBindLexical:.
        output print: "(\{ ctx->frame[{aBind variable index - 1}ul] = ".
        self _generateTypecheck: aBind variable type
             _for: aBind value.
        output print: ";".
        aBind body visitBy: self.
        output print: "; })"!

    method visitLexicalRef: aRef
        -- Tracer trace: #visitLexicalRef:.
        output print: "foo_lexical_ref(ctx, {aRef variable index - 1}ul, {aRef frameOffset}ul)"!

    method visitLexicalSet: aSet
        -- Tracer trace: #visitLexicalSet:.
        output print: "foo_lexical_set(ctx, {aSet variable index - 1}ul, {aSet frameOffset}u, ".
        self _generateTypecheck: aSet variable type
             _for: aSet value.
        output print: ")"!

    method visitBlock: aBlock
        -- Tracer trace: #visitBlock:.
        output print: "foo_closure_new(ctx, ".
        output print: (self closureCName: aBlock).
        output print: ", ".
        output print: aBlock argumentCount.
        output print: ", ".
        output print: aBlock frameSize.
        output print: ")"!

    method visitArray: anArray
        -- Tracer trace: #visitArray:.
        let entries = anArray entries.
        let array = self addTemp.
        output print: "(\{ ctx->frame[{array}] = foo_Array_alloc({entries size}); ".
        entries isEmpty
            ifFalse: { let p = self genTemp: "arrayPtr".
                       output print: "struct FooArray* {p} = PTR(FooArray, ctx->frame[{array}].datum);".
                       entries
                           doWithIndex: { |each index|
                                          output print: "{p}->data[{index-1}] = ".
                                          each visitBy: self.
                                          output print: "; " } }.
        output print: "ctx->frame[{array}]; })"!

    method visitPanic: aPanic
        -- Tracer trace: #visitPanic:.
        output println: "foo_panic(ctx, ".
        aPanic value visitBy: self.
        output println: ")"!
end
