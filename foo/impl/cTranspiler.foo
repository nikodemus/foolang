import .transpiler.record
import .transpiler.array
import .transpiler.boolean
import .transpiler.byte_array
import .transpiler.character
import .transpiler.class
import .transpiler.clock
import .transpiler.closure
import .transpiler.file
import .transpiler.filepath
import .transpiler.filestream
import .transpiler.float
import .transpiler.integer
import .transpiler.layout
import .transpiler.name.Name
import .transpiler.output
import .transpiler.selector
import .transpiler.string
import .transpiler.system
import .transpiler.system_random
import .transpiler.time
import .ast.*
import .utils.*

define CEscapes
    { "'" -> "\\'",
      "\\" -> "\\\\",
      "\t" -> "\\t",
      "\n" -> "\\n",
      "\r" -> "\\r" }!

-- define Tracer DebugTracer name: "CTranspiler"!
define Tracer NullTracer!

class BuiltinMethod { home selector definition isDirect }
    direct method forEach: builtins in: home direct: areDirect
        let dict = Dictionary new.
        builtins
            do: { |selector definition|
                  dict at: selector name
                       put: (self
                                 home: home
                                 selector: selector
                                 definition: definition
                                 isDirect: areDirect) }.
        dict!
    method isBuiltin
        True!
    method isRequired
        False!
    method arity
        definition signature size!
    method frameSize
        self arity + self definition vars!
    method signature
        definition signature!
    method body
        definition body!
    method printOn: stream
        stream print: "#<BuiltinMethod {selector}>"!
    method displayOn: stream
        self printOn: stream!
    method toString
        StringOutput with: { |out| self printOn: out }!
    method methodFunctionName
        Name mangleMethod: self!
    method methodHomeName
        Name mangleMethodClass: self!
end

define DatumClasses
    [Boolean, Character, Integer, Float]!

class CompilerBuiltin { type value markFunction _id _interfaces
                        _directMethods _instanceMethods _allInterfaces
                        _global }
    is AstMethodHome

    direct method type: type
                  value: value
                  mark: mark
                  directMethods: directMethods
                  instanceMethods: instanceMethods
        let theClass = self
                           type: type
                           value: value
                           markFunction: mark
                           _id: False
                           _interfaces: List new
                           _directMethods: False
                           _instanceMethods: False
                           _allInterfaces: False
                           _global: False.
        theClass _directMethods: directMethods.
        theClass _instanceMethods: instanceMethods.
        theClass!

    method slots
        []!

    method idOr: block
        -- A bit of a KLUDGE: builtin globals have definitions
        -- in main.c, and we want their names to be consistent.
        --
        -- See also: AstGlobal#idOr:
        ""!

    method eval
        _global hasValue
            ifTrue: { _global eval }
            ifFalse: { _global value: value }!

    method global: global
        global definition is self
            assert: "Bad global for CompilerBuiltin".
        _global = global!

    method definition
        self!

    method _interfaces
        _interfaces!

    method _directMethods
        _directMethods!

    method _instanceMethods
        _instanceMethods!

    method _readerMethods
        []!

    method _allInterfaces
        _allInterfaces!

    method _allInterfaces: list
        (_allInterfaces is False) assert: "Oops, _allInterfaces already set!".
        _allInterfaces = list asArray!

    method _directMethods: methods
        (self _directMethods is False) assert: "Builtin direct methods already set.".
        _directMethods = BuiltinMethod forEach: methods in: self direct: True!

    method _instanceMethods: methods
        (self _instanceMethods is False) assert: "Builtin instance methods already set.".
        _instanceMethods = BuiltinMethod forEach: methods in: self direct: False!

    method visitBy: visitor
        visitor visitBuiltin: self!

    method name
        value name!

    method isBuiltin
        True!

    method isDynamic
        False!

    method printOn: stream
        stream print: self toString!

    method toString
        "#<CompilerBuiltin {self name} ({type name})>"!
end

class CompilerBuiltins {}
    direct method all
        [ CompilerBuiltin
              type: Class
              value: Array
              mark: "foo_mark_array"
              directMethods: array.DirectMethods
              instanceMethods: array.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Boolean
              mark: "foo_mark_none"
              directMethods: boolean.DirectMethods
              instanceMethods: boolean.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: ByteArray
              mark: "foo_mark_bytes"
              directMethods: byte_array.DirectMethods
              instanceMethods: byte_array.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Character
              mark: "foo_mark_none"
              directMethods: character.DirectMethods
              instanceMethods: character.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Class
              mark: "foo_mark_class"
              directMethods: class.InstanceMethods -- class is its own instance
              instanceMethods: class.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Clock
              mark: "foo_mark_none"
              directMethods: clock.DirectMethods
              instanceMethods: clock.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Closure
              mark: "foo_mark_closure"
              directMethods: Dictionary new
              instanceMethods: closure.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Layout
              mark: "foo_mark_layout"
              directMethods: layout.DirectMethods
              instanceMethods: layout.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: File
              mark: "foo_mark_file"
              directMethods: file.DirectMethods
              instanceMethods: file.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: FilePath
              mark: "foo_mark_bytes"
              directMethods: filepath.DirectMethods
              instanceMethods: filepath.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: FileStream
              mark: "foo_mark_filestream"
              directMethods: filestream.DirectMethods
              instanceMethods: filestream.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Float
              mark: "foo_mark_none"
              directMethods: float.DirectMethods
              instanceMethods: float.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Integer
              mark: "foo_mark_none"
              directMethods: Dictionary new
              instanceMethods: integer.IntegerMethods,
          CompilerBuiltin
              type: Class
              value: Output
              mark: "foo_mark_none"
              directMethods: output.DirectMethods
              instanceMethods: output.InstanceMethods,
          CompilerBuiltin
              type: Interface
              value: Record
              mark: "foo_mark_none"
              directMethods: record.DirectMethods
              instanceMethods: record.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Selector
              mark: "foo_mark_none"
              directMethods: selector.DirectMethods
              instanceMethods: selector.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: String
              mark: "foo_mark_bytes"
              directMethods: string.DirectMethods
              instanceMethods: string.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: (Foolang isSelfHosted
                          ifTrue: { System }
                          ifFalse: { { name: "System" } })
              mark: "foo_mark_none"
              directMethods: system.DirectMethods
              instanceMethods: system.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: (Foolang isSelfHosted
                          ifTrue: { SystemRandom }
                          ifFalse: { { name: "SystemRandom" } })
              mark: "foo_mark_none"
              directMethods: system_random.DirectMethods
              instanceMethods: system_random.InstanceMethods,
          CompilerBuiltin
              type: Class
              value: Time
              mark: "foo_mark_ptr"
              directMethods: time.DirectMethods
              instanceMethods: time.InstanceMethods
        ]!
end

class SelectorMap { names }
    direct method new
        self names: Dictionary new!

    method map: selector
        names
            at: selector name
            ifNonePut: { Name mangleSelector: selector }!

    method do: block
        names do: block!
end

define AlwaysEmittedSelectors
    [#__doSelectors:,
     #invoke:on:,
     #perform:with:,
     #selector,
     #writeString:]!

define $home
        False!

class Counter { value }
    direct method new
        self value: 0!
    method increment
        value = value + 1!
end

define $CascadeReceiverTemp
    "<<<not in cascade>>>"!

class CTranspiler { output selectorMap closureFunctions
                    constants variables tmpCounter
                    globals globalsCounter
                    recordClasses
                    generatedMethods env builtins visited }

    direct method transpile: string in: env with: prelude
        env removeBuiltins: [
            "Any",
            "DoesNotUnderstand",
            "Error",
            "List",
            "Object",
            "TypeError"
        ].
        let builtins = CompilerBuiltins all.
        env replaceBuiltins: builtins.
        -- FIXME: move "target class map" to environment?
        prelude is False
            ifFalse: { env importPrelude: prelude }.
        env load: string.
        self transpileMainIn: env with: builtins!

    direct method transpileMainIn: env with: builtins
        let visitor = CTranspiler
                          output: StringOutput new
                          selectorMap: SelectorMap new
                          closureFunctions: List new
                          constants: List new
                          variables: Dictionary new
                          tmpCounter: 0
                          globals: Dictionary new
                          globalsCounter: Counter new
                          recordClasses: Dictionary new
                          generatedMethods: Dictionary new
                          env: env
                          builtins: (Dictionary
                                         keys: (builtins collect: #value)
                                         values: builtins)
                          visited: Dictionary new.
        visitor output println: "#include \"foo.h\"".
        -- KLUDGE: ensure selectors with references from C code
        AlwaysEmittedSelectors
            do: { |each| visitor selectorMap map: each }.
        let builtins = visitor generateBuiltins.
        let main = env global: "Main".
        visitor declare: main.
        visitor writeDefinitions.
        visitor writeMain: main.
        { main: visitor output,
          builtins: builtins,
          closures: visitor generateClosures,
          constants: visitor generateConstants,
          declarations: visitor generateDeclarations,
          selectors: visitor generateSelectors }!

    method addTemp
        $home addTemp!

    method mangleGlobal: global
        let id = global idOr: { globalsCounter increment }.
        -- Debug println: "{id}: {global}".
        Name mangleGlobal: global
             id: id!

    method mangleMetaclass: aClass
        Name mangleMetaclass: aClass!

    method _visitWithOutputToString: value
        let oldOutput = output.
        let newOutput = StringOutput new.
        { output = newOutput.
          value visitBy: self }
        finally: { output = oldOutput }.
        newOutput content!

    method _visitTemp: value
        value isImmediate
            ifTrue: { return self _visitWithOutputToString: value }.
        let tmp = self addTemp.
        output print: "ctx->frame[{tmp}] = ".
        value visitBy: self.
        output print: ";".
        "ctx->frame[{tmp}]"!

    method declare: global
        globals at: global
                ifNonePut: { global definition }!

    method declareDynamic: var
        self declare: var.
        variables at: var name ifNonePut: { variables size }!

    method genTemp: name
        tmpCounter = tmpCounter + 1.
        "tmp{tmpCounter}_{name}"!

    method forwardDeclarationFor: aGlobal
        -- Debug println: "declare: {aGlobal}".
        (CompilerBuiltin includes: aGlobal)
            ifTrue: { self _classDeclarations: aGlobal }.
        (AstClass includes: aGlobal)
            ifTrue: { self _classDeclarations: aGlobal }.
        (AstInterface includes: aGlobal)
            ifTrue: { self _interfaceDeclarations: aGlobal }.
        (AstBuiltin includes: aGlobal)
            ifTrue: { return False }.
        aGlobal isDynamic
            ifTrue: { self declareDynamic: aGlobal.
                      output println: "struct Foo {Name mangleDynamic: aGlobal};" }
            ifFalse: {  output println: "struct Foo {self mangleGlobal: aGlobal};" }!

    method _classDeclarations: aClass
        output println: "struct FooClass {Name mangleMetaclass: aClass};".
        output println: "struct FooClass {Name mangleClass: aClass};".
        let isOwnDefinition
                = { |def| def home is aClass }.
        (aClass directMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }.
        (aClass instanceMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }!

    method _interfaceDeclarations: anInterface
        output println: "struct FooClass {Name mangleMetaclass: anInterface};".
        output println: "struct FooClass {Name mangleClass: anInterface};".
        let isOwnDefinition
                = { |def| def home is anInterface and: def isRequired not }.
        (anInterface directMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }.
        (anInterface instanceMethods select: isOwnDefinition)
            do: { |each| self _methodDeclaration: each }!

    method _methodDeclaration: aMethod
        output print: "struct Foo ".
        output print: (Name mangleMethod: aMethod).
        output println: "(const struct FooMethod*, struct FooContext*);"!

    method writeDefinitions
        -- Processing a definition can produce new global references. Visit
        -- each definition only once, finish with the full collection.
        let allGlobals = Dictionary new.
        { globals isEmpty }
            whileFalse: { let old = globals.
                          globals = Dictionary new.
                          old do: { |global def|
                                    allGlobals at: global
                                               ifNone: { allGlobals put: def at: global.
                                                         def visitBy: self } } }.
        globals = allGlobals!

    method writeMain: main
        output println: "int main".
        output println: "    (int argc, char** argv)".
        output println: "\{".
        output println: "    fooinit();".
        output println: "    struct FooArray* vars = FooArray_alloc({variables size});".
        variables
            do: { |name offset|
                  let var = {name: name}.
                  output print: "vars->data[{offset}] = ".
                  output print: (Name mangleDynamic: var).
                  output println: ";" }.
        output println: "    struct FooContext* ctx = foo_context_new_main(vars);".
        output println: "    struct FooArray* array = FooArray_alloc(argc-1);".
        output println: "    for (size_t i = 0; i < array->size; i++)".
        output println: "        array->data[i] = foo_String_new_from(argv[i+1]);".
        output println: "    struct Foo args = \{ .class = &FooClass_Array, .datum = \{ .ptr = array } };".
        output println: "    struct Foo system = \{ .class = &FooClass_System, .datum = \{ .ptr = NULL } };".
        output println: "    foo_send(ctx, &{Name mangleSelector: #run:in:}, {self mangleGlobal: main}, 2, args, system);".
        output println: "    return 0;".
        output println: "}"!

    method generateSelectors
        let output = StringOutput new.
        let prev = "NULL".
        selectorMap do: { |name cname|
                         output print: "struct FooSelector ".
                         output print: cname.
                         output print: " = \{ .name = FOO_CSTRING(".
                         output display: name.
                         output print: "), .next = ".
                         output print: prev.
                         output print: " };\n".
                         prev = "&{cname}" }.
        output println: "struct FooSelector* FOO_InternedSelectors = {prev};".
        output!

    method generateDeclarations
        -- Debug println: "      #generateDeclarations".
        let output = StringOutput new.
        let builtinVisitor = CTranspiler
                                 output: output
                                 selectorMap: selectorMap
                                 closureFunctions: closureFunctions
                                 constants: constants
                                 variables: variables
                                 tmpCounter: tmpCounter
                                 globals: globals
                                 globalsCounter: globalsCounter
                                 recordClasses: recordClasses
                                 generatedMethods: generatedMethods
                                 env: env
                                 builtins: builtins
                                 visited: visited.
        builtinVisitor output println: "#include \"foo.h\"".
        -- FIXME: visit only referenced builtins
        self compilerBuiltins
            do: { |each| builtinVisitor forwardDeclarationFor: each }.
        globals
            doValues: { |each|
                        builtinVisitor forwardDeclarationFor: each }.
        closureFunctions
            do: { |closure|
                  output print: closure declaration.
                  output println: ";" }.
        output!

    method compilerBuiltins
        -- Filter out module definitions
        let builtinGlobals = env builtins values
                          select: { |each| AstGlobal includes: each }.
        (builtinGlobals collect: #definition)
            select: { |each| CompilerBuiltin includes: each }!

    method generateBuiltins
        -- Debug println: "      #generateBuiltins:".
        let output = StringOutput new.
        let builtinVisitor = CTranspiler
                                 output: output
                                 selectorMap: selectorMap
                                 closureFunctions: closureFunctions
                                 constants: constants
                                 variables: variables
                                 tmpCounter: tmpCounter
                                 globals: globals
                                 globalsCounter: globalsCounter
                                 recordClasses: recordClasses
                                 generatedMethods: generatedMethods
                                 env: env
                                 builtins: builtins
                                 visited: visited.
        builtinVisitor output println: "#include \"foo.h\"".
        -- FIXME: used builtins only
        self compilerBuiltins
            do: { |each|
                  builtinVisitor visitClassDefinition: each }.
        output!

    method generateClosures
        self generateClosuresOn: StringOutput new!

    method generateClosuresOn: out
        closureFunctions do: { |closure|
                             out println: closure definition }.
        out!

    method generateConstants
        self generateConstantsOn: StringOutput new!

    method generateConstantsOn: out
        constants do: { |each| out println: each declaration }.
        constants do: { |each|
                        out println: each definition }.
        out!

    method selectorCName: selector
        self selectorMap map: selector!

    method constantCName: value
        -- Tracer constantCName: value.
        (Selector includes: value)
            ifTrue: { return self selectorCName: value }.
        (Object includes: value)
            ifTrue: { constants
                          do: { |each|
                                -- Debug println: "constantCName == {each}".
                                value == each value
                                    ifTrue: { return each cname } } }
            ifFalse: { constants
                           do: { |each|
                                -- Debug println: "constantCName is {each}".
                                value is each value
                                   ifTrue: { return each cname } } }.
        ((Class includes: value) or: (Interface includes: value))
            ifTrue: { self declare: (self _astClassOf: value).
                      let cname = Name mangleClass: value.
                      constants add: { value: value,
                                       cname: cname,
                                       declaration: "",
                                       definition: "" }.
                      return cname }
            ifFalse: { let index = constants size + 1.
                       let cname = "fooconst_{Name mangleName: value classOf name}_{index}".
                       -- Placeholder in case of recursive entry.
                       constants add: { value: value, cname: cname }.
                       constants at: index
                                 put: (self _constantDefinition: value
                                            _called: cname).
                       return cname }!

    method _isPtr: value
        let theClass = value classOf.
        (DatumClasses contains: theClass)
            ifTrue: { return False }.
        True!

    method _writeDatum: value _to: out
        -- Tracer visitDatum: value.
        (self _isPtr: value)
            ifTrue: { return out print: ".ptr = &{self constantCName: value}" }.
        (Boolean includes: value)
            ifTrue: { let bit = value ifTrue: { 1 } ifFalse: { 0 }.
                      return out print: ".boolean = {bit}" }.
        (Character includes: value)
            ifTrue: { return out print: ".int64 = {value code}" }.
        (Float includes: value)
            ifTrue: { return out print: ".float64 = {value}" }.
        (Integer includes: value)
            ifTrue: { return out print: ".int64 = {value}" }.
        Error raise: "Don't know how to transpile constant `{value}` into C."!

    method _astClassOf: value
        (Record includes: value)
            ifTrue: { return self _recordClassFromRecord: value }.
        -- KLUDGE: Dictionary is builtin on bootstrap host, so
        -- env classes don't know about it. Instead of this
        -- should somehow include it it compiler builtins,
        -- maybe with a "redefined: True" flag?
        (Dictionary includes: value)
            ifTrue: { return env global: "Dictionary" }.
        -- FIXME: WTF? Why?
        let theClass = ((Class includes: value) or: (Interface includes: value))
                         ifTrue: { value }
                         ifFalse: { value classOf }.
        return env classes
            at: theClass
            ifNone: { builtins
                          at: theClass
                          ifNone: {
                              Debug println: "looking for: {value} ({theClass})".
                              env classes keys
                                  do: { |each|
                                        Debug println: "- {each} ({each is theClass})" }.
                              panic "No AstClass for: {value} ({theClass})\nenv classes: {env classes keys}\nbuiltins: {builtins keys}" } }!

    method _recordClassFromRecord: aRecord
        let keys = (Record keysIn: aRecord) sorted
                       collect: #name.
        let name = Selector
                       intern: (StringOutput
                                    with: { |out|
                                            keys do: { |each| out print: each }}).
        self _ensureRecordClass: { name: name,
                                   slots: keys }!

    method _writeValue: value _to: out
        -- Tracer _writeValue: value.
        ((Class includes: value) or: (Interface includes: value))
            ifTrue: { out print: "(struct Foo)\{ .class = &{Name mangleMetaclass: (self _astClassOf: value)}, .datum = \{ " }
            ifFalse: { out print: "(struct Foo)\{ .class = &{Name mangleClass: (self _astClassOf: value)}, .datum = \{ " }.
        self _writeDatum: value _to: out.
        out println: " } }"!

    method _constantDefinition: value _called: cname
        -- Tracer _constantDefinition: value.
        (Array includes: value)
            ifTrue: { return
                          { value: value,
                            cname: cname,
                            declaration: "struct FooArray {cname};",
                            definition: (self _arrayDefinition: value
                                              _called: cname) } }.
        (Record includes: value)
            ifTrue: { return
                          { value: value,
                            cname: cname,
                            declaration: "struct FooArray {cname};",
                            definition: (self _recordDefinition: value
                                              _called: cname) } }.
        (String includes: value)
            ifTrue: { return
                          { value: value,
                            cname: cname,
                            declaration: "struct FooBytes {cname};",
                            definition: (self _stringDefinition: value
                                              _called: cname) } }.
        { value: value,
          cname: cname,
          declaration: "struct FooArray {cname};",
          definition: (self _instanceDefinition: value
                            _called: cname) }!

    method _arrayDefinition: value _called: cname
        StringOutput
            with: { |out|
                    out println: "struct FooArray {cname} =".
                    out println: "\{".
                    out println: "    .header = \{ .allocation = STATIC },".
                    out println: "    .size = {value size},".
                    out print: "    .data = \{ ".
                    value do: { |each|
                                self _writeValue: each
                                     _to: out.
                                out print: "," }.
                    out println: " }".
                    out println: "};" }!

    method _instanceDefinition: value _called: cname
        -- Tracer _instanceDefinition: value _called: cname
        let theClass = self _astClassOf: value.
        self declare: theClass.
        let slots = theClass definition slots.
        StringOutput
            with: { |out|
                    out println: "struct FooArray {cname} =".
                    out println: "\{".
                    out println: "    .header = \{ .allocation = STATIC },".
                    out println: "    .size = {slots size},".
                    out print: "    .data = \{ ".
                    slots
                        do: { |each|
                              self _writeValue: ((Selector intern: each name)
                                                     sendTo: value)
                                   _to: out.
                              out print: "," }.
                    out println: " }".
                    out println: "};" }!

    method _recordDefinition: value _called: cname
        StringOutput
            with: { |out|
                    out println: "struct FooArray {cname} =".
                    out println: "\{".
                    out println: "    .header = \{ .allocation = STATIC },".
                    out println: "    .size = {Record sizeOf: value},".
                    out print: "    .data = \{ ".
                    value do: { |each|
                                self _writeValue: each
                                     _to: out.
                                out print: "," }.
                    out println: " }".
                    out println: "};" }!

    method _printStringAsComment: s0 to: out
        -- KLUDGE ARRGH do this properly FIXME
        let s1 = s0 replace: "\\" with: "\\\\".
        let s2 = s1 replace: "\n" with: "\\n".
        let s3 = s2 replace: "\r" with: "\\r".
        let s4 = s3 replace: "\"" with: "\\\"".
        let s5 = s4 replace: "\{" with: "\\\{".
        out println: "// \"{s5}\""!

    method _stringDefinition: value _called: cname
        StringOutput
            with: { |out|
                    value lines
                        do: { |each| self _printStringAsComment: each to: out }.
                    out println: "struct FooBytes {cname} =".
                    out println: "\{".
                    out println: "    .header = \{ .allocation = STATIC },".
                    out println: "    .size = {value size},".
                    out print: "    .data = \{ ".
                    value do: { |each|
                                out print: "'".
                                out print: (CEscapes at: each ifNone: { each }).
                                out print: "'," }.
                    out print: "0".
                    out println: " }".
                    out println: "};" }!

    method closureCName: closure
        let $home = closure.
        let output = StringOutput new.
        -- Placeholder so that recursive entry by visitor doesn't grab the
        -- same id.
        closureFunctions add: False.
        let index = closureFunctions size.
        let cname = "fooclosure_id{index}".
        let signature = StringOutput new.
        signature print: "struct Foo ".
        signature print: cname.
        signature print: "(struct FooContext* ctx)".
        output print: signature.
        output println: " \{".
        -- FIXME: Given that we need to check types here, should also put the args
        -- in frame here, same as in methods.
        closure argumentVariables
            do: { |var|
                  let type = var type.
                  type is Any
                      ifFalse: { output println: "    foo_class_typecheck(ctx, &{Name mangleClass: type}, ctx->frame[{var index-1}]);" } }.
        output print: "    return ".
        let closureVisitor = CTranspiler
                               output: output
                               selectorMap: selectorMap
                               closureFunctions: closureFunctions
                               constants: constants
                               variables: variables
                               tmpCounter: tmpCounter
                               globals: globals
                               globalsCounter: globalsCounter
                               recordClasses: recordClasses
                               generatedMethods: generatedMethods
                               env: env
                               builtins: builtins
                               visited: visited.
        closureVisitor _generateTypecheck: closure returnType
                     _for: closure body.
        output println: ";\n}".
        closureFunctions
            put: { declaration: signature, definition: output }
            at: index.
        cname!

    method visitBuiltin: aClass
        -- Tracer trace: #visitBuiltin:.
        self!

    method visitDefine: aDefine
        (visited has: aDefine)
            ifTrue: { return False }.
        visited put: True at: aDefine.
        Tracer visitDefine: aDefine.
        aDefine isDynamic
            ifTrue: { output println: "struct Foo {Name mangleDynamic: aDefine} = " }
            ifFalse: { output println: "struct Foo {self mangleGlobal: aDefine} = " }.
        self _writeValue: aDefine eval _to: output.
        output println: ";".
        output newline!

    method _ensureRecordClass: aRecord
        let aRecordClass = recordClasses
            at: aRecord name name -- Selector don't play nice in bootstrap host dictionary!
            ifNonePut: { self _createRecordClass: aRecord }.
        globals at: aRecordClass
                ifNonePut: { aRecordClass }!

    method _createRecordClass: aRecord
        let name = String concat: ["Record_", aRecord name name replace: ":" with: "$"].
        let theClass = AstClass
                           name: name
                           slots: (aRecord slots
                                       collectWithIndex: { |each index|
                                                           AstSlot name: each
                                                                   index: index
                                                                   type: Any })
                           interfaces: [env global: "Record"]
                           env: env.
        theClass directMethods: [].
        theClass instanceMethods: [].
        theClass!

    method visitRecord: aRecord
        -- Tracer visitRecord: aRecord.
        let recordClass = self _ensureRecordClass: aRecord.
        output print: "(\{ ".
        let args = aRecord values
                       collect: { |each| self _visitTemp: each }.
        output print: "foo_send(ctx".
        output print: ", &{Name mangleSelector: aRecord name}".
        output print: ", {self mangleGlobal: recordClass}".
        output print: ", ".
        output print: args size.
        args
            do: { |each|
                  output print: ", {each}" }.
        output print: "); })"!

    method visitDictionary: aDictionary
        -- Tracer visitDictionary: aDictionary
        output print: "(\{".
        let new = self selectorCName: #new.
        let dict = self addTemp.
        output print: "ctx->frame[{dict}] = foo_send(ctx, &{new}, ".
        self visitGlobal: (env global: "Dictionary").
        output print: ", 0);".
        let putAt = self selectorCName: #put:at:.
        aDictionary entries
            do: { |each|
                  let k = self _visitTemp: each key.
                  let v = self _visitTemp: each value.
                  output print: "foo_send(ctx, &{putAt}, ctx->frame[{dict}], 2, {v}, {k}); " }.
        output print: "ctx->frame[{dict}]; })"!

    method _generateLayout: aClass
        -- Tracer _generateLayout: aClass.
        aClass isBuiltin
            ifTrue: { return "NULL" }. -- FIXME: proper builtin layouts
        -- FIXME: Since user doesn't have access to these layouts,
        -- could/should intern them.
        let name = "FooLayout_{aClass name}".
        output println: "struct FooLayout {name} = \{".
        output println: "    .header = \{ .allocation = STATIC },".
        output println: "    .mark = foo_mark_oops,".
        output println: "    .size = {aClass slots size}".
        output println: "};".
        return "&{name}"!

    method _generateInheritance: anObject forMetaclass: forMetaclass
        let inheritance = forMetaclass
                              ifTrue: { "FooMetaclassInheritance_{anObject name}" }
                              ifFalse: { "FooClassInheritance_{anObject name}" }.
        let mangle = forMetaclass
                         ifTrue: { { |x| Name mangleMetaclass: x} }
                         ifFalse: { { |x| Name mangleClass: x } }.
        let interfaces = anObject interfaceGlobals asList.
        forMetaclass
            ifTrue: { interfaces add: (env global: "Class") }.
        output println: "struct FooPointerList {inheritance} = \{".
        output println: "    .header = \{ .allocation = STATIC },".
        output println: "    .mark = foo_mark_class,".
        output println: "    .size = {interfaces size},".
        output println: "    .data = \{".
        interfaces
            do: { |each|
                  self declare: each.
                  output println: "        &{mangle value: each}," }.
        output println: "    }".
        output println: "};".
        output newline.
        inheritance!

    method visitInterfaceDefinition: anInterface
        (visited has: anInterface)
            ifTrue: { return False }.
        visited put: True at: anInterface.
        Tracer visitInterfaceDefinition: anInterface name.
        output println: "/**
* {anInterface name} (an interface)
*
*/".
        let metaclassName = Name mangleMetaclass: anInterface.
        let className = Name mangleClass: anInterface.
        let globalName = self mangleGlobal: anInterface.
        -- Augmented with #includes: and #name
        let directMethods = (anInterface directMethods reject: #isRequired) asList.
        directMethods
            do: { |each| self _writeMethod: each _for: anInterface }.
        self _generateDefaultDirectMethodsFor: anInterface
            _in: directMethods.
        let instanceMethods = anInterface instanceMethods reject: #isRequired.
        instanceMethods
            do: { |each| self _writeMethod: each _for: anInterface }.
        -- Interface metaclass
        -- FIXME: name says 'Foo interface', should be 'Foo class'!
        let metaclassInheritance
            = self _generateInheritance: anInterface forMetaclass: True.
        let classInheritance
            = self _generateInheritance: anInterface forMetaclass: False.
        let metaclassNameString = "{anInterface name} interface".
        output println: "struct FooClass {metaclassName} = ".
        output println: "\{".
        output println: "    .header = \{ .allocation = STATIC },".
        output println: "    .name = &{self constantCName: metaclassNameString}, // {metaclassNameString}".
        output println: "    .metaclass = &FooClass_Class,".
        output println: "    .inherited = &{metaclassInheritance},".
        output println: "    .layout = &TheClassLayout,".
        output println: "    .mark = foo_mark_none,".
        output println: "    .size = {directMethods size},".
        output println: "    .methods = \{".
        directMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .class = &{each methodHomeName},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{each methodFunctionName},".
                  output println: "                            .object = (struct Foo)\{ .class = NULL, .datum = \{ .ptr = NULL } } }," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Interface class (empty, used for identity only)!
        -- FIXME: for runtime instantiation of classes we need to add the instance methods here!
        output println: "struct FooClass {className} = ".
        output println: "\{".
        output println: "    .header = \{ .allocation = STATIC },".
        output println: "    .name = &{self constantCName: anInterface name}, // {anInterface name}".
        output println: "    .metaclass = &{metaclassName},".
        output println: "    .inherited = &{classInheritance},".
        output println: "    .layout = NULL,". -- FIXME
        output println: "    .mark = foo_mark_none,".
        output println: "    .size = {instanceMethods size},".
        output println: "    .methods = \{".
        instanceMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .class = &{each methodHomeName},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{each methodFunctionName},".
                  output println: "                            .object = (struct Foo)\{ .class = NULL, .datum = \{ .ptr = NULL \}\}\}," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Interface object
        output println: "struct Foo {globalName} =".
        output println: "\{".
        output println: "    .class = &{metaclassName},".
        output println: "    .datum = \{ .ptr = &{className} }".
        output println: "};".
        output newline!

    method _generateClassConstructor: aClass
        let ctorProto = { home: aClass,
                          selector: aClass constructor,
                          isDirect: True }.
        -- Awkward: we need the proto to mangle the names...
        let ctor =  { selector: aClass constructor,
                      arity: aClass slots size,
                      frameSize: aClass slots size,
                      methodHomeName: (Name mangleMethodClass: ctorProto),
                      methodFunctionName: (Name mangleMethod: ctorProto) }.
        output print: "struct Foo ".
        output println: ctor methodFunctionName.
        output println: "    (const struct FooMethod* method, struct FooContext* ctx)".
        output println: "\{".
        output println: "    (void)method;".
        output println: "    (void)ctx;".
        output println: "    struct FooArray* new = FooInstance_alloc({aClass slots size});".
        aClass slots
            doWithIndex: { |each index|
                           let type = each type. -- FIXME: visit the type
                           type is Any
                               ifTrue: { output println: "new->data[{index-1}] = ctx->frame[{index-1}];" }
                               ifFalse: { output println: "new->data[{index -1}] = foo_class_typecheck(ctx, &{Name mangleClass: type}, ctx->frame[{index-1}]);" } }.
        output println: "    return (struct Foo)\{ .class = PTR(FooClass, ctx->receiver.datum), .datum = \{ .ptr = new } };".
        output println: "}".
        output newline.
        ctor!

    method _generateDefaultDirectMethodsFor: aClass _in: table
        (table find: { |each| each selector == #includes: }) is False
            ifTrue: { table add: (self _generateDirectMethod_includes: aClass) }.
        (table find: { |each| each selector == #classOf: }) is False
            ifTrue: { table add: (self _generateDirectMethod_classOf: aClass) }.
        (table find: { |each| each selector == #name }) is False
            ifTrue: { table add: (self _generateDirectMethod_name: aClass) }!

    method _generateDirectMethod_includes: aClass
        { selector: #includes:,
          arity: 1,
          frameSize: 1,
          methodHomeName: (Name mangleMetaclass: aClass),
          methodFunctionName: "foo_method_includes_" }!

    method _generateDirectMethod_name: aClass
        { selector: #name,
          arity: 0,
          frameSize: 0,
          methodHomeName: (Name mangleMetaclass: aClass),
          methodFunctionName: "foo_method_name" }!

    method _generateDirectMethod_classOf: aClass
        { selector: #classOf,
          arity: 0,
          frameSize: 0,
          methodHomeName: (Name mangleMetaclass: aClass),
          methodFunctionName: "foo_method_classOf" }!

    method _generateInstanceClassOf: aClass
        { selector: #classOf,
          arity: 0,
          frameSize: 0,
          methodHomeName: (Name mangleClass: aClass),
          methodFunctionName: "foo_method_classOf" }!

    method visitClassDefinition: aClass
        (visited has: aClass)
            ifTrue: { return False }.
        visited put: True at: aClass.
        Tracer visitClassDefinition: aClass name.
        let classNote = aClass isBuiltin
                       ifTrue: { "{aClass name} (builtin)" }
                       ifFalse: { aClass name }.
        output println: "/**
 * {aClass name}
 *
 */".
        let isTheClass = aClass isBuiltin and: aClass name == "Class".
        let className = Name mangleClass: aClass.
        let metaclassName = Name mangleMetaclass: aClass.
        let globalName = self mangleGlobal: aClass.
        -- Augmented later with: constructor (aka ctor), #includes:, and #name
        let directMethods = aClass directMethods asList.
        -- Debug println: "{aClass name} direct methods:".
        -- directMethods do: { |each| Debug println: "- {each selector}" }.
        directMethods
            do: { |each| self _writeMethod: each _for: aClass }.
        -- Augmented later with #classOf.
        let instanceMethods = aClass instanceMethods asList.
        -- Debug println: "{aClass name} methods:".
        -- instanceMethods do: { |each| Debug println: "- {each selector}" }.
        instanceMethods
            do: { |each| self _writeMethod: each _for: aClass }.
        aClass isBuiltin
            ifFalse: { directMethods add: (self _generateClassConstructor: aClass) }.
        let classMethods = isTheClass
                               ifTrue: { instanceMethods }
                               ifFalse:{ directMethods }.
        self _generateDefaultDirectMethodsFor: aClass
            _in: classMethods.
        instanceMethods add: (self _generateInstanceClassOf: aClass).
        isTheClass
            ifFalse: { -- Class metaclass, not needed for Class which
                       -- is its own metaclass.
                       let metaclassInheritance
                           = self _generateInheritance: aClass forMetaclass: True.
                       let metaclassNameString = "{aClass name} classOf".
                       output println: "struct FooClass {metaclassName} = ".
                       output println: "\{".
                       output println: "    .header = \{ .allocation = STATIC },".
                       output println: "    .name = &{self constantCName: metaclassNameString}, // {metaclassNameString}".
                       output println: "    .metaclass = &FooClass_Class,".
                       output println: "    .inherited = &{metaclassInheritance},".
                       output println: "    .layout = &TheClassLayout,".
                       output println: "    .mark = foo_mark_class,".
                       output println: "    .size = {directMethods size},".
                       output println: "    .methods = \{".
                       directMethods
                           do: { |each|
                                 output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                                 output println: "                            .class = &{each methodHomeName},".
                                 output println: "                            .argCount = {each arity},".
                                 output println: "                            .frameSize = {each frameSize},".
                                 output println: "                            .function = &{each methodFunctionName},".
                                 output println: "                            .object = (struct Foo)\{ .class = NULL, .datum = \{ .ptr = NULL } } }," }.
                       output println: "    }".
                       output println: "};".
                       output newline }.
        -- Instance Class
        let classInheritance = self _generateInheritance: aClass forMetaclass: False.
        let layout = isTheClass
                         ifTrue: { "&TheClassLayout" }
                         ifFalse: { self _generateLayout: aClass }.
        -- Debug println: "{aClass} => {aClass markFunction}".
        output println: "struct FooClass {className} = ".
        output println: "\{".
        output println: "    .header = \{ .allocation = STATIC },".
        output println: "    .name = &{self constantCName: aClass name}, // {aClass name}".
        output println: "    .metaclass = &{metaclassName},".
        output println: "    .inherited = &{classInheritance},".
        output println: "    .layout = {layout},".
        output println: "    .mark = {aClass markFunction},".
        output println: "    .size = {instanceMethods size + 1},".
        output println: "    .methods = \{".
        instanceMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .class = &{each methodHomeName},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{each methodFunctionName},".
                  output println: "                            .object = (struct Foo)\{ .class = NULL, .datum = \{ .ptr = NULL \}\}\}," }.
        -- #__doSelectors
        output println: "        (struct FooMethod)\{ .selector = &FOO_____doSelectors_,".
        output println: "                            .class = &{className},".
        output println: "                            .argCount = 1,".
        output println: "                            .frameSize = 1,".
        output println: "                            .function = &foo_method_doSelectors_,".
        output println: "                            .object = (struct Foo)\{ .class = NULL, .datum = \{ .ptr = NULL \}\}\},".
        output println: "    }".
        output println: "};".
        output newline.
        -- Class object
        output println: "struct Foo {globalName} =".
        output println: "\{".
        output println: "    .class = &{metaclassName},".
        output println: "    .datum = \{ .ptr = &{className} }".
        output println: "};".
        output newline.
        True!

    method _writeMethod: aMethod _for: aClass
        -- Tracer _writeMethod: aMethod _for: type.
        let name = Name mangleMethod: aMethod.
        generatedMethods
            at: name
            ifNonePut: { self _actuallyGenerateMethod: aMethod _as: name _for: aClass }!

    method _actuallyGenerateMethod: aMethod _as: name _for: aClass
        -- Tracer _actuallyGenerateMethod: aMethod _as: name _for: type.
        -- Debug println: "_actuallyGenerateMethod: {aMethod}".
        aMethod isRequired
            ifTrue: { Error raise: "Cannot generate required method: {aMethod} for: {aClass}." }.
        let $home = aMethod.
        output print: "struct Foo ".
        output println: name.
        output println: "    (const struct FooMethod* method, struct FooContext* ctx)".
        output println: "\{".
        output println: "    (void)method;".
        output println: "    (void)ctx;".
        aMethod signature
            doWithIndex: { |type index|
                           -- FIXME: visit the type
                           type is Any
                               ifFalse: { output println: "    foo_class_typecheck(ctx, &{Name mangleClass: type}, ctx->frame[{index-1}ul]);" } }.
        aMethod isBuiltin
            ifTrue: { -- Debug println: "  - builtin method".
                      output print: "    ".
                      output println: (aMethod body replace: "\n" with: "\n    ").
                      output println: "}" }
            ifFalse: { -- Debug println: "  - normal method".
                       output print: "    return ".
                       self _generateTypecheck: aMethod returnType
                            _for: aMethod body.
                       output println: ";".
                       output println: "}" }.
        -- Debug println: "  => method done".
        output newline.
        aMethod!

    method _generateTypecheck: type _for: value
        -- Tracer _generateTypecheck: type _for: value.
        -- Debug println: "_generateTypecheck: {type} _for: {value}".
        type is Any
            ifTrue: { return value visitBy: self }.
        let type = type::AstGlobal.
        self declare: type.
        output print: "foo_class_typecheck(ctx, &".
        output print: (Name mangleClass: type).
        output print: ", ".
        value visitBy: self.
        output print: ")"!

    method visitGlobal: aVar
        -- Tracer visitGlobal: aVar.
        self declare: aVar.
        output print: (self mangleGlobal: aVar)!

    method visitDynamic: aVar
        -- Tracer trace: #visitDynamic:.
        let index = self declareDynamic: aVar.
        output print: "ctx->vars->data[{index}]"!

    method visitTypecheck: aCheck
        -- Tracer visitTypecheck: aCheck.
        self _generateTypecheck: aCheck type
             _for: aCheck value!

    method visitIs: anIs
        -- Tracer trace: #visitIs:.
        output print: "(\{".
        let left = self _visitTemp: anIs left.
        let right = self _visitTemp: anIs right.
        output print: "FOO_BOOLEAN(foo_eq({left}, {right})); ".
        output print: "})"!

    method visitSeq: seq
        -- Tracer trace: #visitSeq:.
        output print: "(\{ ".
        seq first visitBy: self.
        output print: "; ".
        seq then visitBy: self.
        output print: "; })"!

    method visitSlotSet: set
        -- Tracer trace: #visitSlotSet:.
        output print: "(PTR(FooArray, foo_check_modification(ctx, ctx->receiver.datum))->data[".
        output print: (set slot index - 1).
        output print: "] = ".
        self _generateTypecheck: set slot type
             _for: set value.
        output print: ")"!

    method visitSlotRef: ref
        -- Tracer trace: #visitSlotRef:.
        output print: "PTR(FooArray, ctx->receiver.datum)->data[".
        output print: (ref slot index - 1).
        output print: "]"!

    method visitReturn: ret
        -- Tracer trace: #visitReturn:.
        output print: "foo_return(ctx, ".
        self _generateTypecheck: ret from returnType
             _for: ret value.
        output print: ")"!

    method visitConstant: aConstant
        -- Tracer visitConstant: aConstant.
        self _writeValue: aConstant value _to: output!

    method visitCascade: aCascade
        output print: "(\{".
        let $CascadeReceiverTemp = self _visitTemp: aCascade receiver.
        aCascade messages
            do: { |each|
                  each visitBy: self.
                  output print: ";" }.
        output print: "});"!

    method visitCascadeReceiver: _
        output print: $CascadeReceiverTemp!

    method visitSend: aSend
        -- Tracer visitSend: aSend selector.
        output print: "(\{ ".
        let receiver = self _visitTemp: aSend receiver.
        let args = aSend arguments
                          collect: { |each| self _visitTemp: each }.
        output print: "foo_send(ctx, &".
        output print: (self selectorCName: aSend selector).
        output print: ", {receiver}, ".
        output print: args size.
        args
            do: { |each|
                  output print: ", {each}" }.
        output print: "); })"!

    method visitSelfInstance: aSelf
        -- Tracer visitSelfInstance: aSelf.
        output print: "ctx->receiver"!

    method visitSelfClass: aSelf
        -- Tracer trace: #visitSelfClass:.
        output print: "(struct Foo)\{ .class = ctx->receiver.class->metaclass, .datum = \{ .ptr = ctx->receiver.class }}"!

    method visitBindDynamic: aBind
        -- Tracer trace: #visitBindDynamic:.
        let name = aBind variable name.
        let index = self declareDynamic: aBind variable.
        let unbind = self genTemp: "unbind".
        output print: "(\{ struct FooUnbind {unbind} = \{ .cleanup = \{ .function = foo_unbind, .next = ctx->cleanup }, .index = {index}, .value = ctx->vars->data[{index}] };".
        output print: " ctx->cleanup = &{unbind}.cleanup;".
        output print: " ctx->vars->data[{index}] = ".
        aBind value visitBy: self.
        output print: ";".
        let res = self _visitTemp: aBind body.
        output print: " assert(&{unbind}.cleanup == ctx->cleanup);".
        output print: " ctx->cleanup = ctx->cleanup->next;".
        output print: " foo_unbind(ctx, &{unbind}.cleanup);".
        output print: " {res}; })"!

    method visitBindLexical: aBind
        -- Tracer trace: #visitBindLexical:.
        output print: "(\{ ctx->frame[{aBind variable index - 1}] = ".
        self _generateTypecheck: aBind variable type
             _for: aBind value.
        output print: ";".
        aBind body visitBy: self.
        output print: "; })"!

    method visitLexicalRef: aRef
        -- Tracer trace: #visitLexicalRef:.
        aRef frameOffset is 0
            ifTrue: { output print: "ctx->frame[{aRef variable index - 1}]" }
            ifFalse: { output print: "foo_lexical_ref(ctx, {aRef variable index - 1}, {aRef frameOffset})" }!

    method visitLexicalSet: aSet
        -- Tracer trace: #visitLexicalSet:.
        aSet frameOffset is 0
            ifTrue: { output print: "(ctx->frame[{aSet variable index - 1}] = " }
            ifFalse: { output print: "foo_lexical_set(ctx, {aSet variable index - 1}, {aSet frameOffset}, " }.
        self _generateTypecheck: aSet variable type
             _for: aSet value.
        output print: ")"!

    method visitBlock: aBlock
        -- Tracer trace: #visitBlock:.
        output print: "foo_closure_new(ctx, ".
        output print: (self closureCName: aBlock).
        output print: ", ".
        output print: aBlock argumentCount.
        output print: ", ".
        output print: aBlock frameSize.
        output print: ")"!

    method visitArray: anArray
        -- Tracer trace: #visitArray:.
        let entries = anArray entries.
        let array = self addTemp.
        output print: "(\{ ctx->frame[{array}] = foo_Array_alloc({entries size}); ".
        entries isEmpty
            ifFalse: { let p = self genTemp: "arrayPtr".
                       output print: "struct FooArray* {p} = PTR(FooArray, ctx->frame[{array}].datum);".
                       entries
                           doWithIndex: { |each index|
                                          output print: "{p}->data[{index-1}] = ".
                                          each visitBy: self.
                                          output print: "; " } }.
        output print: "ctx->frame[{array}]; })"!

    method visitPanic: aPanic
        -- Tracer trace: #visitPanic:.
        output println: "foo_panic(ctx, ".
        aPanic value visitBy: self.
        output println: ")"!
end
