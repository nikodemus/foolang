import .transpiler.name.Name
import .transpiler.integer.IntegerMethods
import .ast.AstClass

define BlockMethods
    { #value -> {signature: [],
                 body: "return foo_apply(ctx, nargs, args);"} }!

define BuiltinClasses
    [{name: "Integer", methods: IntegerMethods},
     {name: "Block", methods: BlockMethods}]!

class SelectorMap { names }
    direct method new
        self names: Dictionary new!

    method map: selector
        names
            at: selector name
            ifNonePut: { Name mangleSelector: selector }!

    method do: block
        names do: block!
end

class CTranspiler { output selectorMap blockFunctions }

    direct method transpile: globals in: env
        let visitor = self
                          output: StringOutput new
                          selectorMap: SelectorMap new
                          blockFunctions: List new.
        -- FIXME: visit Main, and it's dependencies only
        globals do: { |each| each definition visitBy: visitor }.
        visitor generateMain.
        { main: visitor output content,
          blocks: visitor generateBlocks,
          classes: visitor generateClasses,
          selectors: visitor generateSelectors }!

    method generateMain
        output println: "int main".
        output println: "    (int argc, char** argv)".
        output println: "\{".
        output println: "    struct FooContext* ctx = foo_context_new_main(0ul);".
        let main = Name mangleGlobal: {name: "Main"}.
        output println: "    foo_send(ctx, &{Name mangleSelector: #run}, {main}, 0);".
        output println: "    return 0;".
        output println: "}"!

    method generateSelectors
        let output = StringOutput new.
        let prev = "NULL".
        selectorMap do: { |name cname|
                         output print: "struct FooSelector ".
                         output print: cname.
                         output print: " = \{ .name = &FOO_CSTRING(".
                         output display: name.
                         output print: "), .next = ".
                         output print: prev.
                         output print: " };\n".
                         prev = "&{cname}" }.
        output println: "struct FooSelector* FOO_InternedSelectors = {prev};".
        output content!

    method generateClasses
        StringOutput
            with: { |out|
                    BuiltinClasses
                        do: { |each| self _generateClass: each to: out } }!

    method _generateClass: aClass to: stream
        let methods = aClass methods.
        -- 1. Method functions
        methods
            do: { |selector methodInfo|
                  stream println: "struct Foo {Name mangleInstanceMethod: selector in: aClass}".
                  stream println: "    (struct FooContext* ctx, size_t nargs, va_list args)".
                  stream println: "\{".
                  stream println: "    (void)ctx;".
                  stream println: "    (void)nargs;".
                  stream println: "    (void)args;".
                  let signature = methodInfo signature.
                  (selector arity - 1 == signature size) assert.
                  signature
                      doWithIndex: { |argType index|
                                     stream println: "    struct Foo arg{index} = foo_vtable_typecheck(&{Name mangleInstanceVtable: (signature at: index)}, va_arg(args, struct Foo));".
                                     stream println: "    (void)arg{index};" }.
                  stream print: "    ".
                  stream println: (methodInfo body replace: "\n" with: "\n    ").
                  stream println: "}".
                  stream newline }.
        -- 2. MethodArray
        let methodArrayName = "FOO_{aClass name}Methods".
        stream println: "struct FooMethodArray {methodArrayName} = ".
        stream println: "\{".
        stream println: "    .size = {methods size},".
        stream println: "    .data = \{".
        methods
            doKeys: { |each|
                      let arity = each arity - 1. -- Selector arity is one greater!
                      stream println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each},".
                      stream println: "                            .argCount = {arity},".
                      stream println: "                            .frameSize = {arity},".
                      stream println: "                            .function = &{Name mangleInstanceMethod: each in: aClass} }," }.
        stream println: "    }".
        stream println: "};".
        stream newline.
        -- 3. Vtable
        stream println: "struct FooVtable {Name mangleInstanceVtable: aClass} = ".
        stream println: "\{".
        stream println: "    .name = &FOO_CSTRING({aClass name displayString}),".
        stream println: "    .methods = &{methodArrayName}".
        stream println: "};".
        stream newline!

    method generateBlocks
        StringOutput
            with: { |out|
                    blockFunctions do: { |block| out println: block } }!

    method selectorCName: selector
        self selectorMap map: selector!

    method blockCName: block
        let output = StringOutput new.
        -- Placeholder so that recursive entry by visitor doesn't grab the
        -- same id.
        blockFunctions add: False.
        let index = blockFunctions size.
        let cname = "fooblock_id{index}".
        output print: "struct Foo ".
        output print: cname.
        output println: " (struct FooContext* ctx) \{".
        output print: "return ".
        let blockVisitor = CTranspiler
                               output: output
                               selectorMap: selectorMap
                               blockFunctions: blockFunctions.
        block body visitBy: blockVisitor.
        output println: ";\n}".
        blockFunctions put: output content at: index.
        cname!

    method visitClassDefinition: aClass
        aClass directMethods
            do: { |each|
                  self
                      _generateMethod: each
                      _in: aClass
                      _as: (Name mangleDirectMethod: each selector in: aClass) }.
        aClass instanceMethods
            do: { |each|
                  self
                      _generateMethod: each
                      _in: aClass
                      _as: (Name mangleInstanceMethod: each selector in: aClass) }.
        -- Layout
        let layoutName = "FooLayout_{aClass name}".
        output println: "struct FooLayout {layoutName} =".
        output println: "\{".
        output println: "    .size = {aClass slots size},".
        output println: "    .slots = \{".
        aClass slots
            do: { |each|
                  output println: "        \{ .name = FOO_CSTRING({each name displayString}) }," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Constructor
        let instanceVtableName = Name mangleInstanceVtable: aClass.
        let ctor = aClass constructor.
        let ctorName = Name mangleDirectMethod: ctor in: aClass.
        output println: "struct FooVtable {instanceVtableName};". -- forward decl
        output newline.
        output print: "struct Foo ".
        output println: ctorName.
        output println: "    (struct FooContext* ctx, size_t nargs, va_list args)".
        output println: "\{".
        output println: "    (void)ctx;".
        output println: "    (void)nargs;".
        output println: "    (void)args;".
        output println: "    struct Foo* new = FOO_ALLOC_ARRAY({aClass slots size}, struct Foo);".
        output println: "    for (int i = 0; i < {aClass slots size}; ++i)".
        output println: "        new[i] = va_arg(args, struct Foo);".
        output println: "    return (struct Foo)\{ .vtable = &{instanceVtableName}, .datum = \{ .object = new } };".
        output println: "}".
        output newline.
        -- Direct Method Array
        let directMethodArrayName = "FOO_{aClass name}DirectMethods".
        let directMethods = aClass directMethods copy.
        directMethods push: { selector: ctor, arity: aClass slots size, frameSize: 0 }.
        output println: "struct FooMethodArray {directMethodArrayName} =".
        output println: "\{".
        output println: "    .size = {directMethods size},".
        output println: "    .data = \{".
        directMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{Name mangleDirectMethod: each selector in: aClass} }," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Instance Method Array
        let instanceMethodArrayName = "FOO_{aClass name}InstanceMethods".
        output println: "struct FooMethodArray {instanceMethodArrayName} =".
        output println: "\{".
        output println: "    .size = {aClass instanceMethods size},".
        output println: "    .data = \{".
        aClass instanceMethods
            do: { |each|
                  output println: "        (struct FooMethod)\{ .selector = &{self selectorCName: each selector},".
                  output println: "                            .argCount = {each arity},".
                  output println: "                            .frameSize = {each frameSize},".
                  output println: "                            .function = &{Name mangleInstanceMethod: each selector in: aClass} }," }.
        output println: "    }".
        output println: "};".
        output newline.
        -- Class Vtable
        let classVtableName = Name mangleClassVtable: aClass.
        output println: "struct FooVtable {classVtableName} = ".
        output println: "\{".
        output println: "    .name = &FOO_CSTRING({aClass name displayString}\" class\"),".
        output println: "    .methods = &{directMethodArrayName}".
        output println: "};".
        output newline.
        -- Instance Vtable
        output println: "struct FooVtable {instanceVtableName} = ".
        output println: "\{".
        output println: "    .name = &FOO_CSTRING({aClass name displayString}),".
        output println: "    .methods = &{instanceMethodArrayName}".
        output println: "};".
        output newline.
        -- Class struct
        let className = "FooClass_{aClass name}".
        output println: "struct FooClass {className} = ".
        output println: "\{".
        output println: "    .instanceVtable = &{instanceVtableName}".
        output println: "};".
        output newline.
        -- Class object
        let globalName = Name mangleGlobal: aClass.
        output println: "struct Foo {globalName} =".
        output println: "\{".
        output println: "    .vtable = &{classVtableName},".
        output println: "    .datum = \{ .class = &{className} }".
        output println: "};".
        output newline!

    method _generateMethod: aMethod _in: aClass _as: mangledName
        output print: "struct Foo ".
        output println: mangledName.
        output println: "    (struct FooContext* ctx, size_t nargs, va_list args)".
        output println: "\{".
        output println: "    (void)ctx;".
        output println: "    (void)nargs;".
        output println: "    (void)args;".
        output print: "    return ".
        aMethod body visitBy: self.
        output println: ";".
        output println: "}"!

    method visitComment: aComment
        -- FIXME: Include comments in generated source.
        aComment value visitBy: self!

    method visitConstant: aConstant
        let value = aConstant value.
        (Integer includes: value)
            ifTrue: { return output print: "foo_Integer_new({value})" }.
        Error raise: "Don't know how to transpile constant `{value}` into C."!

    method visitSend: aSend
        output print: "foo_send(ctx, &".
        output print: (self selectorCName: aSend selector).
        output print: ", ".
        aSend receiver visitBy: self.
        output print: ", ".
        output print: aSend arguments size.
        output print: "ul".
        aSend arguments
            do: { |arg|
                  output print: ", ".
                  arg visitBy: self }.
        output print: ")"!

    method visitSelfInstance: aSelf
        output print: "ctx->receiver"!

    method visitBindLexical: aBind
        output print: "(\{ ctx->frame[{aBind variable index - 1}ul] = ".
        aBind value visitBy: self.
        output print: ";".
        aBind body visitBy: self.
        output print: "; })"!

    method visitLexicalRef: aRef
        output print: "foo_lexical_ref(ctx, {aRef variable index - 1}ul, {aRef frameOffset}ul)"!

    method visitBlock: aBlock
        output print: "foo_block_new(ctx, ".
        output print: (self blockCName: aBlock).
        output print: ", ".
        output print: aBlock argumentCount.
        output print: ", ".
        output print: aBlock frameSize.
        output print: ")"!
end
