import .source.*
import .syntax.*
import .utils.Debug

interface Token
    is Object

    direct method from: first to: last in: parser
        self
            string: (parser source from: first to: last)
            first: first last: last!

    method precedence
        False!

    method parseAsSuffixOf: prefix with: parser
        Error raise: "Cannot parse {self} (@{self first}) in suffix position {parser syntaxTable where}! (self-hosted parser)"!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        Error raise: "Cannot parse {self} (@{self first}) in prefix position position {parser syntaxTable where}! (self-hosted parser)"!

    method toString
        "#<Token \"{self string}\">"!

    required method string
end

define StringEscapes
    let escapes = Dictionary new.
    escapes put: "\n" at: "n".
    escapes!

class TokenString { string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let out = StringOutput new.
        let escape = False.
        first to: last
              do: { |pos|
                    (escape not and: (parser atEscape: pos))
                        ifTrue: { escape = True }
                        ifFalse: { let orig = parser source from: pos to: pos.
                                   out print: (escape
                                                   ifTrue: { escape = False.
                                                             self escape: orig }
                                                   ifFalse: { orig }) } }.
        SyntaxLiteral value: out content!

    method escape: s
        StringEscapes at: s ifNone: { s }!
end

class TokenDecimal { string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let n = 0.
        1 to: string size
          do: { |pos|
                n = n * 10 + (string at: pos) digit }.
        SyntaxLiteral value: n!

    method toString
        "#<TokenDecimal {string}>"!
end

class TokenEof { position }
    is Token

    direct method at: position in: parser
        self position: position!

    method precedence
        0!

    method string
        "EOF"!

    method first
        position!

    method last
        position!
end

-- For CoreSyntaxTable --

class InvalidToken { precedence string first last }
    is Token
end

class CommentToken { precedence string first last }
    is Token
    ---
    See also: special handlings in SequenceToken and LetToken to parse

        foo bar. -- comment
        quux zot

        let x = foo bar. -- comment
        quux zot

    as suffix comments on `foo bar`.
    ---

    method parseAsPrefixWith: parser atPrecedence: precedence
        -- NOTE: must continue at same precedence! Consider eg.
        --
        --    let x = -- comment
        --            -42 abs.
        --    123
        --
        -- where the comment is reached while parsing at SingleExpressionPrecedence,
        -- versus:
        --
        --    foo bar.
        --    -- comment
        --    bar quux
        --
        -- where the comment is reached while parsing at SeqPrecedence!
        SyntaxPrefixComment
            comment: parser readline
            value: (parser parseAtPrecedence: precedence)
            source: (parser sourceFrom: first to: last)!

    method parseAsSuffixOf: prefix with: parser
        SyntaxSuffixComment
            comment: parser readline
            value: prefix
            source: (parser sourceFrom: first to: last)!
end

-- For ExpressionSyntaxTable --

class SequenceToken { precedence string first last }
    is Token
    ---
    Special casing for end of line comments after dot to
    make the following a _suffix_ comment on `foo bar`:

        foo bar. -- comment
        quux zot

    The human expectation trumps consistency here.
    ---

    method parseAsSuffixOf: prefix with: parser
        SyntaxSeq
            first: (parser handleSuffixCommentOf: prefix)
            then: (parser parseAtPrecedence: SeqPrecedence)!
end

class AssignmentToken { precedence string first last }
    is Token

    method parseAsSuffixOf: prefix with: parser
        SyntaxAssign
            variable: prefix::SyntaxVariable
            value: (parser parseAtPrecedence: SingleExpressionPrecedence)!
end

class BlockStartToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let parameters = List new.
        parser
            when: "|"
            then: { parser nextToken.
                    parser until: "|"
                           do: { parameters add: (parser parseVariableName) } }.
        let body = parser parseAtPrecedence: SeqPrecedence.
        parser expect: "}".
        SyntaxBlock
            parameters: parameters
            body: body!
end

class ArrayStartToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let elements = List new.
        -- Optional leading comma
        parser when: ","
               then: { parser nextToken }.
        parser until: "]"
               do: { elements add: parser parse.
                     -- Allow trailing comma
                     parser unless: "]"
                            then: { parser expect: "," } }.
        parser expect: "]".
        SyntaxArray
            elements: elements!
end

class OpenParenToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let body = parser parseAtPrecedence: SeqPrecedence.
        parser expect: ")".
        SyntaxParens body: body!
end

class IsSuffixToken { precedence string first last }
    is Token

    method parseAsSuffixOf: prefix with: parser
        SyntaxIs
            left: prefix
            right: (parser parseAtPrecedence: SingleExpressionPrecedence)!

    method toString
        "#<IsSuffixToken>"!
end

class LetToken { precedence string first last }
    is Token

    ---
    Special casing for end of line comments after dot to
    make the following a _suffix_ comment on `foo bar`:

        let x = foo bar. -- comment
        quux zot

    The human expectation trumps consistency here.
    ---

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let name = parser parseVariableName.
        parser expect: "=".
        let value = (parser parseAtPrecedence: SingleExpressionPrecedence).
        parser expect: ".".
        SyntaxLet
            name: name
            value: (parser handleSuffixCommentOf: value)
            body: (parser parseAtPrecedence: SeqPrecedence)!
end

class SelfToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxSelf new!

    method toString
        "#<SelfToken>"!
end

class ReturnToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxReturn
            value: (parser parseAtPrecedence: SingleExpressionPrecedence)!

    method toString
        "#<ReturnToken>"!
end

-- For ToplevelSyntaxTable --

class ClassToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let name = parser parseVariableName.
        let slots = List new.
        parser expect: "\{".
        parser until: "}"
               do: { slots add: parser parseVariableName }.
        parser expect: "}".
        let theClass = SyntaxClass name: name slots: slots.
        let classParser = parser syntaxTable: ClassSyntaxTable.
        classParser
            until: "end"
            do: { theClass add: (classParser parseAtPrecedence: precedence) }.
        parser expect: "end".
        parser handleSuffixCommentOf: theClass!

    method toString
        "#<ClassToken>"!
end

class DefineToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let definitionParser = parser syntaxTable: ExpressionSyntaxTable.
        let def = SyntaxDefine
                      name: definitionParser parseVariableName
                      body: (definitionParser parseAtPrecedence: SeqPrecedence).
        parser expect: "!".
        def!

    method toString
        "#<DefineToken>"!
end

class InterfaceToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let theInterface = SyntaxInterface name: parser parseVariableName.
        let interfaceParser = parser syntaxTable: InterfaceSyntaxTable.
        interfaceParser
            until: "end"
            do: { theInterface add: (interfaceParser parseAtPrecedence: precedence) }.
        interfaceParser
            expect: "end".
        parser handleSuffixCommentOf: theInterface!

    method toString
        "#<InterfaceToken>"!
end

-- For ClassSyntaxTable and InterfaceSyntaxTable --

class IsPrefixToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxInterfaceRef name: parser parseVariableName!

    method toString
        "#<IsPrefixToken>"!
end

interface MethodToken
    is Token

    method parseWith: parser as: methodClass
        let bodyParser = parser syntaxTable: ExpressionSyntaxTable.
        let signature = self parseMethodSignatureWith: bodyParser.
        -- Debug println: "\n- method {signature selector}, {methodClass}".
        let body = bodyParser parseAtPrecedence: SeqPrecedence.
        parser expect: "!".
        body = bodyParser handleSuffixCommentOf: body.
        methodClass
                signature: signature
                body: body!

    method parseMethodSignatureWith: parser
        let selector = StringOutput new.
        let parameters = List new.
        parser nextToken
            parseAsMethodSignatureWith: parser
            selector: selector
            parameters: parameters.
        MethodSignature
            selector: (Selector new: selector content)
            parameters: parameters!

    method toString
        "#<MethodToken>"!
end

class InstanceMethodToken { precedence string first last }
    is MethodToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        self parseWith: parser as: SyntaxInstanceMethod!

    method toString
        "#<InstanceMethodToken>"!
end

class DirectMethodToken { precedence string first last }
    is MethodToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        parser expect: "method".
        self parseWith: parser as: SyntaxDirectMethod!

    method toString
        "#<DirectMethodToken>"!
end

class BangToken { precedence string first last }
    is Token

    method toString
        "#<BangToken>"!
end

class SyntaxTable { where tokens }
    is Object

    method where: newWhere tokens: newTokens
        SyntaxTable
            where: newWhere
            tokens: (tokens copy merge: newTokens)!
end

-- FIXME: call it binding power, it's more accurate
class SyntaxEntry { tokenClass precedence }
    is Object
end

class SigilEntry { precedence }
    is Object
    method tokenClass
        TokenSigil!
end

define SeqPrecedence
    1!

define SingleExpressionPrecedence
    2! -- dot has precedence 2

define KeywordPrecedence
    9!

define UnknownOperatorPrecedence
    10!

define UnaryPrecedence
    1000!

define PrefixPrecedence
    1000!

define CoreSyntaxTable
    SyntaxTable
    where: "anywhere"
    tokens:
    {
         "}" -> SyntaxEntry tokenClass: InvalidToken precedence: 0,
         ")" -> SyntaxEntry tokenClass: InvalidToken precedence: 0,
         "]" -> SyntaxEntry tokenClass: InvalidToken precedence: 0,
         "," -> SyntaxEntry tokenClass: InvalidToken precedence: 0,
         "--" -> SyntaxEntry tokenClass: CommentToken precedence: 1000
    }!

define ExpressionSyntaxTable
    CoreSyntaxTable
    where: "in an expression"
    tokens:
    {
         "return" -> SyntaxEntry tokenClass: ReturnToken precedence: 1000,
         "self" -> SyntaxEntry tokenClass: SelfToken precedence: 1000,
         "*" -> SigilEntry precedence: 90,
         "/" -> SigilEntry precedence: 90,
         "+" -> SigilEntry precedence: 80,
         "-" -> SigilEntry precedence: 80,
         "is" -> SyntaxEntry tokenClass: IsSuffixToken precedence: 10,
         "=" -> SyntaxEntry tokenClass: AssignmentToken precedence: 4,
         "let" -> SyntaxEntry tokenClass: LetToken precedence: 3,
         -- Why precedence 3 for these?
         "\{" -> SyntaxEntry tokenClass: BlockStartToken precedence: 3,
         "[" -> SyntaxEntry tokenClass: ArrayStartToken precedence: 3,
         "(" -> SyntaxEntry tokenClass: OpenParenToken precedence: 3,
         "." -> SyntaxEntry tokenClass: SequenceToken precedence: 2,
         "!" -> SyntaxEntry tokenClass: BangToken precedence: 1
    }!

define ToplevelSyntaxTable
    CoreSyntaxTable
    where: "at toplevel"
    tokens:
    {
         "define" -> SyntaxEntry tokenClass: DefineToken precedence: 1000,
         "class" -> SyntaxEntry tokenClass: ClassToken precedence: 1000,
         "interface" -> SyntaxEntry tokenClass: InterfaceToken precedence: 1000
    }!

define MixedSyntaxTable
    ExpressionSyntaxTable
    where: "here"
    tokens: ToplevelSyntaxTable tokens!

define ClassSyntaxTable
    CoreSyntaxTable
    where: "in a class"
    tokens:
    {
         "is" -> SyntaxEntry tokenClass: IsPrefixToken precedence: 1000,
         "method" -> SyntaxEntry tokenClass: InstanceMethodToken precedence: 1000,
         "direct" -> SyntaxEntry tokenClass: DirectMethodToken precedence: 1000
    }!

-- Currently same as ClassSyntaxTable, but will diverge with required methods, etc
define InterfaceSyntaxTable
    ClassSyntaxTable
    where: "in an interface"
    tokens: Dictionary new!

interface LookupToken
    is Token

    direct method from: first to: last in: parser
        let tokenString = parser source from: first to: last.
        -- Figure out the correct tokenclass using current syntax.
        let entry = parser syntaxTable tokens
                        at: tokenString
                        ifNone: { SyntaxEntry
                                      tokenClass: self
                                      precedence: (self defaultPrecedence) }.
        -- Debug println: "token '{tokenString}' --> {tokenClass}".
        entry tokenClass
            precedence: entry precedence
            string: tokenString
            first: first
            last: last!
end

class TokenSigil { precedence string first last }
    is LookupToken

    direct method defaultPrecedence
        UnknownOperatorPrecedence!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxPrefix
            receiver: (parser parseAtPrecedence: PrefixPrecedence)
            selector: (Selector name: string)
            source: (parser sourceFrom: first to: last)!

    method parseAsSuffixOf: prefix with: parser
        SyntaxBinary
            receiver: prefix
            selector: (Selector name: string)
            argument: (parser parseAtPrecedence: precedence)
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        parameters add: parser parseVariableName!
end

class TokenWord { precedence string first last }
    is LookupToken

    direct method defaultPrecedence
        UnaryPrecedence!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxVariable
            name: string!

    method parseAsSuffixOf: prefix with: parser
        SyntaxUnary
            receiver: prefix
            selector: (Selector name: string)
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        string == "prefix"
            ifTrue: { let op = parser nextToken.
                      (TokenSigil includes: op)
                          ifFalse: { Error raise: "Expected prefix sigil, got: {op string}" }.
                      selector print: op string }!

    method toString
        "#<TokenWord {string}>"!
end

class TokenKeyword { string first last }
    is Token

    direct method from: first to: last in: parser
        self string: (parser source from: first to: last)
             first: first
             last: last!

    method precedence
        KeywordPrecedence!

    method parseAsSuffixOf: prefix with: parser
        let arguments = List new.
        let selector = StringOutput new: string.
        { arguments push: (parser parseAtPrecedence: self precedence).
          let token = parser lookahead.
          (TokenKeyword includes: token)
              ifTrue: { parser nextToken.
                        selector print: token string.
                        True } }
        whileTrue.
        SyntaxKeyword
            receiver: prefix
            selector: (Selector name: selector content)
            arguments: arguments
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        parameters add: parser parseVariableName.
        (TokenKeyword includes: parser lookahead)
            ifTrue: { parser nextToken
                          parseAsMethodSignatureWith: parser
                          selector: selector
                          parameters: parameters }!
end

define SpecialCharacters
    ["(" character,
     ")" character,
     "[" character,
     "]" character,
     "\{" character,
     "}" character,
     "!" character,
     "." character,
     ";" character,
     "," character]!

define UnderscoreCharacter
    "_" character!

define DoublequoteCharacter
    "\"" character!

define EscapeCharacter
    "\\" character!

define ColonCharacter
    ":" character!

-- FIXME: Broken for unicode input!
class Parser { source::String
               positionBox
               first::Integer
               last::Integer
               stack::List -- for lookahead
               syntaxTable }
    is Object

    method position
        positionBox first!

    method toString
        "#<Parser position: {self position}>"!

    direct method _new: source syntaxTable: syntaxTable
        source
            ifEmpty: { Error raise: "Cannot parse empty string!" }.
        self
            source: source
            positionBox: [1]
            first: 1
            last: (source size)
            stack: List new
            syntaxTable: syntaxTable!

    method syntaxTable: newSyntaxTable
        Parser
            source: source
            positionBox: positionBox
            first: first
            last: (source size)
            stack: stack
            syntaxTable: newSyntaxTable!

    direct method parseExpressions: source
        (self _new: source syntaxTable: ExpressionSyntaxTable)
            parseAll: #parse!

    direct method parseDefinitions: source
        (self _new: source syntaxTable: ToplevelSyntaxTable)
            parseAll: #parsePrefix!

    direct method parseMixed: source
        (self _new: source syntaxTable: MixedSyntaxTable)
            parseAll: #parse! -- wwwhhhhaaaaa

    method parseAll: selector
        let syntax = List new.
        { self skipWhitespace.
          self atEof }
        whileFalse: { syntax add: (selector sendTo: self) }.
        -- syntax do: { |s| Debug println: "=> {s}" }.
        syntax!

    method handleSuffixCommentOf: prefix
        -- #sees: means without intervening newline!
        (self sees: "--")
            ifTrue: { self nextToken
                          parseAsSuffixOf: prefix
                          with: self }
            ifFalse: { prefix }!

    method readline
        let start = self position.
        { self atEof or: self atNewline }
            whileFalse: { self advance }.
        let stop = self position - 1.
        self atEof
            ifFalse: { self advance }.
        source from: start to: stop!

    method sourceFrom: first to: last
        SourceString string: source first: first last: last!

    method parse
        self parseAtPrecedence: 0!

    method parsePrefix
        self parseAtPrecedence: 1000!

    method parseVariableName
        let token = self nextToken.
        (TokenWord includes: token)
            ifFalse: { Error raise: "Invalid variable name in self-hosted parser: {token string}" }.
        token string!

    method expect: expected
        let got = self nextToken string.
        got == expected
            ifFalse: { Error raise: "Expected '{expected}', got '{got}' {syntaxTable where} (self-hosted parser)
Position: {self position}
Source: {source}" }!

    method sees: test
        -- Cannot use lookahead since that would skip newlines!
        self skipWhile: { self atHorizontalWhitespace }.
        let last = (self position + test size - 1) min: source size.
        test == (source from: self position to: last)!

    method when: test then: action
        self lookahead string == test
            ifTrue: { action value }!

    method unless: test then: action
        self lookahead string == test
            ifFalse: { action value }!

    method until: test do: action
        { self lookahead string == test }
            whileFalse: action!

    method parseAtPrecedence: precedence
        self
            parseSuffixOf: (self parsePrefixAtPrecedence: precedence)
            with: precedence!

    method parsePrefixAtPrecedence: precedence
        self nextToken parseAsPrefixWith: self atPrecedence: precedence!

    method parseSuffixOf: prefix with: precedence
        let expr = prefix.

        { -- Debug println: "expr: {expr}, precedence={precedence}, next={self lookahead}?, nextPrecedence={self nextPrecedence}".
          precedence < self nextPrecedence }
        whileTrue: { -- Debug println: " -> go".
                     expr = self parseSuffixOf: expr }.
        -- Debug println: " -> no".
        expr!

    method parseSuffixOf: prefix
        self nextToken parseAsSuffixOf: prefix with: self!

    method nextPrecedence
        self lookahead precedence!

    method lookahead
        stack
            ifEmpty: { stack push: self scanNext }.
        stack first!

    method nextToken
        stack isEmpty
            ifTrue: { self scanNext }
            ifFalse: { stack pop }!

    method scanNext
        self skipWhitespace.
        self atEof
            ifTrue: { return TokenEof at: self position in: self }.
        self atSpecial
            ifTrue: { return self scanSpecial }.
        self atDigit
            ifTrue: { return self scanDecimal }.
        self atDoublequote
            ifTrue: { return self scanString }.
        self atSigil
            ifTrue: { return self scanSigil }.
        self atWord
            ifTrue: { return self scanWord }.
        Error raise: "Don't know how to scan pos: {self position} in: {source}"!

    method atEof
        self atEof: self position!

    method atEof: position
        position > last!

    method atSpecial
        self isAt: { |char|
                     SpecialCharacters
                         anySatisfy: { |special| special == char } }!

    method atDigit
        self isAt: #isDigit!

    method atDoublequote
        self isAt: { |char| char == DoublequoteCharacter }!

    method atWord
        self isAt: { |char|
                     char isAlphanumeric or: char == UnderscoreCharacter }!

    method atTerminating
        self atSpecial or: self atWhitespace!

    method atNewline
        self isAt: #isNewline!

    method atHorizontalWhitespace
        self isAt: #isHorizontalWhitespace!

    method atSigil
        self atEof not
            ifTrue: { (self atWord or: self atTerminating) not }!

    method atWhitespace
        self isAt: #isWhitespace!

    method atChar: char1 notFollowedBy: char2
        self atEof
            ifTrue: { return False }.
        (source at: self position) == char1
            ifFalse: { return False }.
        (self position + 1 > last)
            ifFalse: { ((source at: self position + 1) == char2) not }!

    method afterEscape
        self atEscape: self position - 1!

    method atEscape: position
        (self atEof: position)
            ifTrue: { return False }.
        (position >= first)
            ifTrue: { (source at: position) == EscapeCharacter }!

    method isAt: block
        self atEof
            ifTrue: { False }
            ifFalse: { block value: (source at: self position) }!

    method skipWhile: test
        -- Debug println: "/skipWhile: {test}".
        let start = self position.
        test whileTrue: { self advance }.
        self position - 1!

    method skipWhitespace
        self skipWhile: { self atWhitespace }!

    method scanSpecial
        -- Debug println: "/scanSpecial".
        let start = self position.
        self advance.
        TokenSigil
            from: start
            to: start
            in: self!

    method scanDecimal
        -- Debug println: "/scanDecimal".
        TokenDecimal
            from: self position
            to: (self skipWhile: { self atDigit })
            in: self!

    method scanString
        -- Debug println: "/scanString".
        self advance.
        let string = TokenString
                         from: self position
                         to: (self skipWhile: { self atDoublequote not or: self afterEscape })
                         in: self.
        self advance.
        string!

    method scanSigil
        -- Debug println: "/scanSigil".
        TokenSigil
            from: self position
            to: (self skipWhile: { self atSigil })
            in: self!

    method scanWord
        -- Debug println: "/scanWord".
        let first = self position.
        self skipWhile: { self atWord }.
        (self atChar: ColonCharacter notFollowedBy: ColonCharacter)
            ifTrue: { self advance.
                      TokenKeyword
                          from: first
                          to: self position - 1
                          in: self }
            ifFalse: { TokenWord
                           from: first
                           to: self position - 1
                           in: self }!

    method advance
        self position <= last
            ifFalse: { panic "Tried to advance beyond end: \"{source}\"" }.
        positionBox put: self position + 1 at: 1!

end
