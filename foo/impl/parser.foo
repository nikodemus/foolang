import .source.*
import .syntax.*
import .utils.Debug

define SeqPrecedence
    1!

define SingleExpressionPrecedence
    2! -- dot has precedence 2

define KeywordPrecedence
    9!

define UnknownOperatorPrecedence
    10!

define PrefixPrecedence
    1000!

define UnaryPrecedence
    1000!

define TokenPrecedence
    let tokens = Dictionary new.
    tokens put: 90 at: "*".
    tokens put: 90 at: "/".
    tokens put: 80 at: "-".
    tokens put: 80 at: "+".
    tokens put: 10 at: "is".
    tokens put: 4 at: "=".
    tokens put: 3 at: "let".
    tokens put: 3 at: "(".
    tokens put: 3 at: "\{".
    tokens put: 2 at: ".".
    tokens put: 1 at: "!".
    tokens put: 0 at: ")".
    tokens put: 0 at: "}".
    tokens put: 0 at: "define".
    tokens put: 0 at: "class".
    tokens!

interface Token
    is Object

    direct method from: first to: last in: parser
        self
            string: (parser source from: first to: last)
            first: first last: last!

    method precedence
        Error raise: "{self string} is not valid in suffix position in self-hosted parser!"!

    method parseAsSuffixOf: prefix with: parser
        Error raise: "Self-hosted parser cannot parse {self} ({self first}) in suffix position!"!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        Error raise: "Self-hosted parser cannot parse {self} ({self first}) in prefix position!"!

    method toString
        "#<Token \"{self string}\">"!
end

define StringEscapes
    let escapes = Dictionary new.
    escapes put: "\n" at: "n".
    escapes!

class TokenString { string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let out = StringOutput new.
        let escape = False.
        first to: last
              do: { |pos|
                    (escape not and: (parser atEscape: pos))
                        ifTrue: { escape = True }
                        ifFalse: { let orig = parser source from: pos to: pos.
                                   out print: (escape
                                                   ifTrue: { escape = False.
                                                             self escape: orig }
                                                   ifFalse: { orig }) } }.
        SyntaxLiteral value: out content!

    method escape: s
        StringEscapes at: s ifNone: { s }!
end

interface SuffixToken
    is Token

    method precedence
        TokenPrecedence
            at: self string
            ifNone: { UnknownOperatorPrecedence }!
end

class TokenDecimal { string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let n = 0.
        1 to: string size
          do: { |pos|
                n = n * 10 + (string at: pos) digit }.
        SyntaxLiteral value: n!
end

class TokenEof { position }
    is Token

    direct method at: position in: parser
        self position: position!

    method precedence
        0!

    method string
        "EOF"!
end

interface ReservedToken
    is SuffixToken
    direct method string: string first: first last: last
        self first: first last: last!
end

class TokenReservedWordDefine { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let def = SyntaxDefine
                      name: parser parseVariableName
                      body: (parser parseAtPrecedence: SeqPrecedence).
        parser expect: "!".
        def!

    method string
        "define"!
end

class TokenReservedWordEnd { first last }
    is ReservedToken

    method string
        "end"!
end

class TokenReservedWordIs { first last }
    is ReservedToken

    method parseAsSuffixOf: prefix with: parser
        SyntaxIs
            left: prefix
            right: (parser parseAtPrecedence: SingleExpressionPrecedence)!

    method string
        "is"!
end

class TokenReservedWordReturn { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxReturn
            value: (parser parseAtPrecedence: SingleExpressionPrecedence)!

    method string
        "return"!
end

class TokenReservedWordLet { first last }
    is ReservedToken

    ---
    Special casing for end of line comments after dot to
    make the following a _suffix_ comment on `foo bar`:

        let x = foo bar. -- comment
        quux zot

    The human expectation trumps consistency here.
    ---

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let name = parser parseVariableName.
        parser expect: "=".
        let value = (parser parseAtPrecedence: SingleExpressionPrecedence).
        parser expect: ".".
        SyntaxLet
            name: name
            value: (parser handleSuffixCommentOf: value)
            body: (parser parseAtPrecedence: SeqPrecedence)!

    method string
        "let"!
end

class TokenReservedSigilDot { first last }
    is ReservedToken

    ---
    Special casing for end of line comments after dot to
    make the following a _suffix_ comment on `foo bar`:

        foo bar. -- comment
        quux zot

    The human expectation trumps consistency here.
    ---

    method parseAsSuffixOf: prefix with: parser
        SyntaxSeq
            first: (parser handleSuffixCommentOf: prefix)
            then: (parser parseAtPrecedence: SeqPrecedence)!

    method string
        "."!
end

class TokenReservedSigilOpenParen { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let body = parser parseAtPrecedence: SeqPrecedence.
        parser expect: ")".
        SyntaxParens
            body: body!

    method string
        "("!
end

class TokenReservedSigilCloseParen { first last }
    is ReservedToken
    method string
        ")"!
end

class TokenReservedSigilOpenBrace { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let parameters = List new.
        parser
            when: "|"
            then: { parser until: "|"
                           do: { parameters add: (parser parseVariableName) } }.
        let body = parser parseAtPrecedence: SeqPrecedence.
        parser expect: "}".
        SyntaxBlock
            parameters: parameters
            body: body!

    method string
        "\{"!
end

class TokenReservedSigilCloseBrace { first last }
    is ReservedToken

    method precedence
        0!

    method string
        "}"!
end

class TokenReservedSigilEqual { first last }
    is ReservedToken

    method parseAsSuffixOf: prefix with: parser
        SyntaxAssign
            variable: prefix::SyntaxVariable
            value: (parser parseAtPrecedence: SingleExpressionPrecedence)!

    method string
        "="!
end

class TokenReservedSigilDoubledash { first last }
    is ReservedToken

    ---
    See also: special handlings in TokenReservedSigilDot and
    TokenReservedSigilLet to parse

        foo bar. -- comment
        quux zot

        let x = foo bar. -- comment
        quux zot

    as suffix comments on `foo bar`.
    ---

    method parseAsPrefixWith: parser atPrecedence: precedence
        -- NOTE: must continue at same precedence! Consider eg.
        --
        --    let x = -- comment
        --            -42 abs.
        --    123
        --
        -- where the comment is reached while parsing at SingleExpressionPrecedence,
        -- versus:
        --
        --    foo bar.
        --    -- comment
        --    bar quux
        --
        -- where the comment is reached while parsing at SeqPrecedence!
        SyntaxPrefixComment
            comment: parser readline
            value: (parser parseAtPrecedence: precedence)
            source: (parser sourceFrom: first to: last)!

    method parseAsSuffixOf: prefix with: parser
        SyntaxSuffixComment
            comment: parser readline
            value: prefix
            source: (parser sourceFrom: first to: last)!

    method string
        "--"!
end

class TokenReservedWordSelf { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxSelf new!
end

class TokenReservedWordClass { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let name = parser parseVariableName.

        let slots = List new.
        parser expect: "\{".
        parser until: "}"
               do: { slots add: parser parseVariableName }.

        let directMethods = List new.
        let methods = List new.
        parser until: "end"
               do: { self
                         parseClassPartWith: parser
                         directMethods: directMethods
                         methods: methods }.

        let theClass = SyntaxClass
                           name: name
                           directMethods: directMethods
                           slots: slots
                           methods: methods.
        parser handleSuffixCommentOf: theClass!

    method parseClassPartWith: parser directMethods: directMethods methods: methods
        -- FIXME: This should instead augment the syntax of the parser
        -- with method and direct. That way we will get comments, etc right.
        parser when: "direct"
               then: { parser expect: "method".
                       directMethods add: (self parseMethodWith: parser).
                       return True }.
        parser when: "method"
               then: { methods add: (self parseMethodWith: parser).
                       return True }.
        Error raise: "Syntax error in class body: {parser nextToken string}"!

    method parseMethodWith: parser
        let syntax = SyntaxMethod
            signature: (self parseMethodSignatureWith: parser)
            body: (parser parseAtPrecedence: SeqPrecedence).
        parser expect: "!".
        parser handleSuffixCommentOf: syntax!

    method parseMethodSignatureWith: parser
        let selector = StringOutput new.
        let parameters = List new.
        parser nextToken
            parseAsMethodSignatureWith: parser
            selector: selector
            parameters: parameters.
        MethodSignature
            selector: (Selector new: selector content)
            parameters: parameters!

    method string
        "class"!
end

define ReservedTokens
    let tokens = Dictionary new.
    tokens put: TokenReservedSigilCloseBrace at: "}".
    tokens put: TokenReservedSigilCloseParen at: ")".
    tokens put: TokenReservedSigilDot at: ".".
    tokens put: TokenReservedSigilEqual at: "=".
    tokens put: TokenReservedSigilOpenBrace at: "\{".
    tokens put: TokenReservedSigilOpenParen at: "(".
    tokens put: TokenReservedWordClass at: "class".
    tokens put: TokenReservedWordDefine at: "define".
    tokens put: TokenReservedWordIs at: "is".
    tokens put: TokenReservedWordLet at: "let".
    tokens put: TokenReservedWordSelf at: "self".
    tokens put: TokenReservedWordReturn at: "return".
    tokens put: TokenReservedSigilDoubledash at: "--".
    tokens!

interface LookupToken
    is SuffixToken

    direct method from: first to: last in: parser
        let tokenString = parser source from: first to: last.
        -- Reserved words get their own classes!
        let tokenClass = ReservedTokens
                             at: tokenString
                             ifNone: { Self }.
        tokenClass string: tokenString first: first last: last!
end

class TokenSigil { string first last }
    is LookupToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxPrefix
            receiver: (parser parseAtPrecedence: PrefixPrecedence)
            selector: (Selector name: string)
            source: (parser sourceFrom: first to: last)!

    method parseAsSuffixOf: prefix with: parser
        SyntaxBinary
            receiver: prefix
            selector: (Selector name: string)
            argument: (parser parseAtPrecedence: (self precedence))
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        parameters add: parser parseVariableName!
end

class TokenWord { string first last }
    is LookupToken

    method precedence
        UnaryPrecedence!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxVariable
            name: string!

    method parseAsSuffixOf: prefix with: parser
        SyntaxUnary
            receiver: prefix
            selector: (Selector name: string)
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        string == "prefix"
            ifTrue: { let op = parser nextToken.
                      (TokenSigil includes: op)
                          ifFalse: { Error raise: "Expected prefix sigil, got: {op string}" }.
                      selector print: op string }!
end

class TokenKeyword { string first last }
    is SuffixToken

    method precedence
        KeywordPrecedence!

    method parseAsSuffixOf: prefix with: parser
        let arguments = List new.
        let selector = StringOutput new: string.
        { arguments push: (parser parseAtPrecedence: (self precedence)).
          let token = parser lookahead.
          (TokenKeyword includes: token)
              ifTrue: { parser nextToken.
                        selector print: token string.
                        True } }
        whileTrue.
        SyntaxKeyword
            receiver: prefix
            selector: (Selector name: selector content)
            arguments: arguments
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        parameters add: parser parseVariableName.
        (TokenKeyword includes: parser lookahead)
            ifTrue: { parser nextToken
                          parseAsMethodSignatureWith: parser
                          selector: selector
                          parameters: parameters }!
end

define SpecialCharacters
    ["(" character,
     ")" character,
     "[" character,
     "]" character,
     "\{" character,
     "}" character,
     "!" character,
     "." character,
     ";" character,
     "," character]!

define UnderscoreCharacter
    "_" character!

define DoublequoteCharacter
    "\"" character!

define EscapeCharacter
    "\\" character!

define ColonCharacter
    ":" character!

-- FIXME: Broken for unicode input!
class Parser { source::String
               position::Integer
               first::Integer
               last::Integer
               lookahead::List }
    is Object

    direct method new: source
        source
            ifEmpty: { Error raise: "Cannot parse empty string!" }.
        self
            source: source
            position: 1
             first: 1
             last: (source size)
             lookahead: List new!

    direct method parse: source::String
        let parser = self new: source.
        let syntax = List new.
        { parser skipWhitespace. parser atEof }
            whileFalse: { syntax add: (parser parse) }.
        -- syntax do: { |s| Debug println: "=> {s}" }.
        syntax!

    method handleSuffixCommentOf: prefix
        -- #sees: means without intervening newline!
        (self sees: "--")
            ifTrue: { self nextToken
                          parseAsSuffixOf: prefix
                          with: self }
            ifFalse: { prefix }!

    method readline
        let start = position.
        { self atEof or: self atNewline }
            whileFalse: { self advance }.
        let stop = position - 1.
        self atEof
            ifFalse: { self advance }.
        source from: start to: stop!

    method sourceFrom: first to: last
        SourceString string: source first: first last: last!

    method parse
        self parseAtPrecedence: 0!

    method parseVariableName
        let token = self nextToken.
        (TokenWord includes: token)
            ifFalse: { Error raise: "Invalid variable name in self-hosted parser: {token string}" }.
        token string!

    method expect: expected
        let got = self nextToken string.
        got == expected
            ifFalse: { Error raise: "Self-hosted parser expected '{expected}', got '{got}'
Context: {source}" }!

    method sees: test
        -- Cannot use lookahead since that would skip newlines!
        self skipWhile: { self atHorizontalWhitespace }.
        let last = (position + test size - 1) min: source size.
        test == (source from: position to: last)!

    method when: test then: action
        self lookahead string == test
            ifTrue: { self nextToken. action value }!

    method until: test do: action
        { self lookahead string == test }
            whileFalse: action.
        self nextToken!

    method while: test do: action
        { self lookahead string == test }
            whileTrue: { self nextToken. action value }!

    method parseAtPrecedence: precedence
        self
            parseSuffixOf: (self parsePrefixAtPrecedence: precedence)
            with: precedence!

    method parsePrefixAtPrecedence: precedence
        self nextToken parseAsPrefixWith: self atPrecedence: precedence!

    method parseSuffixOf: prefix with: precedence
        let expr = prefix.

        { -- Debug println: "expr: {expr}, precedence={precedence}, next={self lookahead}? {self nextPrecedence}".
          precedence < self nextPrecedence }
        whileTrue: { -- Debug println: " -> go".
                     expr = self parseSuffixOf: expr }.
        -- Debug println: " -> no".
        expr!

    method parseSuffixOf: prefix
        self nextToken parseAsSuffixOf: prefix with: self!

    method nextPrecedence
        self lookahead precedence!

    method lookahead
        lookahead
            ifEmpty: { lookahead push: self scanNext }.
        lookahead first!

    method nextToken
        lookahead isEmpty
            ifTrue: { self scanNext }
            ifFalse: { lookahead pop }!

    method scanNext
        self skipWhitespace.
        self atEof
            ifTrue: { return TokenEof at: position in: self }.
        self atSpecial
            ifTrue: { return self scanSpecial }.
        self atDigit
            ifTrue: { return self scanDecimal }.
        self atDoublequote
            ifTrue: { return self scanString }.
        self atSigil
            ifTrue: { return self scanSigil }.
        self atWord
            ifTrue: { return self scanWord }.
        Error raise: "Don't know how to scan pos: {position} in: {source}"!

    method atEof
        self atEof: position!

    method atEof: position
        position > last!

    method atSpecial
        self isAt: { |char|
                     SpecialCharacters
                         anySatisfy: { |special| special == char } }!

    method atDigit
        self isAt: #isDigit!

    method atDoublequote
        self isAt: { |char| char == DoublequoteCharacter }!

    method atWord
        self isAt: { |char|
                     char isAlphanumeric or: char == UnderscoreCharacter }!

    method atTerminating
        self atSpecial or: self atWhitespace!

    method atNewline
        self isAt: #isNewline!

    method atHorizontalWhitespace
        self isAt: #isHorizontalWhitespace!

    method atSigil
        self atEof not
            ifTrue: { (self atWord or: self atTerminating) not }!

    method atWhitespace
        self isAt: #isWhitespace!

    method atChar: char1 notFollowedBy: char2
        self atEof
            ifTrue: { return False }.
        (source at: position) == char1
            ifFalse: { return False }.
        (position + 1 > last)
            ifFalse: { ((source at: position + 1) == char2) not }!

    method afterEscape
        self atEscape: position - 1!

    method atEscape: position
        (self atEof: position)
            ifTrue: { return False }.
        (position >= first)
            ifTrue: { (source at: position) == EscapeCharacter }!

    method isAt: block
        self atEof
            ifTrue: { False }
            ifFalse: { block value: (source at: position) }!

    method skipWhile: test
        -- Debug println: "/skipWhile: {test}".
        let start = position.
        test whileTrue: { self advance }.
        position - 1!

    method skipWhitespace
        self skipWhile: { self atWhitespace }!

    method scanSpecial
        -- Debug println: "/scanSpecial".
        let start = position.
        self advance.
        TokenSigil
            from: start
            to: start
            in: self!

    method scanDecimal
        -- Debug println: "/scanDecimal".
        TokenDecimal
            from: position
            to: (self skipWhile: { self atDigit })
            in: self!

    method scanString
        -- Debug println: "/scanString".
        self advance.
        let string = TokenString
                         from: position
                         to: (self skipWhile: { self atDoublequote not or: self afterEscape })
                         in: self.
        self advance.
        string!

    method scanSigil
        -- Debug println: "/scanSigil".
        TokenSigil
            from: position
            to: (self skipWhile: { self atSigil })
            in: self!

    method scanWord
        -- Debug println: "/scanWord".
        let first = position.
        self skipWhile: { self atWord }.
        (self atChar: ColonCharacter notFollowedBy: ColonCharacter)
            ifTrue: { self advance.
                      TokenKeyword
                          from: first
                          to: position - 1
                          in: self }
            ifFalse: { TokenWord
                           from: first
                           to: position - 1
                           in: self }!

    method advance
        position <= last
            ifFalse: { panic "Tried to advance beyond end: \"{source}\"" }.
        position = position + 1!

end
