import .source.*
import .syntax.*
import .utils.Debug

interface Token
    is Object

    direct method from: first to: last in: parser
        self
            string: (parser source from: first to: last)
            first: first last: last!

    method precedence
        -1!

    method parseAsSuffixOf: prefix with: parser
        let note = "Cannot parse".
        Error raise: "{note}: '{self string}' in suffix position {parser syntaxTable where}:
{(parser sourceFrom: self first to: self last) note: note}"!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let note = "Cannot parse".
        Error raise: "{note} '{self string}' in prefix position {parser syntaxTable where}:
{(parser sourceFrom: self first to: self last) note: note}"!

    method toString
        "#<{self classOf name} \"{self string}\" @ {self first}>"!

    method parseAsVariableWith: parser
        let source = SourceString string: parser source first: self first last: self last.
        Error raise: "Invalid variable in self-hosted parser: {self string} ({self classOf name})
{source}"!

    required method string
    required method first
end

define StringEscapes
    {
         "n" -> "\n",
         "r" -> "\r",
         "t" -> "\t",
         "\\" -> "\\",
         "\"" -> "\"",
         "\{" -> "\{",
         "\}" -> "\}"
    }!

class TokenString { string first last }
    is Token

    method _escapeChar: char
        StringEscapes
            at: char
            ifNone: { panic "Unknown escape character: {char}" }!

    method _scanCharFrom: next into: literal
        let char = string from: next to: next.
        next = next + 1.
        char == "\\"
            ifTrue: { literal print: (self _escapeChar: (string from: next to: next)).
                      next = next + 1 }
            ifFalse: { literal print: char }.
        next!

    method _isInterpolationStart: next
        "\{" == (string from: next to: next)!

    method _literalFrom: next into: parts
        let literal = StringOutput new.
        let from = next.

        { next < string size
              ifTrue: { (self _isInterpolationStart: next) not } }
        whileTrue: { next = self _scanCharFrom: next into: literal }.

        from is next
            ifFalse: { parts add: (SyntaxLiteral value: literal content) }.
        next!

    method _interpolatedFrom: next into: parts
        (next < string size)
            ifFalse: { return next }.
        (self _isInterpolationStart: next) not
            ifTrue: { return next }.
        let source = string from: next to: string size.
        let exprParser = Parser expressionParser: source.
        parts add: exprParser parsePrefix.
        next + exprParser position - 1!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        -- Debug println: "parse string: '{string}'".
        string size is 2 -- just ""
            ifTrue: { return SyntaxLiteral value: "" }.
        let parts = List new.
        let next = 2.
        { next < string size }
            whileTrue: { next = self _literalFrom: next into: parts.
                         next = self _interpolatedFrom: next into: parts }.
        (parts size is 1 and: (SyntaxLiteral includes: parts first))
            ifTrue: { return parts first }.
        SyntaxStringInterpolation
            parts: parts!
end

class TokenFloat { string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxFloatLiteral
            string: string
            value: (Float parse: string)!
end

class TokenDecimalInteger { string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        -- Debug println: self.
        (first <= last) assert.
        let n = 0.
        1 to: string size
          do: { |pos|
                n = n * 10 + (string at: pos) digit }.
        SyntaxLiteral value: n!
end

class TokenHexInteger { string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        -- Debug println: self.
        (first <= last + 3) assert.
        let n = 0.
        3 to: string size
          do: { |pos|
                n = n * 16 + ((string at: pos) digit: 16) }.
        -- Want to retain the format info, hence not SyntaxLiteral.
        SyntaxHexLiteral value: n!
end

class TokenBinaryInteger { string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        -- Debug println: self.
        (first <= last + 3) assert.
        let n = 0.
        3 to: string size
          do: { |pos|
                n = n * 2 + ((string at: pos) digit: 2) }.
        -- Want to retain the format info, hence not SyntaxLiteral.
        SyntaxBinaryLiteral value: n!
end

class TokenEof { position }
    is Token

    direct method at: position in: parser
        self position: position!

    method precedence
        0!

    method string
        "EOF"!

    method first
        position!

    method last
        position!
end

-- For CoreSyntaxTable --

class InvalidToken { precedence string first last }
    is Token
end

interface TokenComment

    direct method from: first to: last in: parser
        last - first < 2
            ifTrue: { LineCommentToken
                          string: (parser from: first to: last)
                          first: first
                          last: last }
            ifFalse: { BlockCommentToken
                           string: (parser from: first to: last)
                           first: first
                           last: last }!
end

class LineCommentToken { string first last }
    is Token

    method precedence
        MaxPrecedence!

    ---
    See also: special handlings in SequenceToken and LetToken to parse

        foo bar. -- comment
        quux zot

        let x = foo bar. -- comment
        quux zot

    as suffix comments on `foo bar`.
    ---

    method parseAsPrefixWith: parser atPrecedence: precedence
        -- NOTE: must continue at same precedence! Consider eg.
        --
        --    let x = -- comment
        --            -42 abs.
        --    123
        --
        -- where the comment is reached while parsing at SingleExpressionPrecedence,
        -- versus:
        --
        --    foo bar.
        --    -- comment
        --    bar quux
        --
        -- where the comment is reached while parsing at SeqPrecedence!
        let comment = parser readline.
        (parser parseAtPrecedence: precedence)
            withPrefixComment: comment
            commentSource: (parser sourceFrom: first to: last)!

    method parseAsSuffixOf: prefix with: parser
        prefix
            withSuffixComment: parser readline
            commentSource: (parser sourceFrom: first to: last)!
end

class BlockCommentToken { string first last }
    is Token

    method precedence
        MinPrecedence!

    method parseAsPrefixWith: parser atPrecedence: precedence
        let endFence = parser find: string.
        let expr = (parser parseAtPrecedence: precedence).
        let origLines = (parser from: last + 1 to: endFence) lines.
        -- Block comments on one line don't get trimmed.
        let lines = origLines size > 1
                        ifTrue: { origLines collect: #trimRight }
                        ifFalse: { origLines }.
        expr
            withBlockComment: lines
            fence: string
            commentSource: (parser sourceFrom: last + 1 to: endFence)!

end

-- For ExpressionSyntaxTable --

class SequenceToken { precedence string first last }
    is Token
    ---
    Special casing for end of line comments after dot to
    make the following a _suffix_ comment on `foo bar`:

        foo bar. -- comment
        quux zot

    The human expectation trumps consistency here.
    ---

    method parseAsSuffixOf: prefix with: parser
        SyntaxSeq
            first: (parser handleSuffixCommentOf: prefix)
            then: parser parseSeq!
end

class AssignmentToken { precedence string first last }
    is Token

    method parseAsSuffixOf: prefix with: parser
        SyntaxAssign
            variable: prefix::SyntaxVariable
            value: parser parseSingle!
end

class OpenBraceToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        -- Record?
        (TokenKeyword includes: parser lookahead)
            ifTrue: { return self _parseAsRecordWith: parser }.

        -- Block OR Dictionary

        -- Block with parameters
        parser when: "|"
               do: { return self _parseAsBlockWith: parser }.

        -- Block with return type and no parameters
        parser when: "->"
               do: { return self _parseAsBlockWith: parser }.

        -- Could be either { expr... } OR { expr -> expr, ... }
        let expr = parser parseSeq.
        parser when: "->"
               do: { -- Dictionary
                     return self
                         _parseAsDictionaryWith: parser
                         _firstKey: expr }.
        self
            _finishBlockWith: parser
            _parameters: []
            _returnType: Any
            _body: expr!

    method _parseAsRecordWith: parser
        let entries = List new.
        parser
            until: "}"
            do: { let key = parser nextToken.
                  (TokenKeyword includes: key)
                      ifFalse: { Error raise: "Expected keyword in record, got: {key}" }.
                  entries add: { key: key string,
                                 value: parser parse }.
                  parser unless: "}"
                         do: { parser expect: "," } }.
        parser expect: "}".
        SyntaxRecord
            entries: entries asArray!

    method _parseAsDictionaryWith: parser _firstKey: keyExpr
        parser expect: "->".
        let entries = List with: { key: keyExpr,
                                   value: parser parseSeq }.
        parser unless: ","
               do: { parser expect: "}".
                     return SyntaxDictionary entries: entries }.
        parser expect: ",".
        parser until: "}"
               do: { entries add: { key: parser parseSeq,
                                    value: (parser expect: "->".
                                            parser parseSeq) }.
                     parser unless: "}"
                            do: { parser expect: "," } }.
        parser expect: "}".
        SyntaxDictionary
            entries: entries!

    method _finishBlockWith: parser
           _parameters: parameters
           _returnType: returnType
           _body: body
        parser expect: "}".
        SyntaxBlock
            parameters: parameters
            returnType: returnType
            body: body!

    method _parseAsBlockWith: parser
        let parameters = List new.
        parser
            when: "|"
            do: { parser nextToken.
                  parser until: "|"
                         do: { parameters add: (parser parseVariable) }.
                  parser nextToken }.
        let returnType = Any.
        parser
            when: "->"
            do: { parser nextToken.
                  returnType = parser parsePrefix }.
        self
            _finishBlockWith: parser
            _parameters: parameters
            _returnType: returnType
            _body: parser parseSeq!
end

class ArrayStartToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let entries = List new.
        -- Optional leading comma
        parser when: ","
               do: { parser nextToken }.
        parser until: "]"
               do: { entries add: parser parse.
                     -- Allow trailing comma
                     parser unless: "]"
                            do: { parser expect: "," } }.
        parser expect: "]".
        SyntaxArray
            entries: entries!
end

class OpenParenToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let body = parser parseSeq.
        parser expect: ")".
        SyntaxParens body: body!
end

class IsSuffixToken { precedence string first last }
    is Token

    method parseAsSuffixOf: prefix with: parser
        SyntaxIs
            left: prefix
            right: (parser parseAtPrecedence: precedence)!
end

class LetToken { precedence string first last }
    is Token

    ---
    Special casing for end of line comments after dot to
    make the following a _suffix_ comment on `foo bar`:

        let x = foo bar. -- comment
        quux zot

    The human expectation trumps consistency here.
    ---

    method parseAsPrefixWith: parser atPrecedence: _precedence
        -- Debug println: "LetToken#parseAsPrefix:atPrecedence".
        let variable = parser parseVariable.
        parser expect: "=".
        let value = parser parseSingle.
        parser expect: ".".
        SyntaxLet
            variable: variable
            value: (parser handleSuffixCommentOf: value)
            body: parser parseSeq!
end

class TypeDeclarationToken { precedence string first last }
    is Token

    method parseAsSuffixOf: prefix with: parser
        SyntaxValueTypeDeclaration
            value: prefix
            type: (parser parsePrefix)!
end

class DynamicVariableToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let name = parser parseName: "a dynamic variable".
        SyntaxDynamicVariable
            name: "${name}"
            source: (parser sourceFrom: first to: parser position - 1)!

    method parseAsVariableWith: parser
        self parseAsPrefixWith: parser atPrecedence: precedence!
end

class SelfInstanceToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxSelfInstance new!
end

class SelfClassToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxSelfClass new!
end

class LiteralToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        parser nextToken parseAsLiteralWith: parser!
end

class PanicToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxPanic
            value: parser parseSingle!
end

class ReturnToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxReturn
            value: parser parseSingle!
end

-- For ToplevelSyntaxTable --

class ClassToken { precedence string first last }
    is Token

    method parseNewclass: name with: parser
        let slots = List new.
        parser expect: "\{".
        parser until: "}"
               do: { slots add: parser parseVariable }.
        parser expect: "}".
        SyntaxClass name: name slots: slots!

    method parseSubclass: name with: parser
        let super = parser parseVariable.
        SyntaxClass name: name inherits: super!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let name = parser parseName: "a class".
        let theClass = parser
                           when: "<"
                           do: { parser nextToken.
                                 self parseSubclass: name with: parser }
                           else: { self parseNewclass: name with: parser }.
        parser withSyntaxTable: ClassSyntaxTable
               do: { parser
                         until: "end"
                         do: { theClass
                                   add: (parser parseAtPrecedence: precedence) }.
                     parser
                         expect: "end" }.
        parser handleSuffixCommentOf: theClass!
end

class DefineToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        -- Debug println: "DefineToken#parseAsPrefixWith: ...".
        parser withSyntaxTable: ExpressionSyntaxTable
               do: { let def = SyntaxDefine
                                   variable: parser parseVariable
                                   body: parser parseSeq.
                     parser
                         expect: "!".
                     def }!
end

class InterfaceToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let theInterface = SyntaxInterface name: (parser parseName: "an interface").
        parser withSyntaxTable: InterfaceSyntaxTable
               do: { parser
                         until: "end"
                         do: { theInterface
                                   add: (parser parseAtPrecedence: precedence) }.
                     parser
                         expect: "end" }.
        parser handleSuffixCommentOf: theInterface!
end

class ExtendToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let theExtend = SyntaxExtend name: (parser parseName: "an extension").
        parser withSyntaxTable: ExtendSyntaxTable
               do: { parser
                         until: "end"
                         do: { theExtend
                                   add: (parser parseAtPrecedence: precedence) }.
                     parser
                         expect: "end" }.
        parser handleSuffixCommentOf: theExtend!
end

-- For ClassSyntaxTable and InterfaceSyntaxTable --

class IsPrefixToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let name = parser parsePrefixAtPrecedence: precedence.
        SyntaxInterfaceRef name: name!
end

interface MethodToken
    is Token

    method parseRequiredWith: parser as: methodClass
        parser withSyntaxTable: ExpressionSyntaxTable
               do: { let signature = self _parseMethodSignatureWith: parser.
                     let theMethod = methodClass
                                         signature: signature
                                         body: False.
                     parser handleSuffixCommentOf: theMethod }!

    method parseMethodWith: parser as: methodClass
        -- Debug println: "MethodToken#parseMethodWith: ...".
        parser withSyntaxTable: ExpressionSyntaxTable
               do: { let signature = self _parseMethodSignatureWith: parser.
                     -- Debug println: "\n- method {signature selector}, {signature parameters}, {methodClass} -> {signature returnType}".
                     -- Debug println: "lookahead: {bodyParser lookahead string}".
                     let body = parser parseSeq.
                     -- Debug println: "body: {body}".
                     parser expect: "!".
                     body = parser handleSuffixCommentOf: body.
                     methodClass
                         signature: signature
                         body: body }!

    method _parseMethodSignatureWith: parser
        let selector = StringOutput new.
        let parameters = List new.
        let returnType = parser nextToken
            parseAsMethodSignatureWith: parser
            selector: selector
            parameters: parameters.
        MethodSignature
            selector: (Selector new: selector content)
            parameters: parameters
            returnType: returnType!
end

class InstanceMethodToken { precedence string first last }
    is MethodToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        self
            parseMethodWith: parser
            as: SyntaxInstanceMethod!
end

class DirectMethodToken { precedence string first last }
    is MethodToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        parser expect: "method".
        self
            parseMethodWith: parser
            as: SyntaxDirectMethod!
end

class RequiredMethodToken { precedence string first last }
    is MethodToken
    method parseAsPrefixWith: parser atPrecedence: _precedence
        parser when: "method"
               do: { parser expect: "method".
                     return self
                         parseRequiredWith: parser
                         as: SyntaxInstanceMethod }.
        parser when: "direct"
               do: { parser expect: "direct".
                     parser expect: "method".
                     return self
                         parseRequiredWith: parser
                         as: SyntaxDirectMethod }.
        Error raise: "Syntax error, expected 'method' or 'direct method' after 'required'."!
end

class BangToken { precedence string first last }
    is Token
end

class ImportToken { precedence string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        parser skipWhitespace.
        let specFirst = parser position.
        let specLast = parser skipWhile: { parser atWhitespace not }.
        let spec = parser from: specFirst to: specLast.
        let parts = spec splitBy: DotCharacter.
        let relative = parts first == ""
                           ifTrue: { parts popFirst.
                                     True }.
        let body = parser parseDefinitions.
        -- FIXME: Syntax change imminent
        parts last first isLowercase
            ifTrue: { return SyntaxModuleImport
                          module: parts
                          relative: relative
                          body: body }.
        let name = parts last.
        name == "*"
            ifTrue: { return SyntaxWildcardImport
                          module: parts butlast
                          relative: relative
                          body: body }.
        SyntaxNameImport
            name: name
            module: parts butlast
            relative: relative
            body: body!
end

class SyntaxTable { where tokens }
    is Object

    method where: newWhere tokens: newTokens
        SyntaxTable
            where: newWhere
            tokens: (tokens copy merge: newTokens)!

end

-- FIXME: call it binding power, it's more accurate
class SyntaxEntry { tokenClass precedence }
    is Object
end

class SigilEntry { precedence }
    is Object
    method tokenClass
        TokenSigil!
end

define MinPrecedence
    0!

define SeqPrecedence
    1!

define SingleExpressionPrecedence
    2! -- dot has precedence 2

define KeywordPrecedence
    9!

define UnknownOperatorPrecedence
    10!

define MaxPrecedence
    1000!

define CoreSyntaxTable
    SyntaxTable
    where: "anywhere"
    tokens:
    {
         "}" -> SyntaxEntry tokenClass: InvalidToken precedence: 0,
         ")" -> SyntaxEntry tokenClass: InvalidToken precedence: 0,
         "]" -> SyntaxEntry tokenClass: InvalidToken precedence: 0,
         "," -> SyntaxEntry tokenClass: InvalidToken precedence: 0,
         "->" -> SyntaxEntry tokenClass: InvalidToken precedence: 0
    }!

define ExpressionSyntaxTable
    CoreSyntaxTable
    where: "in an expression"
    tokens:
    {
         "panic" -> SyntaxEntry tokenClass: PanicToken precedence: 1000,
         "return" -> SyntaxEntry tokenClass: ReturnToken precedence: 1000,
         "self" -> SyntaxEntry tokenClass: SelfInstanceToken precedence: 1000,
         "Self" -> SyntaxEntry tokenClass: SelfClassToken precedence: 1000,
         "#" -> SyntaxEntry tokenClass: LiteralToken precedence: 1000,
         "::" -> SyntaxEntry tokenClass: TypeDeclarationToken precedence: 1000,
         "$" -> SyntaxEntry tokenClass: DynamicVariableToken precedence: 1000,
         "*" -> SigilEntry precedence: 90,
         "/" -> SigilEntry precedence: 90,
         "+" -> SigilEntry precedence: 80,
         "-" -> SigilEntry precedence: 80,
         "is" -> SyntaxEntry tokenClass: IsSuffixToken precedence: 10,
         "let" -> SyntaxEntry tokenClass: LetToken precedence: 3,
         -- Why precedence 3 for these?
         "\{" -> SyntaxEntry tokenClass: OpenBraceToken precedence: 3,
         "[" -> SyntaxEntry tokenClass: ArrayStartToken precedence: 3,
         "(" -> SyntaxEntry tokenClass: OpenParenToken precedence: 3,
         "=" -> SyntaxEntry tokenClass: AssignmentToken precedence: 2,
         "." -> SyntaxEntry tokenClass: SequenceToken precedence: 2,
         "!" -> SyntaxEntry tokenClass: BangToken precedence: 1
    }!

define ToplevelSyntaxTable
    CoreSyntaxTable
    where: "at toplevel"
    tokens:
    {
         "import" -> SyntaxEntry tokenClass: ImportToken precedence: 1000,
         "define" -> SyntaxEntry tokenClass: DefineToken precedence: 1000,
         "class" -> SyntaxEntry tokenClass: ClassToken precedence: 1000,
         "interface" -> SyntaxEntry tokenClass: InterfaceToken precedence: 1000,
         "extend" -> SyntaxEntry tokenClass: ExtendToken precedence: 1000
    }!

define MixedSyntaxTable
    ExpressionSyntaxTable
    where: "here"
    tokens: ToplevelSyntaxTable tokens!

define ClassSyntaxTable
    CoreSyntaxTable
    where: "in a class"
    tokens:
    {
         "is" -> SyntaxEntry tokenClass: IsPrefixToken precedence: 1000,
         "method" -> SyntaxEntry tokenClass: InstanceMethodToken precedence: 1000,
         "direct" -> SyntaxEntry tokenClass: DirectMethodToken precedence: 1000
    }!

define InterfaceSyntaxTable
    ClassSyntaxTable
    where: "in an interface"
    tokens:
    {
         "required" -> SyntaxEntry tokenClass: RequiredMethodToken precedence: 1000
    }!

-- Currently same as ClassSyntaxTable, but may diverge.
define ExtendSyntaxTable
    ClassSyntaxTable
    where: "in an extend"
    tokens: Dictionary new!

interface LookupToken
    is Token

    -- FIXME: Current host doesn't support required direct methods
    -- required direct method tokenClassIn: table
    direct method from: first to: last in: parser
        let tokenString = parser from: first to: last.
        -- Figure out the correct tokenclass using current syntax.
        let entry = parser syntaxTable tokens
                        at: tokenString
                        ifNone: { SyntaxEntry
                                      tokenClass: self
                                      precedence: (self defaultPrecedence) }.
        -- Debug println: "token '{tokenString}' --> {entry tokenClass name}".
        entry tokenClass
            precedence: entry precedence
            string: tokenString
            first: first
            last: last!
end

class TokenSigil { precedence string first last }
    is LookupToken

    direct method defaultPrecedence
        UnknownOperatorPrecedence!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxPrefix
            receiver: (parser parseAtPrecedence: MaxPrecedence)
            selector: (Selector name: string)
            source: (parser sourceFrom: first to: last)!

    method parseAsSuffixOf: prefix with: parser
        SyntaxBinary
            receiver: prefix
            selector: (Selector name: string)
            argument: (parser parseAtPrecedence: precedence)
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        -- Debug println: "TokenSigil#parseAsMethodSignatureWith:selector:parameters:".
        selector print: string.
        parameters add: parser parseVariable.
        parser when: "->"
               do: { parser expect: "->".
                     return parser parsePrefix }.
        Any!

    method parseAsLiteralWith: parser
        SyntaxLiteral
            value: (Selector new: string)!

end

class TokenWord { precedence string first last }
    is LookupToken

    direct method defaultPrecedence
        MaxPrecedence!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        (parser atChar: DotCharacter andThenNot: #isWhitespace)
            ifTrue: { parser advance.
                      let nameFirst = parser position.
                      let nameLast = parser
                                         skipWhile: { (parser atWhitespace
                                                           or: (parser atChar: BangCharacter))
                                                      not }.
                      let parts = (parser from: first to: nameLast)
                                      splitBy: DotCharacter.
                      (parts size is 2) assert.
                      let ref = SyntaxExternalRef
                          module: parts first
                          name: parts second
                          source: (parser sourceFrom: first to: nameLast).
                      return ref }.
        SyntaxVariable
            name: string
            source: (parser sourceFrom: first to: last)!

    method parseAsVariableWith: parser
        parser when: "::"
               do: { parser nextToken.
                     return SyntaxTypedVariable
                         name: string
                         type: parser parsePrefix }.
        SyntaxVariable
            name: string
            source: (parser sourceFrom: first to: last)!

    method parseAsSuffixOf: prefix with: parser
        SyntaxUnary
            receiver: prefix
            selector: (Selector name: string)
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        -- Debug println: "TokenWord#parseAsMethodSignatureWith:selector:parameters:".
        selector print: string.
        string == "prefix"
            ifTrue: { let op = parser nextToken.
                      (TokenSigil includes: op)
                          ifFalse: { Error raise: "Expected prefix sigil, got: {op string}" }.
                      selector print: op string }.
        parser when: "->"
               do:{ parser expect: "->".
                    return parser parsePrefix }.
        Any!

    method parseAsLiteralWith: parser
        SyntaxLiteral
            value: (Selector new: string)!
end

class TokenKeyword { string first last }
    is Token

    direct method from: first to: last in: parser
        self string: (parser source from: first to: last)
             first: first
             last: last!

    method precedence
        KeywordPrecedence!

    method parseAsSuffixOf: prefix with: parser
        let arguments = List new.
        let selector = StringOutput new: string.
        { arguments push: (parser parseAtPrecedence: self precedence).
          let token = parser lookahead.
          (TokenKeyword includes: token)
              ifTrue: { parser nextToken.
                        selector print: token string.
                        True } }
        whileTrue.
        SyntaxKeyword
            receiver: prefix
            selector: (Selector name: selector content)
            arguments: arguments
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        -- Debug println: "TokenKeyord#parseAsMethodSignatureWith:selector:parameters:".
        selector print: string.
        parameters add: parser parseVariable.
        (TokenKeyword includes: parser lookahead)
            ifTrue: { return parser nextToken
                          parseAsMethodSignatureWith: parser
                          selector: selector
                          parameters: parameters }.
        parser when: "->"
               do: { parser expect: "->".
                     return parser parsePrefix }.
        Any!

    method parseAsLiteralWith: parser
        let selector = StringOutput new: string.
        { TokenKeyword includes: parser lookahead }
            whileTrue: { selector print: parser nextToken string }.
        SyntaxLiteral
            value: (Selector new: selector content)!
end

define SpecialCharacters
    ["(" character,
     ")" character,
     "[" character,
     "]" character,
     "\{" character,
     "}" character,
     "!" character,
     "." character,
     ";" character,
     "#" character,
     "," character]!

define UnderscoreCharacter
    "_" character!

define DoublequoteCharacter
    "\"" character!

define EscapeCharacter
    "\\" character!

define ColonCharacter
    ":" character!

define DashCharacter
    "-" character!

define DotCharacter
    "." character!

define DollarCharacter
    "$" character!

define BangCharacter
    "!" character!

-- FIXME: Broken for unicode input!
class Parser { source::String
               _position::Integer
               first::Integer
               last::Integer
               stack::List
               syntaxTable }
    is Object

    method position
        _position!

    method position: pos
        _position = pos!

    method toString
        "#<Parser position: {self position}>"!

    direct method _new: source syntaxTable: syntaxTable
        source
            ifEmpty: { Error raise: "Cannot parse empty string!" }.
        self
            source: source
            _position: 1
            first: 1
            last: (source size)
            stack: List new
            syntaxTable: syntaxTable!

    method withSyntaxTable: newSyntaxTable do: block
        -- You know what would be nice: dynamically bound instance variables.
        let prevTable = syntaxTable.
        syntaxTable = newSyntaxTable.
        self _clearLookahead.
        block
            finally: { syntaxTable = prevTable.
                       self _clearLookahead }!

    direct method expressionParser: source
        self _new: source syntaxTable: ExpressionSyntaxTable!

    direct method definitionParser: source
        self _new: source syntaxTable: ToplevelSyntaxTable!

    direct method parseExpressions: source
        -- Debug println: "#parseExpressions: ...".
        (self expressionParser: source)
            _parseAll: #parse!

    direct method parseDefinitions: source
        (self definitionParser: source)
            parseDefinitions!

    direct method parseMixed: source
        (self _new: source syntaxTable: MixedSyntaxTable)
            _parseAll: #parse! -- wwwhhhhaaaaa

    method parseDefinitions
        self _parseAll: #parsePrefix!

    method _parseAll: selector
        let syntax = List new.
        { self skipWhitespace.
          self atEof }
        whileFalse: { syntax add: (selector sendTo: self) }.
        -- syntax do: { |s| Debug println: "=> {s}" }.
        syntax!

    method parse
        self parseAtPrecedence: MinPrecedence!

    method parseSingle
        self parseAtPrecedence: SingleExpressionPrecedence!

    method parseSeq
        self parseAtPrecedence: SeqPrecedence!

    method parsePrefix
        self parsePrefixAtPrecedence: MaxPrecedence!

    method parseVariable
        self nextToken parseAsVariableWith: self!

    method parseName: context
        self nextToken string!

    method handleSuffixCommentOf: prefix
        -- #sees: means without intervening newline!
        (self sees: "--")
            ifTrue: { self nextToken
                          parseAsSuffixOf: prefix
                          with: self }
            ifFalse: { prefix }!

    method readline
        let start = self position.
        { self atEof or: self atNewline }
            whileFalse: { self advance }.
        let stop = self position - 1.
        self atEof
            ifFalse: { self advance }.
        source from: start to: stop!

    method from: first to: last
        source from: first to: last!

    method sourceFrom: first to: last
        SourceString string: source first: first last: last!

    method expect: expected
        let token = self nextToken.
        let got = token string.
        got == expected
            ifFalse: { Error raise: "Expected '{expected}', got '{got}' {syntaxTable where} (self-hosted parser)
{SourceString string: source first: token first last: token last}" }!

    method sees: test
        -- Cannot use lookahead since that would skip newlines!
        self skipWhile: { self atHorizontalWhitespace }.
        let last = (self position + test size - 1) min: source size.
        test == (source from: self position to: last)!

    method when: test do: action
        self when: test
             do: action
             else: { False }!

    method when: test do: action else: otherAction
        self lookahead string == test
            ifTrue: action
            ifFalse: otherAction!

    method unless: test do: action
        self lookahead string == test
            ifFalse: { action value }!

    method until: test do: action
        { self lookahead string == test }
            whileFalse: action!

    method parseAtPrecedence: precedence
        self
            parseSuffixOf: (self parsePrefixAtPrecedence: precedence)
            with: precedence!

    method parsePrefixAtPrecedence: precedence
        self nextToken parseAsPrefixWith: self atPrecedence: precedence!

    method parseSuffixOf: prefix with: precedence
        let expr = prefix.
        { -- Debug println: "expr: {expr displayString}, precedence={precedence}, next={self lookahead}?, nextPrecedence={self nextPrecedence} in: {syntaxTable where}".
          precedence < self nextPrecedence }
        whileTrue: { -- Debug println: " -> go".
                     expr = self parseSuffixOf: expr }.
        -- Debug println: " -> no".
        expr!

    method parseSuffixOf: prefix
        self nextToken parseAsSuffixOf: prefix with: self!

    method nextPrecedence
        self lookahead precedence!

    method lookahead
        stack
            ifEmpty: { stack push: self _scanNext }.
        stack first!

    method _clearLookahead
        stack
            ifNotEmpty: { self position: stack first first.
                          stack clear }!

    method nextToken
        stack isEmpty
            ifTrue: { self _scanNext }
            ifFalse: { stack pop }!

    method _scanNext
        self skipWhitespace.
        self atEof
            ifTrue: { return TokenEof at: self position in: self }.
        self atSpecial
            ifTrue: { return self _scanSpecial }.
        self atDigit
            ifTrue: { return self _scanNumber }.
        self atDoublequote
            ifTrue: { return self _scanString }.
        self atComment
            ifTrue: { return self _scanComment }.
        self atSigil
            ifTrue: { return self _scanSigil }.
        self atWord
            ifTrue: { return self _scanWord }.
        Error raise: "Don't know how to scan pos: {self position} in: {source}"!

    method atEof
        self atEof: self position!

    method atEof: position
        position > last!

    method atSpecial
        self isAt: { |char|
                     SpecialCharacters
                         anySatisfy: { |special| special == char } }!

    method atDigit
        self isAt: #isDigit!

    method atDoublequote
        self isAt: { |char| char == DoublequoteCharacter }!

    method atComment
        self atChar: DashCharacter and: DashCharacter!

    method _scanComment
        -- Debug println: "Parser#_scanComment".
        TokenComment
            from: self position
            to: (self skipWhile: { self atChar: DashCharacter })
            in: self!

    method find: aString
        let start = self position.
        { aString
              allSatisfy: { |s|
                            self atEof
                                ifTrue: { Error raise: "End of file while waiting for {aString}" }.
                            (self atChar: s character)
                                ifTrue: { self advance.
                                          True } } }
        whileFalse: { start = self position: start + 1 }.
        start - 1!

    method atWord
        self isAt: { |char|
                     char isAlphanumeric or: char == UnderscoreCharacter }!

    method atTerminating
        self atSpecial or: self atWhitespace!

    method atNewline
        self isAt: #isNewline!

    method atHorizontalWhitespace
        self isAt: #isHorizontalWhitespace!

    method atSigil
        self atEof not
            ifTrue: { (self atWord or: self atTerminating) not }!

    method atWhitespace
        self isAt: #isWhitespace!

    method atChar: char
        self atEof
            ifTrue: { return False }.
        (source at: self position) == char!

    method atChar: char1 or: char2
        self atEof
            ifTrue: { return False }.
        let here = (source at: self position).
        here == char1 or: here == char2!

    method atChar: char1 and: char2
        self atEof
            ifTrue: { return False }.
        (source at: self position) == char1
            ifFalse: { return False }.
        (self position + 1 > last)
            ifFalse: { ((source at: self position + 1) == char2) }!

    method atChar: char1 notFollowedBy: char2
        self atEof
            ifTrue: { return False }.
        (source at: self position) == char1
            ifFalse: { return False }.
        (self position + 1 > last)
            ifFalse: { ((source at: self position + 1) == char2) not }!

    method atChar: char1 andThen: test
        self atEof
            ifTrue: { return False }.
        (source at: self position) == char1
            ifFalse: { return False }.
        (self position + 1 > last)
            ifFalse: { (test value: (source at: self position + 1)) }!

    method atChar: char1 andThenNot: testNot
        self atChar: char1 andThen: { |char| (testNot value: char) not }!

    method atAnyOf: string
        self atEof
            ifTrue: { return False }.
        1 to: string size
          do: { |index|
                (self atChar: (string at: index))
                    ifTrue: { return True } }.
        False!

    method atEscape
        (self atEof: self position)
            ifTrue: { return False }.
        (self position >= first)
            ifTrue: { (source at: self position) == EscapeCharacter }!

    method isAt: block
        self atEof
            ifTrue: { False }
            ifFalse: { block value: (source at: self position) }!

    method skipWhile: test
        -- Debug println: "/skipWhile: {test}".
        let start = self position.
        test whileTrue: { self advance }.
        self position - 1!

    method skipWhitespace
        self skipWhile: { self atWhitespace }!

    method _scanSpecial
        -- Debug println: "/scanSpecial".
        let start = self position.
        self advance.
        TokenSigil
            from: start
            to: start
            in: self!

    method _scanNumber
        -- Debug println: "/scanNumber".
        let start = self position.
        self advance.
        (self atChar: "x" character or: "X" character)
            ifTrue: { self advance.
                      return TokenHexInteger
                          from: start
                          to: (self skipWhile: { self atWord })
                          in: self }.
        (self atChar: "b" character or: "B" character)
            ifTrue: { self advance.
                      return TokenBinaryInteger
                          from: start
                          to: (self skipWhile: { self atWord })
                          in: self }.
        let integerEnd = self skipWhile: { self atDigit }.
        let isFloat
            = (self atChar: DotCharacter andThenNot: #isWhitespace)
                ifTrue: { self advance.
                          self skipWhile: { self atDigit }.
                          True }.
        isFloat = (self atAnyOf: "eE")
                  ifTrue: { self advance.
                            (self atAnyOf: "-+")
                                ifTrue: { self advance }.
                            self skipWhile: { self atWord }.
                            True }
                  ifFalse: { isFloat }.
        isFloat
            ifTrue: { TokenFloat
                          from: start
                          to: (self position - 1)
                          in: self}
            ifFalse: { TokenDecimalInteger
                           from: start
                           to: integerEnd
                           in: self }!

    method _scanString
        -- Debug println: "/scanString".
        let start = self position.
        self advance.
        { self atDoublequote }
            whileFalse: { self atEscape ifTrue: { self advance }.
                          self advance }.
        -- Debug println: "/scanString => |{source from: start to: self position - 1}|".
        let res = TokenString
                      from: start
                      to: self position
                      in: self.
        self advance.
        res!

    method _scanSigil
        TokenSigil
            from: self position
            to: (self skipWhile: { self atSigil })
            in: self!

    method _scanWord
        -- Debug println: "/_scanWord".
        let first = self position.
        self skipWhile: { self atWord }.
        (self atChar: ColonCharacter notFollowedBy: ColonCharacter)
            ifTrue: { self advance.
                      TokenKeyword
                          from: first
                          to: self position - 1
                          in: self }
            ifFalse: { TokenWord
                           from: first
                           to: self position - 1
                           in: self }!

    method advance
        self position <= last
            ifFalse: { panic "Tried to advance beyond end: \"{source}\"" }.
        self position: (self position + 1)!

end
