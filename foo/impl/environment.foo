import .syntaxTranslator.SyntaxTranslator
import .astInterpreter.AstInterpreter
import .utils.Debug
import .ast.AstGlobal
import .ast.AstDynamic
import .ast.AstLexicalRef
import .ast.AstSlotRef
import .ast.AstDefinition
import .parser.Parser

class Builtin { value }
    method eval
        value!
end

class Globals { dictionary }
    direct method new
        self dictionary: Dictionary new!
    method define: builtin
        let name = builtin name.
        dictionary
            put: (AstGlobal name: name definition: (Builtin value: builtin))
            at: name!
end

-- FIXME: cannot differentiate from local definitions!
define Builtins
    Globals new
    ; define: Any
    ; define: Array
    ; define: ByteArray
    ; define: Boolean
    ; define: DoesNotUnderstand
    ; define: Error
    ; define: False
    ; define: Integer
    ; define: List
    ; define: Object
    ; define: Selector
    ; define: String
    ; define: StringOutput
    ; define: True
    ; define: TypeError
    ; dictionary!

class Variable { name type index }
    is Object

    direct method name: name type: type frame: frame
        let var = self name: name type: type index: frame size + 1.
        frame add: var.
        var!

    method referenceUpwards: offset
        AstLexicalRef variable: self frameOffset: offset!
end

class Slot { name index type }
    is Object

    direct method forEachVar: vars
        let n = 0.
        vars collect: { |var|
                        n = n + 1.
                        Slot name: var name index: n type: var type }!

    method referenceUpwards: offset
        AstSlotRef slot: self!
end

class Constant { name value }
    is Object

    method referenceUpwards: _offset
        AstConstantRef value: value!
end

class ModuleDictionary { available translated }
    is Object

    direct method new
        self available: Dictionary new
             translated: Dictionary new!

    direct method new: available
        self available: available
             translated: Dictionary new!

    method at: name relative: relative in: env
        let path = "/" join: name.
        self translated
            at: path
            ifNonePut: { self _translate: name _relative: relative _in: env }!

    method _translate: name _relative: relative _in: env
        let path = "/" join: name.
        let path = relative
                       ifTrue: { "./{path}" }
                       ifFalse: { path }.
        let name = "." join: name.
        let source
            = self available
                at: path
                ifNone: { Error raise: "Unknown module: {name}" }.
        { (Environment
               builtins: env builtins
               modules: self)
          load: source }
            on: Error
            do: { |e|
                  let maybeDot = relative ifTrue: { "." } ifFalse: { "" }.
                  Error raise: "Error loading module {maybeDot}{name}:\n{e description}" }!
end

class ModuleBinding { name module }
    method referenceUpwards: _
        self!
    method global: name
        module global: name!
end

class Environment { parent    -- Enclosing environment or False
                    bindings  -- Variables and slots in this environment
                    frame     -- Variables in this frame
                    depth     -- Number of enclosing frames, including this one
                    globals   -- Dictionary of globals
                    builtins  -- Dictionary of builtins
                    modules } -- ModuleDictionary
    is Object

    direct method new
        self
            builtins: Builtins copy!

    direct method builtins: builtins
        self
            builtins: builtins
            modules: ModuleDictionary new!

    direct method modules: modules
        self
            builtins: Builtins copy
            modules: (ModuleDictionary new: modules)!

    direct method builtins: builtins modules: modules
        Environment
            parent: False
            bindings: []
            frame: List new
            depth: 1
            globals: Dictionary new
            builtins: builtins
            modules: modules!

    method toplevel: bindings
        Environment
            parent: self
            bindings: bindings
            frame: List new
            depth: 1
            globals: globals
            builtins: builtins
            modules: modules!

    method toplevel
        self toplevel: []!

    method newFrame
        Environment
            parent: self
            bindings: []
            frame: List new
            depth: depth + 1
            globals: globals
            builtins: builtins
            modules: modules!

    method augment: bindings
        Environment
            parent: self
            bindings: bindings
            frame: frame
            depth: depth
            globals: globals
            builtins: builtins
            modules: modules!

    method removeBuiltins: names
        builtins removeAll: names!

    method import: moduleName relative: relative
        (self depth is 1) assert.
        let module = modules
                         at: moduleName
                         relative: relative
                         in: self.
        -- Debug println: "import: {moduleName}".
        self toplevel: [ModuleBinding
                            name: moduleName last
                            module: module]!

    method import: name from: moduleName relative: relative
        (self depth is 1) assert.
        let global = (modules at: moduleName relative: relative in: self)
                         global: name.
        self toplevel: [global]!

    method importAll: moduleName relative: relative
        (self depth is 1) assert.
        let module = (modules at: moduleName relative: relative in: self).
        let bindings = List new.
        module globals
            doKeys: { |name|
                      (name startsWith: "_")
                          ifFalse: { bindings add: (module global: name) } }.
        self toplevel: bindings!

    method addVariable: name type: type
        self augment: [Variable
                           name: name
                           type: type
                           frame: frame]!

    method addVariable: name
        self addVariable: name type: { value: Any }!

    method addVariables: names
        let type = { value: Any }.
        self augment: (names collect: { |each|
                                        Variable
                                            name: each
                                            type: type
                                            frame: frame })!

    method addVariables: names types: types
        (names size is types size) assert.
        self augment: (names with: types
                             collect: { |name type|
                                        Variable
                                            name: name
                                            type: type
                                            frame: frame })!

    method addSlots: slotVariables
        self augment: (Slot forEachVar: slotVariables)!

    method reference: name
        self reference: name from: depth!

    method reference: name inModule: module
        -- FIXME: should keep this distinct from regular bindings, now
        -- let foo ... will shadow import foo, even if the latter cannot
        -- be used on its own
        (self reference: module from: depth)
            global: name!

    method reference: name from: useDepth
        -- Debug println: "ref? {name} at {depth}?".
        -- Debug println: "bindings: {bindings collect: #name}".
        let binding = bindings
                          find: { |binding| binding name == name }
                          ifNone: { parent is False
                                        ifTrue: { return self
                                                      global: name }
                                        ifFalse: { return parent
                                                       reference: name
                                                       from: useDepth } }.
        binding referenceUpwards: useDepth - depth!

    method load: string
        -- Debug println: "Environment#load:".
        let envDefs = Dictionary new.
        let pendingDefs = List new.
        (Parser parseDefinitions: string)
            do: { |syntax|
                  -- Debug println: "translate: {syntax}".
                  (SyntaxTranslator
                       translate: syntax
                       in: (self toplevel))
                  defineIn: self }.
        self checkGlobals.
        -- Debug println: "Environment#load: OK".
        return self!

    direct method eval: string
        self new eval: string!

    direct method load: string
        self new load: string!

    method eval: string
        -- Debug println: "Environment#eval: {string displayString}".
        let toplevelEnv = self toplevel.
        let res = False.
        (Parser parseExpressions: string)
            do: { |syntax|
                  res =
                      AstInterpreter
                          eval: (SyntaxTranslator translate: syntax in: toplevelEnv)
                          inEnv: toplevelEnv }.
        res!

    method checkGlobals
        globals doValues: #warnIfUndefined!

    method global: name
        -- Debug println: "Environment#global: {name}".
        -- Debug println: "has builtins:\n{builtins}".
        -- Debug println: "has globals:\n{globals displayString}".
        builtins
            at: name
            ifNone: { globals
                          at: name
                          ifNonePut: { AstGlobal name: name } }!

    method dynamic: name
        -- Debug println: "Environment#dynamic: {name}".
        globals
            at: name
            ifNonePut: { AstDynamic name: name }!

    method define: name as: definition
        -- Debug println: "Environment#define:as: {name}".
        (builtins has: name)
            ifTrue: { Error raise: "Cannot redefine a builtin: {name}" }.
        let global = globals
                         at: name
                         ifNonePut: { definition global }.
        global define: definition!

end
