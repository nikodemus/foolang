import .syntaxTranslator.SyntaxTranslator
import .astInterpreter.AstInterpreter
import .utils.Debug
import .ast.AstGlobal
import .ast.AstDynamic
import .ast.AstLexicalRef
import .ast.AstConstantRef
import .ast.AstSlotRef
import .ast.AstDefinition
import .parser.Parser
import .ast.AstBuiltin

class Globals { dictionary }
    direct method new
        self dictionary: Dictionary new!
    method define: builtin
        let name = builtin name.
        let global = AstGlobal
                         name: name
                         definition: (AstBuiltin value: builtin).
        global value. -- finalize
        dictionary
            put: global
            at: name!
end

-- FIXME: cannot differentiate from local definitions!
-- FIXME: use a cascade as soon as they're supported in self-hosted
-- implementation...
define Builtins
    let g = Globals new.
    g define: Any.
    g define: Array.
    g define: ByteArray.
    g define: Boolean.
    g define: Character.
    g define: Class.
    g define: DoesNotUnderstand.
    g define: Error.
    g define: False.
    g define: Float.
    g define: Integer.
    g define: List.
    g define: Object.
    g define: Output.
    g define: Selector.
    g define: String.
    g define: StringOutput.
    g define: True.
    g define: TypeError.
    g dictionary!

class Variable { name type index }
    is Object

    direct method name: name type: type frame: frame
        let var = self name: name type: type index: frame size + 1.
        frame add: var.
        var!

    method referenceUpwards: offset
        AstLexicalRef variable: self frameOffset: offset!

    method printOn: stream
        stream print: "#<Variable {name}>"!
end

class Constant { name value }
    is Object

    method referenceUpwards: _offset
        AstConstantRef value: value!
end

define $CurrentModulePath []!

define $LoadDepth 0!

class ModuleDictionary { available translated }
    is Object

    direct method new
        self available: Dictionary new
             translated: Dictionary new!

    direct method new: available
        self available: available
             translated: Dictionary new!

    method at: path relative: relative in: env
        relative
            ifTrue: { self _translatePath: ($CurrentModulePath butlast concat: path)
                           _in: env }
            ifFalse: { self _translatePath: path
                            _in: env }!

    method _translatePath: path _in: env
        let dotPath = "." join: path.
        self translated
            at: dotPath
            ifNonePut: { self _loadPath: path _in: env _as: dotPath }!

    method _loadPath: path _in: env _as: dotPath
        -- Debug pad: $LoadDepth println: "load: {dotPath} ...".
        let $LoadDepth = $LoadDepth + 1.
        let source
            = self available
                at: path
                ifNone: { Error raise: "Unknown module: {dotPath}, available: {available}" }.
        self _translateSource: source _for: path _in: env!

    method _translateSource: source _for: path _in: env
        -- Debug println: "_translateSource: {source} _for: {path} _in: ...".
        let $CurrentModulePath = path.
        { (Environment
               builtins: env builtins
               modules: self)
          load: source }
            on: Error
            do: { |e|
                  let path = "." join: $CurrentModulePath.
                  Error raise: "Error loading module {path}:\n{e description}" }!
end

class ModuleBinding { name module }
    is Object
    method referenceUpwards: _
        self!
    method global: name
        module global: name!
    method warnIfUndefined
        self!
end

---
parent    -- Enclosing environment or False
bindings  -- Variables and slots in this environmetn
frame     -- Variables in this frame
depth     -- Number of enclosing frames, including this one
globals   -- Dictionary of globals
builtins  -- Dictionary of builtins
modules   -- ModuleDictionary
---
class Environment { parent
                    bindings
                    frame
                    depth
                    globals
                    builtins
                    modules }
    is Object

    direct method new
        self
            builtins: Builtins copy!

    direct method builtins: builtins
        self
            builtins: builtins
            modules: ModuleDictionary new!

    direct method modules: modules
        self
            builtins: Builtins copy
            modules: (ModuleDictionary new: modules)!

    direct method builtins: builtins modules: modules
        Environment
            parent: False
            bindings: []
            frame: List new
            depth: 1
            globals: Dictionary new
            builtins: builtins
            modules: modules!

    method addGlobals: bindings
        self checkToplevel.
        bindings do: { |each| globals put: each at: each name }.
        self!

    method checkToplevel
        (depth is 1)
            ifFalse: { Error raise: "Not at toplevel!" }!

    method newFrame
        Environment
            parent: self
            bindings: []
            frame: List new
            depth: depth + 1
            globals: globals
            builtins: builtins
            modules: modules!

    method augment: bindings
        Environment
            parent: self
            bindings: bindings
            frame: frame
            depth: depth
            globals: globals
            builtins: builtins
            modules: modules!

    method removeBuiltins: names
        builtins removeAll: names!

    method replaceBuiltins: newBuiltins
        newBuiltins do: { |each|
                          let global = builtins
                                           at: each name
                                           ifNonePut: { AstGlobal name: each name }.
                          global redefine: each }!

    method import: moduleName relative: relative
        (self depth is 1) assert.
        let module = modules
                         at: moduleName
                         relative: relative
                         in: self.
        -- Debug println: "import: {moduleName}".
        self addGlobals: [ModuleBinding
                            name: moduleName last
                            module: module]!

    method import: name from: moduleName relative: relative source: source
        (self depth is 1) assert.
        let global = (modules at: moduleName relative: relative in: self)
                         global: name.
        self addGlobals: [global withSource: source]!

    method importAll: moduleName relative: relative
        (self depth is 1) assert.
        let module = (modules at: moduleName relative: relative in: self).
        let bindings = List new.
        module globals
            doKeys: { |name|
                      (name startsWith: "_")
                          ifFalse: { -- Debug println: "importing: {name}".
                                     bindings add: (module global: name) } }.
        self addGlobals: bindings!

    method importPrelude: moduleName
        (self depth is 1) assert.
        let module = (modules at: moduleName relative: False in: self).
        module globals
            do: { |name global|
                      (name startsWith: "_")
                      ifFalse: { -- Debug println: "prelude: {name}".
                                 (builtins has: name)
                                     ifTrue: { (builtins at: name)
                                                   redefineUsing: global }
                                     ifFalse: { builtins put: global at: name } } }!

    method addVariable: name type: type
        -- Debug println: "addVariable: {name} type: {type}".
        self augment: [Variable
                           name: name
                           type: type
                           frame: frame]!

    method addVariable: name
        -- Debug println: "addVariable: {name}".
        self addVariable: name type: Any!

    method addVariables: names
        -- Debug println: "addVariables: {names}".
        self augment: (names collect: { |each|
                                        Variable
                                            name: each
                                            type: Any
                                            frame: frame })!

    method addVariables: names types: types
        -- Debug println: "addVariables: {names} types: {types}".
        (names size is types size) assert.
        self augment: (names with: types
                             collect: { |name type|
                                        Variable
                                            name: name
                                            type: type
                                            frame: frame })!

    method addSlots: slots
        self augment: slots!

    method reference: name
        self reference: name from: depth!

    method reference: name inModule: module source: source
        -- FIXME: should keep this distinct from regular bindings, now
        -- let foo ... will shadow import foo, even if the latter cannot
        -- be used on its own
        ((self reference: module from: depth)
             global: name)
        withSource: source!

    method reference: name from: useDepth
        -- Debug println: "ref? {name} at {depth}?".
        -- Debug println: "bindings: {bindings collect: #name}".
        let binding = bindings
                          find: { |binding| binding name == name }
                          ifNone: { parent is False
                                        ifTrue: { return self global: name }
                                        ifFalse: { return parent
                                                       reference: name
                                                       from: useDepth } }.
        binding referenceUpwards: useDepth - depth!

    method load: string
        -- Debug println: "Environment#load:".
        let envDefs = Dictionary new.
        let pendingDefs = List new.
        self checkToplevel.
        (Parser parseDefinitions: string)
            do: { |syntax|
                  -- Debug println: "translate: {syntax}".
                  (SyntaxTranslator
                       translate: syntax
                       in: self)
                    defineIn: self }.
        self checkGlobals.
        -- Debug println: "Environment#load: OK".
        return self!

    direct method eval: string
        self new eval: string!

    direct method load: string
        self new load: string!

    method eval: string
        -- Debug println: "Environment#eval: {string displayString}".
        self checkToplevel.
        let res = False.
        (Parser parseExpressions: string)
            do: { |syntax|
                  res = AstInterpreter
                            eval: (SyntaxTranslator translate: syntax in: self)
                            inEnv: self }.
        res!

    method checkGlobals
        globals doValues: #warnIfUndefined!

    method global: name
        -- Debug println: "Environment#global: {name}".
        -- Debug println: "has builtins:\n{builtins}".
        -- Debug println: "has globals:\n{globals displayString}".
        builtins
            at: name
            ifNone: { globals
                          at: name
                          ifNonePut: { AstGlobal name: name } }!

    method dynamic: name
        -- Debug println: "Environment#dynamic: {name}".
        globals
            at: name
            ifNonePut: { AstDynamic name: name }!

    method define: name as: definition
        -- Debug println: "Environment#define:as: {name}".
        (builtins has: name)
            ifTrue: { Error raise: "Cannot redefine a builtin: {name}" }.
        let global = globals
                         at: name
                         ifNonePut: { definition allocGlobal }.
        let res = global define: definition.
        -- Debug println: "--".
        res!

end
