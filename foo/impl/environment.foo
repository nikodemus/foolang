import .ast.AstBuiltin
import .ast.AstClass
import .ast.AstConstantRef
import .ast.AstDefinition
import .ast.AstDynamic
import .ast.AstGlobal
import .ast.AstInterface
import .ast.AstLexicalRef
import .ast.AstSlotRef
import .astInterpreter.AstInterpreter
import .parser.Parser
import .syntaxTranslator.SyntaxTranslator
import .utils.Debug

interface SimpleMethod
    method isRequired
        False!

    method name
        self selector name!
end

class GenericDelegator { target }
    is SimpleMethod

    method selector
        #perform:with:!

    method invoke: args on: _receiver
        args first sendTo: target
                   with: args second!
end

class DirectDelegator { selector target }
    is SimpleMethod

    method selector
        #includes:!

    method invoke: args on: _receiver
        selector sendTo: target with: args!
end

-- FIXME: cannot differentiate from local definitions!
-- FIXME: uncomfortable duplicate vs. CompilerBuiltins
class AllBuiltins { env }
    direct method defineIn: env
        (self env: env)
            defineAll.
        False!

    method define: builtin
        let global = env ensureBuiltin: builtin name.
        global define: (AstBuiltin
                            global: global
                            value: builtin)!

    method defineClass: builtin
        let global = env ensureBuiltin: builtin name.
        let theClass = AstClass
                           name: builtin name
                           slots: []
                           interfaces: []
                           env: env.
        -- FIXME: I can access the compiler method
        -- dictionaries here, and define explicit wrappers
        -- for all methods automatically. Adding a small annotation to
        -- the compiler method definitions can tell how the result
        -- should be wrapped.
        --
        -- Then I just need to make the interpreter convert
        -- constants into wrapped objects and pretty well off.
        --
        -- Care needs to be taken with already materialized objects
        -- from compiled code crossing over to the interpreter, though!
        theClass
            ; directMethods: List new
            ; instanceMethods: List new
            ; __addDirectMethod: (GenericDelegator target: builtin)
                -- These need separate delegators, because otherwise they
                -- get default methods that do the wrong thing.
            ; __addDirectMethod: (DirectDelegator selector: #includes: target: builtin)
            ; __addDirectMethod: (DirectDelegator selector: #typecheck: target: builtin)
                .

        global is theClass global
            assert: "Correct global for builtin class."!

    method defineAll
        -- Wrappers for builtin classes so that
        -- prelude can extend them.
        self
            ; defineClass: Array
            ; defineClass: Boolean
            ; defineClass: ByteArray
            ; defineClass: Class
            ; defineClass: Clock
            ; defineClass: Character
            ; defineClass: Closure
            ; defineClass: File
            ; defineClass: FilePath
            ; defineClass: FileStream
            ; defineClass: Float
            ; defineClass: Integer
            ; defineClass: Input
            ; defineClass: Layout
            ; defineClass: Output
            ; defineClass: Random
            ; defineClass: Record
            ; defineClass: Selector
            ; defineClass: String
            ; defineClass: Time
                .
        -- These ones don't exist on bootstrap host, but happily
        -- that one doesn't care about undefined variables either...
        Foolang isSelfHosted
            ifTrue: { self
                          ; defineClass: System
                          ; defineClass: SystemRandom }.
        self
            ; define: False
            ; define: True
                .
        self!
end

class Variable { name type index }
    is Object

    direct method name: name type: type frame: frame
        let var = self name: name type: type index: frame size + 1.
        frame add: var.
        var!

    method referenceUpwards: offset
        AstLexicalRef variable: self frameOffset: offset!

    method printOn: stream
        stream print: "#<Variable {name}>"!

    method visitBy: visitor
        visitor visitVariable: self!
end

class Argument { name type index }
    is Object

    direct method name: name type: type frame: frame
        let var = self name: name type: type index: frame size + 1.
        frame add: var.
        var!

    method referenceUpwards: offset
        AstLexicalRef variable: self frameOffset: offset!

    method printOn: stream
        stream print: "#<Argument {name}>"!

    method visitBy: visitor
        visitor visitArgument: self!
end

class Constant { name value }
    is Object

    method referenceUpwards: _offset
        AstConstantRef value: value!
end

define $CurrentModulePath []!

define $LoadDepth 0!

class ModuleDictionary { available translated }
    is Object

    direct method new
        self available: Dictionary new
             translated: Dictionary new!

    direct method new: available
        self available: available
             translated: Dictionary new!

    method at: path relative: relative in: env
        relative
            ifTrue: { self _translatePath: ($CurrentModulePath butlast concat: path)
                           _in: env }
            ifFalse: { self _translatePath: path
                            _in: env }!

    method _translatePath: path _in: env
        let dotPath = "." join: path.
        self translated
            at: dotPath toUppercase
            ifNonePut: { self _loadPath: path _in: env _as: dotPath }!

    method _loadPath: path _in: env _as: dotPath
        -- Debug pad: $LoadDepth println: "load: {dotPath} ...".
        let $LoadDepth = $LoadDepth + 1.
        let source = self available at: path.
        self _translateSource: source _for: path _in: env!

    method _translateSource: source _for: path _in: env
        -- Debug println: "_translateSource: {source} _for: {path} _in: ...".
        let $CurrentModulePath = path.
        { (env copyForModule: self)
              load: source }
            on: Error
            do: { |e|
                  let path = "." join: $CurrentModulePath.
                  Error raise: "Error loading module {path}:\n{e description}" }!
end

class ModuleBinding { name module }
    is Object
    method referenceUpwards: _
        self!
    method global: name
        module global: name!
    method warnIfUndefined
        self!
end

---
parent    -- Enclosing environment or False
bindings  -- Variables and slots in this environmetn
frame     -- Variables in this frame
depth     -- Number of enclosing frames, including this one
globals   -- Dictionary of globals
builtins  -- Dictionary of builtins
modules   -- ModuleDictionary
---
class Environment { parent
                    bindings
                    frame
                    depth
                    globals
                    builtins
                    modules
                    classes }
    is Object

    method describe
        Debug println: "---".
        Debug println: "bindings = {bindings}".
        Debug println: "globals = {globals}".
        Debug println: "builtins = {builtins}".
        Debug println: "modules = {modules}".
        Debug println: "depth = {depth}".
        parent is False
            ifFalse: { parent describe }!

    direct method new
        self modules: []!

    direct method modules: modules
        self modules: modules
             classes: Dictionary new!

    direct method modules: modules classes: classes
        (Environment
             parent: False
             bindings: []
             frame: List new
             depth: 1
             globals: Dictionary new
             builtins: Dictionary new
             modules: (ModuleDictionary new: modules)
             classes: classes)
        initializeBuiltins!

    method copyForModule: modules
        Environment
            parent: False
            bindings: []
            frame: List new
            depth: 1
            globals: Dictionary new
            builtins: builtins
            modules: modules
            classes: classes!

    method initializeBuiltins
        AllBuiltins defineIn: self.
        self!

    method addGlobals: bindings
        self checkToplevel.
        bindings do: { |each| globals put: each at: each name }.
        self!

    method checkToplevel
        (depth is 1)
            ifFalse: { Error raise: "Not at toplevel!" }!

    method newFrame
        Environment
            parent: self
            bindings: []
            frame: List new
            depth: depth + 1
            globals: globals
            builtins: builtins
            modules: modules
            classes: classes!

    method augment: bindings
        Environment
            parent: self
            bindings: bindings
            frame: frame
            depth: depth
            globals: globals
            builtins: builtins
            modules: modules
            classes: classes!

    method makeGlobal: name
        (name startsWith: "$")
            ifTrue: { AstDynamic name: name }
            ifFalse: { AstGlobal name: name }!

    method redefineBuiltin: definition
        let global = builtins
                         at: definition name
                         ifNonePut: { self makeGlobal: definition name }.
        global redefine: definition!

    method ensureBuiltin: name
        builtins at: name
                 ifNonePut: { self makeGlobal: name }!

    method replaceBuiltins: newBuiltins
        newBuiltins do: { |each| self redefineBuiltin: each }.
        self!

    method import: moduleName relative: relative
        (self depth is 1) assert.
        let module = modules
                         at: moduleName
                         relative: relative
                         in: self.
        -- Debug println: "import: {moduleName}".
        self addGlobals: [ModuleBinding
                            name: moduleName last
                            module: module]!

    method import: name from: moduleName relative: relative source: source
        (self depth is 1) assert.
        let global = (modules at: moduleName relative: relative in: self)
                         global: name.
        self addGlobals: [global withSource: source]!

    method importAll: moduleName relative: relative
        (self depth is 1) assert.
        let module = (modules at: moduleName relative: relative in: self).
        let bindings = List new.
        module globals
            do: { |name global|
                  name isPrivate
                      ifFalse: { bindings add: global } }.
        self addGlobals: bindings!

    method importPrelude: moduleName
        (self depth is 1) assert.
        let module = (modules at: moduleName relative: False in: self).
        module globals
            do: { |name global|
                  name isPrivate
                      ifFalse: { -- Debug println: "prelude: {name}".
                                 (builtins has: name)
                                     ifTrue: { (builtins at: name)
                                                   redefineUsing: global }
                                     ifFalse: { builtins put: global at: name } } }.
        self!

    method addVariable: name type: type
        -- Debug println: "addVariable: {name} type: {type}".
        self augment: [Variable
                           name: name
                           type: type
                           frame: frame]!

    method addVariable: name
        -- Debug println: "addVariable: {name}".
        self addVariable: name type: Any!

    method addArguments: names types: types
        -- Debug println: "addArguments: {names} types: {types}".
        (names size is types size) assert.
        self augment: (names with: types
                             collect: { |name type|
                                        Argument
                                            name: name
                                            type: type
                                            frame: frame })!

    method addSlots: slots
        self augment: slots!

    method reference: name
        self reference: name from: depth!

    method reference: name inModule: module source: source
        -- FIXME: should keep this distinct from regular bindings, now
        -- let foo ... will shadow import foo, even if the latter cannot
        -- be used on its own
        ((self reference: module from: depth)
             global: name)
        withSource: source!

    method reference: name from: useDepth
        -- Debug println: "ref? {name} at {depth}?".
        -- Debug println: "bindings: {bindings collect: #name}".
        let binding = bindings
                          find: { |binding| binding name == name }
                          ifNone: { parent is False
                                        ifTrue: { return self global: name }
                                        ifFalse: { return parent
                                                       reference: name
                                                       from: useDepth } }.
        binding referenceUpwards: useDepth - depth!

    method load: string
        -- Debug println: "Environment#load:".
        let envDefs = Dictionary new.
        let pendingDefs = List new.
        self checkToplevel.
        (Parser parseDefinitions: string)
            do: { |syntax|
                  -- Debug println: "translate: {syntax}".
                  (SyntaxTranslator
                       translate: syntax
                       in: self)
                    defineIn: self }.
        self checkGlobals.
        -- Debug println: "Environment#load: OK".
        return self!

    direct method eval: string
        self new eval: string!

    direct method load: string
        self new load: string!

    method eval: string
        -- Debug println: "Environment#eval: {string displayString}".
        self checkToplevel.
        let res = False.
        (Parser parseExpressions: string)
            do: { |syntax|
                  res = (SyntaxTranslator translate: syntax in: self)
                      evalIn: self }.
        res!

    method checkGlobals
        globals doValues: #warnIfUndefined!

    method builtin: name
        builtins at: name!

    method global: name
        -- Debug println: "Environment#global: {name}".
        -- Debug println: "has builtins:\n{builtins}".
        -- Debug println: "has globals:\n{globals displayString}".
        builtins
            at: name
            ifNone: { globals
                          at: name
                          ifNonePut: { self makeGlobal: name } }!
end
