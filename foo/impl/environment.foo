import .syntaxTranslator.SyntaxTranslator
import .astInterpreter.AstInterpreter
import .utils.Debug
import .ast.AstGlobal
import .ast.AstLexicalRef
import .ast.AstSlotRef
import .ast.AstDefinition
import .undefinedPolicy.UndefinedPolicy
import .undefinedPolicy.AllowReferenceToUndefined
import .undefinedPolicy.ResolveUndefinedsWith

define BuiltinGlobals
    let globals = Dictionary new.
    globals put: (AstGlobal name: "True" value: True) at: "True".
    globals put: (AstGlobal name: "False" value: False) at: "False".
    globals put: (AstGlobal name: "Object" value: Object) at: "Object".
    globals put: (AstGlobal name: "Integer" value: Integer) at: "Integer".
    globals put: (AstGlobal name: "String" value: String) at: "String".
    globals!

class Variable { name index }
    is Object

    direct method name: name frame: frame
        let var = self name: name index: frame size + 1.
        frame add: var.
        var!

    method referenceUpwards: offset
        AstLexicalRef variable: self frameOffset: offset!
end

class Slot { name index }
    is Object

    direct method forEachName: names
        let n = 0.
        names collect: { |name|
                         n = n + 1.
                         Slot name: name index: n }!

    method referenceUpwards: offset
        AstSlotRef slot: self!
end

class Environment { parent    -- Enclosing environment or False
                    bindings  -- Variables and slots in this environment
                    frame     -- Variables in this frame
                    depth     -- Number of enclosing frames, including this one
                    globals } -- Dictionary of globals
    is Object

    direct method new
        Environment
            parent: False
            bindings: []
            frame: List new
            depth: 1
            globals: BuiltinGlobals copy!

    method toplevel
        Environment
            parent: False
            bindings: []
            frame: List new
            depth: 1
            globals: globals!

    method newFrame
        Environment
            parent: self
            bindings: []
            frame: List new
            depth: depth + 1
            globals: globals!

    method addVariable: name
        let var = Variable name: name frame: frame.
        Environment
            parent: self
            bindings: [var]
            frame: frame
            depth: depth
            globals: globals!

    method addVariables: names
        let vars = names collect: { |name| Variable name: name frame: frame }.
        Environment
            parent: self
            bindings: vars
            frame: frame
            depth: depth
            globals: globals!

    method addSlots: names
        let slots = Slot forEachName: names.
        Environment
            parent: self
            bindings: slots
            frame: frame
            depth: depth
            globals: globals!

    method reference: name
        self reference: name from: depth!

    method reference: name from: use
        -- Debug println: "ref? {name} at {depth}?".
        let binding = bindings
                          find: { |binding| binding name == name }
                          ifNone: { parent is False
                                        ifTrue: { return self global: name }
                                        ifFalse: { return parent reference: name from: use }}.
        binding referenceUpwards: use - depth!

    method load: string
        let defs = Dictionary new.
        (Parser parseDefinitions: string)
            do: { |syntax|
                  AllowReferenceToUndefined
                      do: { let def::AstDefinition
                                = SyntaxTranslator
                                    translate: syntax
                                    in: (self toplevel).
                             defs put: def at: def name } }.
        ResolveUndefinedsWith
            definitions: defs
            in: self
            do: { defs doValues: { |def| def defineIn: self } }.
        self checkGlobals.
        self!

    direct method eval: string
        self new eval: string!

    method eval: string
        let toplevelEnv = self toplevel.
        let res = False.
        (Parser parseExpressions: string)
            do: { |syntax|
                  res =
                      AstInterpreter
                          eval: (SyntaxTranslator translate: syntax in: toplevelEnv)
                          inEnv: toplevelEnv }.
        res!

    method checkGlobals
        globals doValues: { |global|
                            global isUndefined
                                ifTrue: { Error raise: "Undefined variable: {global name}" } }!

    method global: name
        globals at: name ifNone: { self undefined: name }!

    method undefined: name
        UndefinedPolicy reference: name in: self!

    method define: name value: value
        let global = globals
                         at: name
                         ifNone: { globals
                                       put: (AstGlobal name: name value: value)
                                       at: name.
                                   return value }.
        global isUndefined
            ifTrue: { global value: value.
                      value }
            ifFalse: { Error raise: "Cannot redefined a global: {name}" }!

end
