import .syntaxTranslator.SyntaxTranslator
import .astInterpreter.AstInterpreter
import .utils.Debug
import .ast.AstGlobal
import .ast.AstLexicalRef
import .ast.AstSlotRef
import .ast.AstDefinition
import .ast.UndefinedPolicy
import .ast.AllowReferenceToUndefined
import .ast.ResolveUndefinedsWith
import .parser.Parser

-- FIXME: cannot differentiate from local definitions!
define BuiltinGlobals
    let globals = Dictionary new.
    globals put: (AstGlobal name: "True" value: True) at: "True".
    globals put: (AstGlobal name: "False" value: False) at: "False".
    globals put: (AstGlobal name: "Object" value: Object) at: "Object".
    globals put: (AstGlobal name: "Integer" value: Integer) at: "Integer".
    globals put: (AstGlobal name: "String" value: String) at: "String".
    globals!

class Variable { name type index }
    is Object

    direct method name: name type: type frame: frame
        let var = self name: name type: type index: frame size + 1.
        frame add: var.
        var!

    method referenceUpwards: offset
        AstLexicalRef variable: self frameOffset: offset!
end

class Slot { name index type }
    is Object

    direct method forEachVar: vars
        let n = 0.
        vars collect: { |var|
                        n = n + 1.
                        Slot name: var name index: n type: var type }!

    method referenceUpwards: offset
        AstSlotRef slot: self!
end

class Constant { name value }
    is Object

    method referenceUpwards: _offset
        AstConstantRef value: value!
end

class ModuleDictionary { available translated }
    direct method new
        self available: Dictionary new
             translated: Dictionary new!

    direct method new: available
        self available: available
             translated: Dictionary new!

    method at: name relative: relative
        let path = "/" join: name.
        self translated
            at: path
            ifNonePut: { self _translate: name _relative: relative }!

    method _translate: name _relative: relative
        let path = "/" join: name.
        let path = relative
                       ifTrue: { "./{path}" }
                       ifFalse: { path }.
        let name = "." join: name.
        let source
            = self available
                at: path
                ifNone: { Error raise: "Unknown module: {name}" }.
        { Environment new load: source }
            on: Error
            do: { |e|
                  let maybeDot = relative ifTrue: { "." } ifFalse: { "" }.
                  Error raise: "Error loading module {maybeDot}{name}:\n{e description}" }!
end

class ModuleBinding { name module }
    method referenceUpwards: _
        self!
    method reference: definition
        module reference: definition!
end

class Environment { parent    -- Enclosing environment or False
                    bindings  -- Variables and slots in this environment
                    frame     -- Variables in this frame
                    depth     -- Number of enclosing frames, including this one
                    globals   -- Dictionary of globals
                    modules } -- ModuleDictionary
    is Object

    direct method new
        Environment
            parent: False
            bindings: []
            frame: List new
            depth: 1
            globals: BuiltinGlobals copy
            modules: ModuleDictionary new!

    direct method modules: modules
        Environment
            parent: False
            bindings: []
            frame: List new
            depth: 1
            globals: BuiltinGlobals copy
            modules: (ModuleDictionary new: modules)!

    method toplevel
        Environment
            parent: False
            bindings: []
            frame: List new
            depth: 1
            globals: globals
            modules: modules!

    method import: moduleName relative: relative
        (self depth is 1) assert.
        let mod = ModuleBinding
                      name: moduleName last
                      module: (modules at: moduleName relative: relative).
        Environment
            parent: self
            bindings: [mod]
            frame: List new
            depth: 1
            globals: globals
            modules: modules!

    method import: name from: moduleName relative: relative
        (self depth is 1) assert.
        let global = (modules at: moduleName relative: relative) reference: name.
        Environment
            parent: self
            bindings: [global]
            frame: List new
            depth: 1
            globals: globals
            modules: modules!

    method importAll: moduleName relative: relative
        (self depth is 1) assert.
        let module = (modules at: moduleName relative: relative).
        let bindings = List new.
        module globals
            doKeys: { |name|
                      (name startsWith: "_")
                          ifFalse: { bindings add: (module reference: name) } }.
        Environment
            parent: self
            bindings: bindings
            frame: List new
            depth: 1
            globals: globals
            modules: modules!

    method newFrame
        Environment
            parent: self
            bindings: []
            frame: List new
            depth: depth + 1
            globals: globals
            modules: modules!

    method addVariable: name type: type
        let var = Variable
                      name: name
                      type: type
                      frame: frame.
        Environment
            parent: self
            bindings: [var]
            frame: frame
            depth: depth
            globals: globals
            modules: modules!

    method addVariable: name
        self addVariable: name type: Any!

    method addVariables: names
        let vars = names collect: { |name|
                                    Variable
                                        name: name
                                        type: Any
                                        frame: frame }.
        Environment
            parent: self
            bindings: vars
            frame: frame
            depth: depth
            globals: globals
            modules: modules!

    method addVariables: names types: types
        (names size is types size) assert.
        let vars = names with: types
                         collect: { |name type|
                                    Variable
                                        name: name
                                        type: type
                                        frame: frame }.
        Environment
            parent: self
            bindings: vars
            frame: frame
            depth: depth
            globals: globals
            modules: modules!

    method addSlots: slotVariables
        let slots = Slot forEachVar: slotVariables.
        Environment
            parent: self
            bindings: slots
            frame: frame
            depth: depth
            globals: globals
            modules: modules!

    method reference: name
        self reference: name from: depth!

    method reference: name inModule: module
        -- FIXME: should keep this distinct from regular bindings, now
        -- let foo ... will shadow import foo, even if the latter cannot
        -- be used on its own
        (self reference: module from: depth)
            reference: name!

    method reference: name from: use
        -- Debug println: "ref? {name} at {depth}?".
        let binding = bindings
                          find: { |binding| binding name == name }
                          ifNone: { parent is False
                                        ifTrue: { return self global: name }
                                        ifFalse: { return parent reference: name from: use }}.
        binding referenceUpwards: use - depth!

    method load: string
        let envDefs = Dictionary new.
        let pendingDefs = List new.
        (Parser parseDefinitions: string)
            do: { |syntax|
                  -- Debug println: "translate: {syntax}".
                  AllowReferenceToUndefined
                      do: { (SyntaxTranslator
                                 translate: syntax
                                 in: (self toplevel))
                            do: { |def|
                                  def isCanonical
                                      ifTrue: { envDefs put: def at: def name }.
                                  pendingDefs add: def } } }.
        ResolveUndefinedsWith
            definitions: envDefs
            in: self
            do: { pendingDefs
                      do: { |def|
                            -- Debug println: "define: {def}".
                            def defineIn: self } }.
        self checkGlobals.
        self!

    direct method eval: string
        self new eval: string!

    direct method load: string
        self new load: string!

    method eval: string
        let toplevelEnv = self toplevel.
        let res = False.
        (Parser parseExpressions: string)
            do: { |syntax|
                  res =
                      AstInterpreter
                          eval: (SyntaxTranslator translate: syntax in: toplevelEnv)
                          inEnv: toplevelEnv }.
        res!

    method checkGlobals
        globals doValues: { |global|
                            global isUndefined
                                ifTrue: { Error raise: "Undefined variable: {global name}" } }!

    method global: name
        globals at: name ifNone: { self undefined: name }!

    method undefined: name
        UndefinedPolicy reference: name in: self!

    method define: name value: value
        let global = globals
                         at: name
                         ifNone: { globals
                                       put: (AstGlobal name: name value: value)
                                       at: name.
                                   return value }.
        global isUndefined
            ifTrue: { global value: value.
                      value }
            ifFalse: { Error raise: "Cannot redefined a global: {name}" }!

end
