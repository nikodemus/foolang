import .utils.Debug

interface Type
    is Object

    method findMethod: selector in: env
        self earlyBinding
            => { |name|
                 return (env global: name)
                     definition findInstanceMethod: selector }.
        False!

    method earlyBinding
        False!
end

class EqType { value }
    is Type

    method findMethod: selector in: env
        ((Class includes: value) or: (Interface includes: value))
            ifTrue: { self findDirectMethod: selector in: env }
            ifFalse: { self findInstanceMethod: selector in: env }!

    method findDirectMethod: selector in: env
        -- FIXME: should look for builtins, but they're not in the environment!
        let targetClass = env classes at: value ifNone: { return False }.
        targetClass findDirectMethod: selector!

    method findInstanceMethod: selector in: env
        -- FIXME: should look for builtins, but they're not in the environment!
        let targetClass = env classes at: value classOf ifNone: { return False }.
        targetClass findInstanceMethod: selector!

    method displayOn: stream
        stream writeString: "#<EqType {value classOf name}>"!
end

    --- For EqType
    method findMethod: selector for: compiler
        (Record includes: value)
            ifTrue: { let recordClass =  compiler _recordClassFromRecord: value.
                      return recordClass findInstanceMethod: selector }.
        let wantDirectMethod = (Class includes: value) or: (Interface includes: value).
        let hostClass = wantDirectMethod
                            ifTrue: { value }
                            ifFalse: { value classOf }.
        let targetClass = compiler env classes
                              at: hostClass
                              ifNone: { let builtin
                                            = compiler _findBuiltinFor: hostClass
                                                       _ifNone: { Debug println: "!!! could not map {hostClass}".
                                                                  return False }.
                                        builtin definition }.
        wantDirectMethod
            ifTrue: { targetClass findDirectMethod: selector }
            ifFalse: { targetClass findInstanceMethod: selector }!
    ---

class HostType { hostType }
    is Type

    direct method type: hostType
        hostType is Any
            ifTrue: { TheUnknownType }
            ifFalse: { self hostType: hostType }!


    method findMethod: selector in: env
        -- FIXME: look for builtin as well
        let targetType = env classes
                             at: hostType
                             ifNone: { return False }.
        targetType isClass
            ifTrue: { targetType findInstanceMethod: selector }!

    method displayOn: stream
        stream writeString: "#<HostType {hostType name}"!
end

class UnknownType {}
    is Type

    method displayOn: stream
        stream writeString: "#<UnknownType>"!
end

class ReceiverType { definition }
    is Type

    method findMethod: selector in: _env
        -- Interface methods can be overridden!
        definition isClass
            ifTrue: { definition findInstanceMethod: selector }!

    method displayOn: stream
        stream writeString: "#<ReceiverType {definition name}>"!
end

class ReceiverClassType { definition }
    is Type

    method findMethod: selector in: _env
        -- Interface methods can be overridden!
        definition isClass
            ifTrue: { definition findDirectMethod: selector }!

    method displayOn: stream
        stream writeString: "#<ReceiverClassType {definition name}>"!
end

class ReceiverMetaclassType { definition }
    is Type

    method displayOn: stream
        stream writeString: "#<ReceiverMetaclassType {definition name}>"!
end

class BooleanType {}
    is Type

    -- FIXME: I _really_ mislike this. Should represent the type
    -- directly with the right object.
    method earlyBinding
        "Boolean"!

    method displayOn: stream
        stream writeString: "#<BooleanType>"!
end

class ClosureType { argumentTypes returnType }
    is Type

    method earlyBinding
        "Closure"!

    method displayOn: stream
        stream writeString: "#<ClosureType {argumentTypes} -> {returnType}>"!
end

class ArrayType {}
    is Type

    method displayOn: stream
        stream writeString: "#<ArrayType>"!
end

class CascadeReceiverType {}
    is Type

    method displayOn: stream
        stream writeString: "#<CascadeReceiverType>"!
end

define TheCascadeReceiverType
    CascadeReceiverType new!

define TheArrayType
    ArrayType new!

define TheUnknownType
    UnknownType new!

define TheBooleanType
    BooleanType new!
