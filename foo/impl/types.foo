import .utils.Debug

interface Type
    is Object

    method findMethod: selector in: env
        self earlyBinding
            => { |name|
                 return (env global: name)
                     definition findInstanceMethod: selector }.
        False!

    method earlyBinding
        False!
end

class EqType { value }
    is Type

    method findMethod: selector in: env
        ((Class includes: value) or: (Interface includes: value))
            ifTrue: { self findDirectMethod: selector in: env }
            ifFalse: { self findInstanceMethod: selector in: env }!

    method findDirectMethod: selector in: env
        -- FIXME: should look for builtins, but they're not in the environment!
        let targetClass = env classes at: value ifNone: { return False }.
        targetClass findDirectMethod: selector!

    method findInstanceMethod: selector in: env
        -- FIXME: should look for builtins, but they're not in the environment!
        let targetClass = env classes at: value classOf ifNone: { return False }.
        targetClass findInstanceMethod: selector!

    method displayOn: stream
        stream writeString: "#<EqType {value classOf name}>"!
end

class UnknownType {}
    is Type

    method displayOn: stream
        stream writeString: "#<UnknownType>"!
end

class ReceiverType { definition }
    is Type

    method displayOn: stream
        stream writeString: "#<ReceiverType {definition name}>"!
end

class ReceiverClassType { definition }
    is Type

    method displayOn: stream
        stream writeString: "#<ReceiverClassType {definition name}>"!
end

class BooleanType {}
    is Type

    -- FIXME: I _really_ mislike this. Should represent the type
    -- directly with the right object.
    method earlyBinding
        "Boolean"!

    method displayOn: stream
        stream writeString: "#<BooleanType>"!
end

class ClosureType { argumentTypes returnType }
    is Type

    method earlyBinding
        "Closure"!

    method displayOn: stream
        stream writeString: "#<ClosureType {argumentTypes} -> {returnType}>"!
end

class ArrayType {}
    is Type

    method displayOn: stream
        stream writeString: "#<ArrayType>"!
end

class CascadeReceiverType {}
    is Type

    method displayOn: stream
        stream writeString: "#<CascadeReceiverType>"!
end

define TheCascadeReceiverType
    CascadeReceiverType new!

define TheArrayType
    ArrayType new!

define TheUnknownType
    UnknownType new!

define TheBooleanType
    BooleanType new!
