import .utils.Debug

interface Type
    is Object

    method findMethod: selector in: env
        self earlyBinding
            => { |name|
                 return (env global: name)
                     definition findInstanceMethod: selector }.
        False!

    method withDefinitionFor: type in: env do: block
        let definition = env classes
                             at: type
                             ifNone: { let builtin = env findBuiltinFor: type
                                                         ifNone: { return False }.
                                        builtin definitionIn: env }.
        block value: definition!

    method earlyBinding
        False!
end

class EqType { value }
    is Type

    method findMethod: selector in: env
        ((Class includes: value) or: (Interface includes: value))
            ifTrue: { self findDirectMethod: selector in: env }
            ifFalse: { self findInstanceMethod: selector in: env }!

    method findDirectMethod: selector in: env
        self withDefinitionFor: value
             in: env
             do: { |def| def findDirectMethod: selector }!

    method findInstanceMethod: selector in: env
        (Record includes: value)
            ifTrue: { let recordClass = env recordClassFromRecord: value.
                      return recordClass findInstanceMethod: selector }.
        self withDefinitionFor: value classOf
             in: env
             do: { |def| def findInstanceMethod: selector }!

    method displayOn: stream
        stream writeString: "#<EqType {value classOf name}>"!
end

    --- For EqType
    method findMethod: selector in: env
        (Record includes: value)
            ifTrue: { let recordClass = env recordClassFromRecord: value.
                      return recordClass findInstanceMethod: selector }.
        let wantDirectMethod = (Class includes: value) or: (Interface includes: value).
        let hostClass = wantDirectMethod
                            ifTrue: { value }
                            ifFalse: { value classOf }.
        let targetClass = env classes
                              at: hostClass
                              ifNone: { let builtin = env findBuiltinFor: hostClass
                                                          ifNone: { return False }.
                                         builtin definition }.
        wantDirectMethod
            ifTrue: { targetClass findDirectMethod: selector }
            ifFalse: { targetClass findInstanceMethod: selector }!
    ---

class DefinitionType { definition }
    is Type

    method displayOn: stream
        stream writeString: "#<DefinitionType {definition name}>"!

    method findMethod: selector in: _env
        definition findInstanceMethod: selector!
end

class HostType { hostType }
    is Type

    direct method type: hostType
        hostType is Any
            ifTrue: { TheUnknownType }
            ifFalse: { self hostType: hostType }!

    method findMethod: selector in: env
        self withDefinitionFor: hostType
             in: env
             do: { |def|
                   def isClass
                       ifTrue: { def findInstanceMethod: selector } }!

    method displayOn: stream
        stream writeString: "#<HostType {hostType name}"!
end

class UnknownType {}
    is Type

    method name
        "<<UnknownType>>"!

    method displayOn: stream
        stream writeString: "#<UnknownType>"!
end

class ReceiverType { definition }
    is Type

    method findMethod: selector in: _env
        -- Interface methods can be overridden, so cannot early bind
        -- to them.
        -- * Clone methods from interfaces to classes.
        -- * Add final qualifier for non-overridable interface methods.
        definition isClass
            ifTrue: { definition findInstanceMethod: selector }!

    method displayOn: stream
        stream writeString: "#<ReceiverType {definition name}>"!
end

class ReceiverClassType { definition }
    is Type

    method findMethod: selector in: _env
        -- Interface methods can be overridden, so cannot early bind
        -- to them.
        -- * Clone methods from interfaces to classes.
        -- * Add final qualifier for non-overridable interface methods.
        definition isClass
            ifTrue: { definition findDirectMethod: selector }!

    method displayOn: stream
        stream writeString: "#<ReceiverClassType {definition name}>"!
end

class ReceiverMetaclassType { definition }
    is Type

    method displayOn: stream
        stream writeString: "#<ReceiverMetaclassType {definition name}>"!
end

class BooleanType {}
    is Type

    -- FIXME: I _really_ mislike this. Should represent the type
    -- directly with the right object.
    method earlyBinding
        "Boolean"!

    method displayOn: stream
        stream writeString: "#<BooleanType>"!
end

class ClosureType { argumentTypes returnType }
    is Type

    method earlyBinding
        "Closure"!

    method displayOn: stream
        stream writeString: "#<ClosureType {argumentTypes} -> {returnType}>"!
end

class ArrayType {}
    is Type

    method displayOn: stream
        stream writeString: "#<ArrayType>"!
end

class CascadeReceiverType {}
    is Type

    method displayOn: stream
        stream writeString: "#<CascadeReceiverType>"!
end

define TheCascadeReceiverType
    CascadeReceiverType new!

define TheArrayType
    ArrayType new!

define TheUnknownType
    UnknownType new!

define TheBooleanType
    BooleanType new!
