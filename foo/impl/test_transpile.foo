import .compiler
import .utils.Debug

import lib.assert.Assert

import .test_self_hosting.TestSelfHosting
import .transpiler.test_name.TestName

class TestTranspileWrapper { test system }
    method assert: assert
        test
            assert: assert
            system: system!
end

interface TranspilerTest
    is TestSuite

    direct method system: system
        TestTranspileWrapper test: self system: system!

    method prelude: prelude transpile: string
        let target = system currentDirectory / "tmp_transpile_test.exe".
        target ifExists: #deleteFile.
        target exists not
            assert: "executable cleared".
        (compiler.Compiler
             source: string
             target: target
             system: system
             prelude: prelude)
            compile.
        target exists
            assert: "executable created".
        let cmd = system command: target pathname.
        cmd stderr isEmpty
            ifFalse: { Debug println: "---stderr---".
                       Debug println: cmd stderr.
                       Debug println: "---" }.
        cmd!

    method transpile: string expect: output
        self prelude: False
             transpile: string
             ok: True
             expect: output!

    method transpile: string expectError: output
        self prelude: False
             transpile: string
             ok: False
             expect: output!

    method transpileWithError: string
        { let res = self prelude: False transpile: string.
          Output debug println: "WTF:\{string}\n==>\n{res}".
          return False }
            on: Error
            do: { |e|
                  return e description }.
        Error raise: "Expected transpiler error, but nothing happened:\n{string}"!

    method transpile: string expectCompilerError: output::String
        assert that: { self transpileWithError: string }
               equals: output
               testing: "transpile:expectCompilerError:"!

    method transpileWithPrelude: string expect: output
        self prelude: ["lang", "target_prelude"] asList
             transpile: string
             ok: True
             expect: output!

    method transpileWithPrelude: string check: block
        self prelude: ["lang", "target_prelude"] asList
             transpile: string
             ok: True
             check: block!

    method prelude: name transpile: string ok: maybe expect: output
        assert that: { let res = self prelude: name
                                      transpile: string.
                       [res ok, res stdout] }
               equals: [maybe, output]
               testing: "transpiler"!

    method prelude: name transpile: string ok: maybe check: block
        assert true: { let res = self prelude: name
                                      transpile: string.
                       block value: res }
               testing: "transpiler"!
end

class TestTranspilePanic { assert system }
    is TranspilerTest

    method testPanic
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 panic \"Let's Panic You And Me!\"!
                         end"
            expectError: "PANIC: Let's Panic You And Me!
Backtrace:
  1: Main classOf#run:in:
"!
end

class TestTranspilePreludeException { assert system }
    is TranspilerTest

    method test_Main_does_not_understand
        self transpile: "import lang.exception.*
                         import lang.selector_target_ext
                         import lang.object.Object

                         class Main \{\}
                             is Object
                             direct method run: command in: system
                                 self bang!
                         end"
            expectError: "PANIC: UNHANDLED ERROR: Main does not understand: #bang
Backtrace:
  6: FallbackHandler classOf#raise:
  5: Error#raise (DoesNotUnderstand)
  4: DoesNotUnderstand classOf#raise:with:on:source:context:
  3: DoesNotUnderstand classOf#raise:with:on:
  2: Object interface#perform:with: (Main classOf) #bang
  1: Main classOf#run:in:
"!

    method test_Class_does_not_understand
        self transpile: "import lang.exception.*
                         import lang.class_target_ext
                         import lang.selector_target_ext

                         class Main \{\}
                             is Object
                             direct method run: command in: system
                                 Class bang!
                         end"
            expectError: "PANIC: UNHANDLED ERROR: Class does not understand: #bang
Backtrace:
  6: FallbackHandler classOf#raise:
  5: Error#raise (DoesNotUnderstand)
  4: DoesNotUnderstand classOf#raise:with:on:source:context:
  3: DoesNotUnderstand classOf#raise:with:on:
  2: Object#perform:with: (Class) #bang
  1: Main classOf#run:in:
"!

    method testErrorRaise
        self transpile: "import lang.exception.*
                         import lang.closure_ext

                         class Main \{}
                             direct method run: command in: system
                                 \{ self bang }
                                     on: Error
                                     do: \{ 1 debug }.
                                 self bang!
                             direct method bang
                                 Error raise: \"Bang!\"!
                         end"
            expectError: "#<Integer 1>PANIC: UNHANDLED ERROR: Bang!
Backtrace:
  11: FallbackHandler classOf#raise:
  10: Handler#raise:
  9: Error#raise (SimpleError)
  8: SimpleError classOf#raise:
  7: Error interface#raise:
  6: Main classOf#bang
  4: Closure#value
  3: Error interface#withHandler:do:
  2: Block#on:do: (Closure)
  1: Main classOf#run:in:
"!

end

class TestTranspilePreludeFilePath { assert system }
    is TranspilerTest

    method testExists
        self transpile: "import lang.filepath_ext
                         class Main \{}
                              direct method run: command in: system
                                  (system files / \"foo\")
                                      ifExists: \{ system output writeString: \"foo ok, \" }
                                      ifDoesNotExist: \{ system output writeString: \"no foo! \"}.
                                  (system files / \"nosuchthing\")
                                      ifExists: \{ system output writeString: \"nosuchthing exists!\" }
                                      ifDoesNotExist: \{ system output writeString: \"nosuchthing ok\"}!
                         end"
             expect: "foo ok, nosuchthing ok"!

    method testFile
        self transpile: "import lang.filepath_ext
                         class Main \{}
                             direct method run: command in: system
                                 (system files / \"README.md\") pathname printOn: system output!
                         end"
            expect: "README.md"!

    method testIsDirectory
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 let foo = system files / \"foo\".
                                 let readme = system files / \"README.md\".
                                 foo isDirectory debug.
                                 readme isDirectory debug!
                         end"
            expect: "#<Boolean True>#<Boolean False>"!

    method testIsFile
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 let foo = system files / \"foo\".
                                 let readme = system files / \"README.md\".
                                 readme isFile debug.
                                 foo isFile debug!
                         end"
             expect: "#<Boolean True>#<Boolean False>"!

    method testToString
        self transpile: "import lang.filepath_ext
                         class Main \{}
                              direct method run: command in: system
                                  (system files / \"foo\") toString debug!
                         end"
             expect: "#<String foo>"!

end

class TestTranspilePreludeFileStream { assert system }
    is TranspilerTest

    method testRoundtrip
        self transpile: "class Main \{}
                             direct method run: command in: system
                                let test = (system files / \"test.tmp\").
                                let out = test file forWrite truncateExisting createOrOpen.
                                out writeString: \"This is\".
                                out close.
                                let out2 = test file forAppend createOrOpen.
                                out2 writeString: \" a test!\".
                                out2 close.
                                let in = test file forRead open.
                                system output writeString: in readString.
                                in offsetFromEnd: -8.
                                system output writeString: in readString.
                                in offset: 2.
                                in offsetFromHere: 2.
                                system output writeString: in readString.
                                in close.
                                test deleteFile!
                         end"
            expect: "This is a test! a test! is a test!"!


    method testSize
        self transpile: "import lang.filestream_ext
                         import lang.filepath_ext
                         import lang.file_ext
                         class Main \{}
                             direct method run: command in: system
                                 let size = (system files / \"data/132-bytes.txt\") forRead
                                     open: \{ |s| s size }.
                                 size debug!
                         end"
            expect: "#<Integer 132>"!
end

class TestTranspilePreludeIterable { assert system }
    is TranspilerTest

    method test
        self transpile: "import lang.iterable.*
                         import lang.integer_ext

                         class MyIterator \{ pos thing }
                             is Iterator
                             method nextIfNone: block
                                self hasNext
                                    ifTrue: \{ pos = pos integerAdd: 1.
                                               thing at: pos }
                                    ifFalse: block!
                             method hasNext
                                pos < thing size!
                         end

                         class MyIterable \{ a b c }
                             is Iterable
                             method iterator
                                 MyIterator pos: 0 thing: self!
                             method at: index
                                 index is 1 ifTrue: \{ return a }.
                                 index is 2 ifTrue: \{ return b }.
                                 index is 3 ifTrue: \{ return c }!
                             method size
                                 3!
                         end

                         class Main \{}
                             direct method run: command in: system
                                 (MyIterable a: 10 b: 20 c: 30)
                                     do: \{ |each| each debug }!
                         end"
            expect: "#<Integer 10>#<Integer 20>#<Integer 30>"!
end

class TestTranspilePreludeObject { assert system }
    is TranspilerTest

    method test
        self transpile: "import lang.object.Object

                         class Main \{ x }
                             is Object
                             direct method run: command in: system
                                 ((self x: 1) == (self x: 2)) debug.
                                 ((self x: 1) == (self x: 1)) debug!
                             method isEquivalent: other
                                 (self x is other x)!
                         end"
            expect: "#<Boolean False>#<Boolean True>"!
end

class TestTranspilePreludeOutput { assert system }
    is TranspilerTest

    method test
        self transpile: "import lang.output_ext
                         import lang.integer_ext

                         class Main \{ x }
                             direct method run: command in: system
                                 system output println: \"Hello World!\".
                                 system output print: 42!
                         end"
            expect: "Hello World!\n42"!
end

class TestTranspilePreludeStringOutput { assert system }
    is TranspilerTest

    method test
        self transpile: "import lang.stringOutput.StringOutput

                         class Main \{}
                             direct method run: command in: system
                                 (StringOutput with: \{ |out|
                                                        out print: \"O\".
                                                        out print: \"k\".
                                                        out print: \"!\" })
                                     debug!
                         end"
            expect: "#<String Ok!>"!
end

class TestTranspileInterface { assert system }
    is TranspilerTest

    method testInterfaceDirect
        self transpile: "interface MyInterface
                             direct method boop
                                 self ding!
                             direct method ding
                                 42!
                         end
                         class Main \{}
                             direct method run: command in: system
                                 MyInterface boop debug!
                         end"
            expect: "#<Integer 42>"!

    method testInterfaceInherited
        self transpile: "interface MyInterface
                             direct method new
                                 self _value: 42!
                             method ding
                                 self value!
                         end
                         class MyClass \{ _value }
                             is MyInterface
                             direct method boop
                                 self new!
                             method value
                                 _value!
                         end
                         class Main \{}
                             direct method run: command in: system
                                 MyClass boop ding debug!
                         end"
            expect: "#<Integer 42>"!

    method testInterfaceOverride
        self transpile: "interface MyInterface
                             direct method new
                                 self _value: 42!
                             method ding
                                 self _value!
                         end
                         class MyClass \{ _value }
                             is MyInterface
                             direct method new
                                self _value: 100!
                             direct method boop
                                 self new!
                             method ding
                                 _value integerAdd: 1!
                         end
                         class Main \{}
                             direct method run: command in: system
                                 MyClass boop ding debug!
                         end"
            expect: "#<Integer 101>"!

    method testInterfaceRequired
        self transpile: "interface MyInterface
                             required method foo
                             method bar
                                 self foo!
                         end
                         class MyClass \{}
                             is MyInterface
                             method foo
                                 4102!
                         end
                         class Main \{}
                             direct method run: command in: system
                                 MyClass new bar debug!
                         end"
            expect: "#<Integer 4102>"!
end

class TestTranspileSend { assert system }
    is TranspilerTest

    method test_Send_keyword_keyword
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 (self add: 40 and: 5) debug!
                             direct method add: x and: y
                                 x integerAdd: y!
                        end"
            expect: "#<Integer 45>"!

    method test_Send_eval_order
        self transpile: "class Main \{ out }
                             direct method run: command in: system
                                 (self out: system output) run!
                             method run
                                 (self say: \"1\" return: self)
                                    a: (self say: \"2\")
                                    b: (self say: \"3\")
                                    c: (self say: \"4\")!
                             method say: x
                                 self say: x return: x!
                             method say: x return: y
                                 out writeString: x.
                                 y!
                             method a: a b: b c: c
                                 False!
                       end"
            expect: "1234"!
end

class TestTranspileGlobals { assert system }
    is TranspilerTest

    method test_Define_global_with_private_slots
        self transpile: "class HasPrivates \{ _private1 _private2 }
                             direct method new
                                 self _private1: \"1\"
                                      _private2: \"2\"!
                             method toString
                                 \"a = \{_private1}, b = \{_private2\}\"!
                         end
                         define ThisHasPrivates HasPrivates new!
                         class Main \{\}
                             direct method run: command in: system
                                 system output
                                     writeString: ThisHasPrivates toString!
                         end"
            expect: "a = 1, b = 2"!

    method test_Define_global_dictionary
        self transpile: "import lang.dictionary_target.Dictionary
                         define Dict \{ \"a\" -> \"A\", \"b\" -> \"B\" \}!
                         class Main \{\}
                             direct method run: command in: system
                                 system output
                                     writeString: (Dict at: \"a\").
                                 system output
                                     writeString: (Dict at: \"b\")!
                         end"
            expect: "AB"!

    method test_Define_global_interface
        self transpile: "import lang.any.Any
                         define X Any!
                         class Main \{}
                             direct method run: command in: system
                                 system output writeString: X name!
                         end"
            expect: "Any"!

    method test_Define_global_array
        self transpile: "define MyArray [1,2,3]!
                         class Main \{}
                             direct method run: command in: system
                                 MyArray debug!
                         end"
            expect: "[#<Integer 1>, #<Integer 2>, #<Integer 3>]"!

    method test_Define_global_nested_array
        self transpile: "define MyArray [[1],[[1]],[[[1]]]]!
                         class Main \{}
                             direct method run: command in: system
                                 MyArray debug!
                         end"
            expect: "[[#<Integer 1>], [[#<Integer 1>]], [[[#<Integer 1>]]]]"!

    method test_Define_global_boolean
        self transpile: "define MyBoolean True!
                         class Main \{}
                             direct method run: command in: system
                                 MyBoolean debug!
                         end"
            expect: "#<Boolean True>"!

    method test_Define_global_class_instance
        self transpileWithPrelude:
            "class MyClass \{ x y }
                 method value
                     x integerAdd: y!
             end

             define MyValue MyClass x: 40 y: 1202!

             class Main \{}
                 direct method run: command in: system
                     MyValue value debug.
                     MyValue x debug!
             end"
                expect: "#<Integer 1242>#<Integer 40>"!

    method test_Define_depends_on_class_defined_after
        self transpile: "define A_Definition A_Class status: \"yes!\"!
                         class A_Class \{ status }
                             method ok status!
                         end
                         class Main \{}
                             direct method run: command in: system
                                 system output
                                     writeString: (self ok: A_Definition)!
                             direct method ok: x
                                 x ok!
                         end"
            expect: "yes!"!

    method test_Define_global_float
        self transpile: "define MyFloat 12.34!
                         class Main \{}
                             direct method run: command in: system
                                 MyFloat debug!
                         end"
            expect: "#<Float 12.34>"!

    method test_Define_global_integer
        self transpile: "define MyInteger 1234!
                         class Main \{}
                             direct method run: command in: system
                                 MyInteger debug!
                         end"
            expect: "#<Integer 1234>"!

    method test_Define_global_selector
        self transpile: "define MySelector #foobar!

                         class Main \{}
                             direct method run: command in: system
                                 MySelector debug!
                         end"
            expect: "#<Selector foobar>"!

    method test_Define_global_string
        self transpile: "define MyString \"foobar\"!
                         class Main \{}
                             direct method run: command in: system
                                 MyString debug!
                         end"
            expect: "#<String foobar>"!

    method test_Undefined_variable
        self transpile: "class Main \{\}
                             direct method run: command in: system
                                 ThisIsUndefined bang!
                         end"
            expectCompilerError: "Undefined variable: ThisIsUndefined
001 class Main \{}
002                              direct method run: command in: system
003                                  ThisIsUndefined bang!
                                     ^^^^^^^^^^^^^^^ Undefined variable: ThisIsUndefined
004                          end
"!

    method test_Undefined_import
        self transpile: "import lang.list.ThisIsUndefinedToo
                         class Main \{\}
                             direct method run: command in: system
                                 ThisIsUndefinedToo bang!
                         end"
            expectCompilerError: "Undefined variable: ThisIsUndefinedToo
001 import lang.list.ThisIsUndefinedToo
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Undefined variable: ThisIsUndefinedToo
002                          class Main \{\}
003                              direct method run: command in: system
004                                  ThisIsUndefinedToo bang!
005                          end
"!

    method test_Undefined_external
        self transpile: "import lang.list
                         class Main \{\}
                             direct method run: command in: system
                                 list.ThisIsReallyUndefined bang!
                         end"
            expectCompilerError: "Undefined variable: ThisIsReallyUndefined
002                          class Main \{}
003                              direct method run: command in: system
004                                  list.ThisIsReallyUndefined bang!
                                          ^^^^^^^^^^^^^^^^^^^^^ Undefined variable: ThisIsReallyUndefined
005                          end
"!

    method test_Put_at_cannot_modify_global_nested_array
        self transpile: "define ThisIsStatic [1, [2], 3]!
                         class Main \{}
                             direct method run: command in: system
                                 let box = ThisIsStatic at: 2.
                                 box put: 0 at: 2.
                                 system output writeString: \"OOPS MODIFIED A GLOBAL!\"!
                         end"
            expectError: "PANIC: Cannot modify constant object!
Backtrace:
  2: Array#put:at:
  1: Main classOf#run:in:
"!

    method test_Put_at_cannot_modify_global_ByteArray
        self transpile: "define ThisIsStatic [ByteArray new: 1]!
                         class Main \{}
                             direct method run: command in: system
                                 let bytes :: ByteArray = ThisIsStatic at: 1.
                                 bytes put: 0 at: 1.
                                 system output writeString: \"OOPS MODIFIED A GLOBAL!\"!
                         end"
            expectError: "PANIC: Cannot modify constant object!
Backtrace:
  2: ByteArray#put:at:
  1: Main classOf#run:in:
"!

    method test_Cannot_modify_global_instances
        self transpile: "import lang.object.Object
                         class Counter \{ value }
                             method inc
                                 value = value integerAdd: 1!
                         end
                         define MyCounter
                             Counter value: 0!
                         class Main \{}
                             direct method run: command in: system
                                 MyCounter inc.
                                 system output writeString: \"OOPS MODIFIED A GLOBAL!\"!
                         end"
            expectError: "PANIC: Cannot modify constant object!
Backtrace:
  2: Counter#inc
  1: Main classOf#run:in:
"!

    method test_At_put_cannot_modify_global_nested_array
        self transpile: "define ThisIsStatic [[1], 2, 3]!
                         class Main \{}
                             direct method run: command in: system
                                 let box = ThisIsStatic at: 1.
                                 box at: 1 put: 0.
                                 system output writeString: \"OOPS MODIFIED A GLOBAL!\"!
                         end"
            expectError: "PANIC: Cannot modify constant object!
Backtrace:
  2: Array#at:put:
  1: Main classOf#run:in:
"!
end

class TestTranspileSelf { assert system }
    is TranspilerTest

    method testSelf
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 self foo debug!
                             direct method foo
                                 142!
                         end"
            expect: "#<Integer 142>"!

    method testSelfClass
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 self new foo debug!
                             method foo
                                 Self bar!
                             direct method bar
                                 242!
                         end"
            expect: "#<Integer 242>"!
end

class TestTranspileSelfHosted { assert system }
    is TranspilerTest

    method test_Bad_import
        -- The uppercase Integer makes parser want to import
        -- the global integer defined in lang.foo, and module
        -- setup uses lang both as the root and as the file.
        -- It's not perfect, but it's semi-logical. See
        -- https://github.com/nikodemus/foolang/issues/674 for what
        -- future.
        self transpile: "import lang.Integer
                         class Main \{}
                             direct method run: command in: system
                                system exit!
                         end"
            expectCompilerError: (system isUnix
                                      ifTrue: { "Import error: file foo/lang/lang.foo does not exist." }
                                      ifFalse: { "Import error: file foo\\lang\\lang.foo does not exist." })!

    method test_Transpiled_Parser
        self transpileWithPrelude:
            "import impl.parser
             class Main \{\}
                direct method run: command in: system
                     let exprs = parser.Parser parseExpressions: \"123\".
                     system output print: exprs.
                     let defs = parser.Parser parseDefinitions:
\"
interface X
    method y
        42!
end
\".
                     system output print: defs!

             end"
                expect: "[#<SyntaxLiteral 123>][#<SyntaxInterface X>]"!

    method test_Transpiled_SyntaxPrinter
        self transpileWithPrelude:
            "import impl.syntaxPrinter
             import impl.syntax
             class Main \{\}
                 direct method run: command in: system
                     let tree = syntax.SyntaxBinary
                          receiver: (syntax.SyntaxLiteral value: 20)
                          selector: #+
                          argument: (syntax.SyntaxLiteral value: 22)
                          source: \"20+22\".
                      syntaxPrinter.SyntaxPrinter
                          print: tree
                          to: system output!
             end"
            expect: "20 + 22"!

    method test_Transpiled_evaluator
        self transpileWithPrelude:
            "import impl.environment.Environment
             class Main \{\}
                 direct method run: command in: system
                     let tests = [
                                    [[\"float-literal.test\"], \"float-literal.test\"],
                                    [[\"message-to-float.test\"], \"message-to-float.result\"],
                                    [[\"class-classOf.def\", \"class-classOf.test\"], \"class-classOf.result\"]
                                 ].
                     let root = system files / \"foo/tests/self-hosting\".
                     tests do: \{ |eachTest|
                                    let sources = eachTest first.
                                    let env = Environment new.
                                    sources butlast
                                        do: \{ |eachDef|
                                               env load: (root / eachDef) readString \}.
                                    let script = (root / sources last) readString trim.
                                    let res = (env eval: script) displayString.
                                    let expect = (root / eachTest second) readString trim.
                                    res == expect
                                        ifFalse: \{ Error raise: \"FROM \{sources} EXPECTED:
\{script}
  --->
\{expect displayString}
GOT:
\{res displayString}
\"} }.
                     system output print: #ok!
             end"
            expect: "#ok"!
end

class TestTranspileBacktrace { assert system }
    is TranspilerTest

    method testBacktraceNoMethod
        self transpile: "interface Aux
                             direct method ok2
                                 self oops!
                         end
                         class Main \{}
                             is Aux
                             direct method run: command in: system
                                 self ok!
                             direct method ok
                                 self ok2!
                         end"
            -- This gets the "instance of ..." message because Main is
            -- not an object, so this is the panic from the runtime
            -- instead of a DoesNotUnderstand.
            expectError: "PANIC: Instances of Main classOf do not understand: #oops
Backtrace:
  3: Aux interface#ok2 (Main classOf)
  2: Main classOf#ok
  1: Main classOf#run:in:
"!
end

class TestTranspileClass { assert system }
    is TranspilerTest

    method test_Runtime_class_instances
        self transpile:
            "import lang.output_ext
             import lang.selector_target_ext
             import lang.array_target_ext

             class BlockMethod \{ selector block \}
                 method invoke: args on: receiver
                     block apply: ([receiver] append: args)!
             end

             class Main \{\}
                  direct method run: command in: system
                      self testSlotlessIn: system.
                      self testOneSlotIn: system.
                      self testThreeSlotsIn: system!

                  direct method testOneSlotIn: system
                      let layout = Layout new: 1.
                      let testMetaclass
                        = Class
                            subclass: \"*TestSlotsMetaclass\"
                            interfaces: []
                            methods: [(BlockMethod
                                        selector: (#new:)
                                        block: \{ |r a|
                                                  layout makeInstanceOf: r
                                                         with: a })].
                      let testClass
                        = testMetaclass
                            new: \"*TestSlotsClass\"
                            layout: layout
                            interfaces: []
                            methods: [(BlockMethod
                                        selector: #ping
                                        block: \{ |r|
                                                   [layout at: 1 in: r] })].
                      system output print: (testClass new: 123) ping!

                  direct method testThreeSlotsIn: system
                      let layout = Layout new: 3.
                      let testMetaclass
                        = Class
                            subclass: \"*TestSlotsMetaclass\"
                            interfaces: []
                            methods: [(BlockMethod
                                        selector: (#a:b:c:)
                                        block: \{ |r a b c|
                                                  layout makeInstanceOf: r
                                                         with: a
                                                         with: b
                                                         with: c })].
                      let testClass
                        = testMetaclass
                            new: \"*TestSlotsClass\"
                            layout: layout
                            interfaces: []
                            methods: [(BlockMethod
                                        selector: #ping
                                        block: \{ |r|
                                                  [layout at: 1 in: r,
                                                   layout at: 2 in: r,
                                                   layout at: 3 in: r] })].
                      system output print: (testClass a: 10 b: 20 c: 30) ping!

                  direct method testSlotlessIn: system
                      let layout = Layout empty.
                      let testMetaclass
                        = Class
                            subclass: \"*TestMetaclass\"
                            interfaces: []
                            methods: [(BlockMethod
                                        selector: (#new)
                                        block: \{ |r|
                                                  layout makeInstanceOf: r })].
                      let testClass
                        = testMetaclass
                            new: \"*TestClass\"
                            layout: layout
                            interfaces: []
                            methods: [(BlockMethod
                                        selector: #ping
                                        block: \{ |r|
                                                  #pong })].
                      system output print: testClass new ping!
             end"
            expect: "#pong[123][10, 20, 30]"!
end

class TestTranspileSelector { assert system }
    is TranspilerTest

    method test
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 #foo debug.
                                 (#name sendTo: #bar with: []) debug!
                        end"
            expect: "#<Selector foo>#<String bar>"!
end

class TestTranspileIncludes { assert system }
    is TranspilerTest

    method testArrayIncludes
        self transpile: "class Main \{}
                             direct method run: command in: system
                                (Array includes: [1, 2, 3]) debug.
                                (Array includes: 123) debug!
                         end"
            expect: "#<Boolean True>#<Boolean False>"!
end

class TestTranspileSystem { assert system }
    is TranspilerTest

    method test_System_getenv
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 (system getenv: \"no such variable\") is False
                                     ifTrue: \{ system output writeString: \"undef, \" }.
                                 (String includes: (system getenv: \"PATH\"))
                                     ifTrue: \{ system output writeString: \"path\" }!
                        end"
            expect: "undef, path"!

    method testClock
        self transpile: "class Main \{}
                             -- Just a small smoketest
                             direct method run: command in: system
                                 let clock = system clock.
                                 let t0 = clock seconds.
                                 let n = 0.
                                 let t = clock seconds.
                                 \{ (t0 floatAdd: 0.1) floatLt: t }
                                     whileFalse: \{ clock sleep: 0.1.
                                                    t = clock seconds.
                                                    n = n integerAdd: 1 }.
                                 -- Sleeps may be short, but let's bet on 3
                                 -- consequtive sleeps not being short.
                                 (0 integerLt: n) debug.
                                 (n integerLte: 3) debug.
                                 (t floatLt: (t0 floatAdd: 1.0)) debug!
                          end"
            expect: "#<Boolean True>#<Boolean True>#<Boolean True>"!

    method test_Main_run_in_command_size
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 command size debug!
                         end"
            expect: "#<Integer 0>"!

    method testRandom
        self transpile: "class Main \{}
                            direct method run: command in: system
                                let a = system random integer.
                                let b = system random integer.
                                (a is b) debug!
                        end"
            expect: "#<Boolean False>"!

    method test_System_currentDirectory
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 let path = system currentDirectory / \"foo/foo.foo\".
                                 system output writeString: path pathname.
                                 path exists
                                     ifTrue: \{ system output writeString: \" ok!\" }!
                         end"
            expect: ".//foo/foo.foo ok!"!
end

class TestTranspileExtend { assert system }
    is TranspilerTest

    method testExtend
        self transpile: "class MyClass \{}
                              method bar
                                42!
                         end
                         extend MyClass
                              method foo
                                  self bar integerMul: 2!
                         end
                         class Main \{}
                              direct method run: command in: system
                                  MyClass new foo debug!
                         end"
            expect: "#<Integer 84>"!

    method testExtendBuiltin
        self transpile: "extend Integer
                             method doopdoop
                                 1239812798!
                         end
                         class Main \{}
                             direct method run: command in: system
                                 0 doopdoop debug!
                         end"
            expect: "#<Integer 1239812798>"!

    method testExtendInterface
        self transpile: "interface MyInterface
                         end
                         class MyClass \{}
                              is MyInterface
                              method bar
                                42!
                         end
                         extend MyInterface
                              method foo
                                  self bar integerMul: 2!
                         end
                         class Main \{}
                              direct method run: command in: system
                                  MyClass new foo debug!
                         end"
            expect: "#<Integer 84>"!
end

class TestTranspileTypecheck { assert system }
    is TranspilerTest

    method testIntegerValueOops
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 (1.2::Integer) debug!
                         end"
            expectError: "PANIC: Type error! Wanted: Integer, got: Float
Backtrace:
  1: Main classOf#run:in:
"!

    method testIntegerMethodArgOops
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 self foo: 1.2!
                             direct method foo: x::Integer
                                 x debug!
                         end"
            expectError: "PANIC: Type error! Wanted: Integer, got: Float
Backtrace:
  2: Main classOf#foo:
  1: Main classOf#run:in:
"!

    method testIntegerBlockArgOops
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 \{ |x::Integer| x debug } value: 1.2!
                         end"
            expectError: "PANIC: Type error! Wanted: Integer, got: Float
Backtrace:
  2: Closure#value:
  1: Main classOf#run:in:
"!

    method testInterfaceOops
        self transpile: "interface MyInterface
                         end
                         class Main \{}
                             direct method run: command in: system
                                 42 :: MyInterface value debug!
                         end"
            expectError: "PANIC: Type error! Wanted: MyInterface, got: Integer
Backtrace:
  1: Main classOf#run:in:
"!

    method testLetOops
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 let x :: Integer = 42.12.
                                 x debug!
                         end"
            expectError: "PANIC: Type error! Wanted: Integer, got: Float
Backtrace:
  1: Main classOf#run:in:
"!

    method testAssignOops
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 let x :: Integer = 42.
                                 x = 12.23.
                                 x debug!
                         end"
            expectError: "PANIC: Type error! Wanted: Integer, got: Float
Backtrace:
  1: Main classOf#run:in:
"!

    method testSlotTypeInitOops
        self transpile: "class Main \{ x::Integer }
                             direct method run: command in: system
                                 (self x: 42.42) x debug!
                             method x
                                 x!
                         end"
            expectError: "PANIC: Type error! Wanted: Integer, got: Float
Backtrace:
  2: Main classOf#x:
  1: Main classOf#run:in:
"!

    method testSlotTypeAssignOops
        self transpile: "class Main \{ x::Integer }
                             direct method run: command in: system
                                 (self x: 0) frob debug!
                             method frob
                                 x = 42.123.
                                 x!
                         end"
            expectError: "PANIC: Type error! Wanted: Integer, got: Float
Backtrace:
  2: Main#frob
  1: Main classOf#run:in:
"!

    method testMethodReturnTypeOops
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 self foo debug!
                             direct method foo -> Integer
                                 42.42!
                         end"
            expectError: "PANIC: Type error! Wanted: Integer, got: Float
Backtrace:
  2: Main classOf#foo
  1: Main classOf#run:in:
"!

    method testMethodNonLocalReturnTypeOops
        self transpile: "class Main \{}
                             direct method run: command in: system
                                 self foo debug!
                             direct method foo -> Integer
                                 self bar: \{ return 42.32 }!
                             direct method bar: block
                                 block value.
                                 return 0!
                         end"
            expectError: "PANIC: Type error! Wanted: Integer, got: Float
Backtrace:
  4: Closure#value
  3: Main classOf#bar:
  2: Main classOf#foo
  1: Main classOf#run:in:
"!

    method testBlockReturnTypeOops
        self transpile: "class Main \{}
                             direct method run: command in: system
                                (\{ |a| -> Integer a } value: 42.32) debug!
                         end"
            expectError: "PANIC: Type error! Wanted: Integer, got: Float
Backtrace:
  2: Closure#value:
  1: Main classOf#run:in:
"!

end

class Main {}
    direct method run: cmd in: system
        let tests = {
            "--backtrace" -> TestTranspileBacktrace,
            "--class" -> TestTranspileClass,
            "--extend" -> TestTranspileExtend,
            "--globals" -> TestTranspileGlobals,
            "--includes" -> TestTranspileIncludes,
            "--interface" -> TestTranspileInterface,
            "--panic" -> TestTranspilePanic,
            "--prelude-exception" -> TestTranspilePreludeException,
            "--prelude-filepath" -> TestTranspilePreludeFilePath,
            "--prelude-filestream" -> TestTranspilePreludeFileStream,
            "--prelude-iterable" -> TestTranspilePreludeIterable,
            "--prelude-object" -> TestTranspilePreludeObject,
            "--prelude-output" -> TestTranspilePreludeOutput,
            "--prelude-string-output" -> TestTranspilePreludeStringOutput,
            "--self" -> TestTranspileSelf,
            "--self-hosted" -> TestTranspileSelfHosted,
            "--selector" -> TestTranspileSelector,
            "--send" -> TestTranspileSend,
            "--system" -> TestTranspileSystem,
            "--typecheck" -> TestTranspileTypecheck
        }.
        let all = tests keys sort.
        cmd == []
            ifTrue: { cmd = all }.
        -- Trying to work around Linux CI hosts mysteriously crashing, presumably due to OOM
        -- killer, presumably due to bootstrap implementation leaking memory, presumably due
        -- to circular Rc chains somewhere.
        cmd == ["--fork-all"]
            ifTrue: { all
                          do: { |test|
                                let next = "cargo run -- foo/impl/test_transpile.foo --use=foo/lib -- {test}".
                                system output println: "TEST: {next}".
                                let command = system command: next.
                                system output println: "--test stdout--".
                                system output println: command stdout.
                                system output println: "--test stderr--".
                                system output println: command stderr.
                                command ok
                                    ifFalse: { system exit: 1 } }.
                      system exit }.
        cmd do: { |name|
                  Assert
                      runSuite: ((tests
                                      at: name
                                      ifNone: { Error raise: "Unknown test: {name}" })
                                     system: system)
                      in: system
                      onFailure: { system exit: 1 } }.
        system exit!
end
