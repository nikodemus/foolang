import .environment.Environment
import .parser.Parser
import .utils.Debug
import .syntaxTranslator.SyntaxTranslator
import .syntaxPrinter.SyntaxPrinter
import .cTranspiler.CTranspiler

class Tests { system ok }

    direct method runIn: system
        (self system: system ok: True) run!

    method test: selector
        { Debug print: selector name.
          selector sendTo: self.
          Debug println: " ok" }
            on: Error
            do: { |e|
                  Debug println: " FAILED:\n{e description}".
                  ok = False.
                  return False }.
        True!

    method run
        self
            ; test: #testArray1
            ; test: #testArray2
            ; test: #testArray3
            ; test: #testArray4
            ; test: #testArray5
            ; test: #testArray6
            ; test: #testArray7
            ; test: #test42
            ; test: #testPlus
            ; test: #testPrecedence1
            ; test: #testPrecedence2
            ; test: #testPrefixMethod
            ; test: #testUnaryMethod
            ; test: #testKeywordMethod
            ; test: #testIs
            ; test: #testLet
            ; test: #testParens
            ; test: #testAssign1
            ; test: #testAssign2
            ; test: #testSimpleBlock
            ; test: #testArgBlock
            ; test: #testBlockClosure
            ; test: #testSimpleClass
            ; test: #testClassWithMethod
            ; test: #testSlotAssign
            ; test: #testClassWithPrefixMethod
            ; test: #testTwoClasses
            ; test: #testDefine
            ; test: #testBlockInMethod
            ; test: #testDirectMethod
            ; test: #testReturn
            ; test: #testAstSource
            ; test: #testOutOfOrderDefine
            ; test: #testOutOfOrderClasses
            ; test: #testInterface1
            ; test: #testInterface2
            ; test: #testInterface3
            ; test: #testBacktrace
            ; test: #testString1
            ; test: #testString2
            ; test: #testString3
            ; test: #testComment1
            ; test: #testComment2
            ; test: #testComment3
            ; test: #testComment4
            ; test: #testComment5
            ; test: #testComment6
            ; test: #testComment7
            ; test: #testComment8 -- ; test: #testComment9
            ; test: #testTranspile
               .
        self!

    method checkParsingBy: block for: source
        -- Check Syntax print/parse consistency.
        -- Debug println: "/parse1".
        let syntaxList = block value: source.
        let output = StringOutput new.
        -- Debug println: "/pretty".
        syntaxList do: { |syntax|
                         -- Debug println: "".
                         -- SyntaxPrinter print: syntax to: Output debug.
                         output print: syntax toString }.
        let printed = output content.
        -- Debug println: "/parse2 + compare".
        { syntaxList checkEqual: (block value: source) }
            on: Error
            do: { |err|
                  panic "CST print/parse inconsistency!
original:\n{source}
printed:\n{printed}
problem: {err description}" }!

    method parse: source expect: pretty
        -- Checks that parse pretty-prints as expected
        let syntaxList1 = Parser parseMixed: source.
        let syntaxList2 = Parser parseMixed: pretty.
        { syntaxList1 checkEqual: syntaxList2 }
            on: Error
            do: { |err|
                  Error raise: "parse inconsistent with desired pretty-print!
source:\n{source}
pretty:\n{pretty}
problem: {err description}" }.
        let output = StringOutput new.
        syntaxList1 do: { |syntax| output print: syntax toString }.
        let printed = output content.
        printed == pretty
            ifFalse: { Error raise: "print inconsistent with desired pretty-print!
source:\n{source}
printed:\n{printed}
pretty:\n{pretty}" }!

    method eval: exprSource expect: expected
        self checkParsingBy: { |source| Parser parseExpressions: source }
             for: exprSource.
        let result = Environment new eval: exprSource.
        (result == expected)
            ifFalse: { Error raise: "Expected {expected}, got: {result}
from: '{exprSource}'" }!

    method load: defSource eval: exprSource
        -- Debug println: "/parseDef".
        self checkParsingBy: { |source| Parser parseDefinitions: source }
             for: defSource.
        -- Debug println: "/parseExpr".
        self checkParsingBy: { |source| Parser parseExpressions: source }
             for: exprSource.
        let env = Environment new.
        -- Debug println: "/load".
        env load: defSource.
        -- Debug println: "/eval".
        env eval: exprSource!

    method load: defSource eval: exprSource expect: expected
        let result = self load: defSource eval: exprSource.
        (result == expected)
            ifFalse: { Error raise: "Expected {expected}, got: {result}
from: {exprSource}
with: {defSource}" }!

    method load: defSource eval: exprSource expectError: type where: test
        { self load: defSource eval: exprSource }
            on: type
            do: { |err|
                  (test value: err)
                      ifTrue: { return True }
                      ifFalse: { Error raise: "Error did not match expectations: {err description}
from: {exprSource}
with: {defSource}" }}.
        Error raise: "Expected error, didn't get one
from: {exprSource}
with: {defSource}"!

    method testInterface1
        self load: "interface TestInterface1
                        direct method answer
                           42!
                    end"
            eval: "TestInterface1 answer"
            expect: 42!

    method testInterface2
        self load: "interface TestInterface2
                    end"
            eval: "TestInterface2 includes: 42"
            expect: False!

    method testInterface3
        self load: "interface TestInterface3
                        method foo
                            self!
                    end
                    class TestInterface3Impl \{}
                        is TestInterface3
                    end"
            eval: "TestInterface3 includes: (TestInterface3Impl new foo)"
            expect: True!

    method test42
        self eval: "42" expect: 42!

    method testPlus
        self eval: "100 + 1000 + 10 + 1" expect: 1111!

    method testPrecedence1
        self eval: "12 + 10 * 10 - 1" expect: 111!

    method testPrecedence2
        self eval: "let x = -40. let y = -2. x abs + y abs" expect: 42!

    method testPrefixMethod
        self eval: "- 42" expect: -42!

    method testUnaryMethod
        self eval: "- 42 abs" expect: 42!

    method testKeywordMethod
        self eval: "1 to: 10 by: 2" expect: (1 to: 10 by: 2)!

    method testIs
        self eval: "1 is 1" expect: True.
        self eval: "1 is 2" expect: False!

    method testLet
        self eval: "let x = 1. x + x"
             expect: 2!

    method testParens
        self eval: "(1 + 1) * 2"
             expect: 4!

    method testAssign1
        self eval: "let x = 20. x = x + 1. x * 2"
             expect: 42!

    method testAssign2
        self eval: "let y = 0.
                    let x = 20.
                    (let x = 2000. x = x + 100. y = x * 2).
                    x = x + 1. y + x * 2"
            expect: 4242!

    method testSimpleBlock
        self eval: "\{ 32 + 10 } value"
             expect: 42!

    method testArgBlock
        self eval: "\{ |x| x + 1 } value: 41"
             expect: 42!

    method testBlockClosure
        self eval: "let block = (let x = 21. \{ x = x * 2 }).
                    let x = 0.
                    block value. block value"
            expect: 84!

    method testDefine
        self load: "define FourtyTwoForTestDefine
                       42!"
             eval: "FourtyTwoForTestDefine"
             expect: 42!

    method testSimpleClass
        self load: "class MyClass \{ x } is Object end"
             eval: "let c = MyClass x: 42. c x"
             expect: 42.
         self load: "class MyClass \{ x y } is Object end"
             eval: "let c = MyClass x: 40 y: 2. c x + c y"
             expect: 42!

    method testClassWithMethod
        self load: "class MyClass \{ slot }
                        method foo: x
                           slot + x!
                    end"
             eval: "(MyClass slot: 40) foo: 2"
             expect: 42!

    method testSlotAssign
        self load: "class MyClass \{ slot }
                        method bar
                           slot = slot * 2!
                        method foo
                           self bar.
                           slot!
                    end"
             eval: "(MyClass slot: 21) foo"
             expect: 42!

    method testClassWithPrefixMethod
        self load: "class MyClass \{ slot }
                        method prefix%
                            slot * slot!
                    end"
             eval: "%(MyClass slot: -2)"
             expect: 4!

    method testTwoClasses
        self load: "class Class1 \{ slot }
                        is Object
                        method foo: x
                           x bar + slot * 2!
                    end
                    class Class2 \{ slot }
                        is Object
                        method bar
                           slot!
                        method foo: y
                           y foo: self!
                    end"
             eval: "(Class2 slot: 2) foo: (Class1 slot: 20)"
             expect: 42!

    method testBlockInMethod
        self load: "class ClassAA \{ slot }
                        method capture: x
                           \{ x }!
                        method captureSlot
                           \{ slot }!
                        method capture
                           let z = 2.
                           \{ (self captureSlot) value + (self capture: z) value }!
                    end
                    class ClassBB \{ slot }
                        method ctor: x
                           \{ (ClassAA slot: x + slot) }!
                        method run: x
                           (self ctor: x * 2) value capture value!
                    end"
             eval: "(ClassBB slot: 20) run: 10"
             expect: 42!

    method testDirectMethod
        self load: "class ClassDirectMethod \{}
                        direct method gimme1
                            self new gimme2!
                        method gimme2
                            42!
                    end"
             eval: "ClassDirectMethod gimme1"
             expect: 42!

    method testReturn
        self load: "class ReturnTest \{}
                        direct method test: ok
                            ok
                               ifTrue: \{ return 42 }.
                            666!
                    end"
            eval: "ReturnTest test: True"
            expect: 42!

    method testComment1
        -- Prefix comment to let value
        self
            parse: "           let x = -- boop\n 21.     x     *  2"
            expect: "let x = -- boop\n        21.\nx * 2"!

    method testComment2
        -- Suffix comment to let value
        self
            parse: "let x = 21 -- boop\n.\nx * 2"
            expect: "let x = 21. -- boop\nx * 2".
        self
            parse: "let x = 21. -- boop\n\nx * 2"
            expect: "let x = 21. -- boop\nx * 2"!

    method testComment3
        -- Prefix comment in sequence
        self
            parse: "    doo daa.\n    -- boop\n   self bar. \n x * 2"
            expect: "doo daa.\n-- boop\nself bar.\nx * 2"!

    method testComment4
        -- Suffix comment in sequence
        self
            parse: "self bar. -- boop\n x * 2"
            expect: "self bar. -- boop\nx * 2".
        self
            parse: "self bar -- boop\n. x * 2"
            expect: "self bar. -- boop\nx * 2"!

    method testComment5
        -- Prefix comment to class
        self
            parse: "-- boop\n    class   X   \{}   end"
            expect: "-- boop\nclass X \{}\nend\n"!

    method testComment6
        -- Suffix comment to class
        self
            parse: "class   X   \{}   end -- boop"
            expect: "class X \{}\nend -- boop\n"!

    method testComment7
        -- Suffix comment to method signature == prefix comment to body
        self
            parse: "class   X   \{}method bar -- boop\n42!\nend"
            expect: "class X \{}\n    method bar\n        -- boop\n        42!\nend\n"!

    method testComment8
        -- Suffix comment to method body
        self
            parse: "class X \{} method bar\n42! -- boop\nend"
            expect: "class X \{}\n    method bar\n        42! -- boop\nend\n"!

    method testComment9
        -- Prefix comment to method (does not work currently!)
        self
            parse: "class X \{} -- boop\n method bar\n 42!\n end\n"
            expect: "class X \{}\n    -- boop\n    method bar\n        42!\nend\n"!

    method testArray1
        self eval: "[1, 1+1, 3]"
             expect: [1,2,3]!

    method testArray2
        self eval: "[1, 1+1, 3, ]"
             expect: [1,2,3]!

    method testArray3
        self eval: "[, 1, 1+1, 3]"
             expect: [1,2,3]!

    method testArray4
        self eval: "[, 1, 1+1, 3,]"
             expect: [1,2,3]!

    method testArray5
        self eval: "[1]"
             expect: [1]!

    method testArray6
        self eval: "[]"
             expect: []!

    method testArray7
        self eval: "[,]"
             expect: []!

    method testBacktrace
        self load: "class BacktraceTest \{}
                        is Object
                        method bang: block
                           block value!
                        method foo
                            self bang: \{ self nope }!
                        method bar
                           self foo!
                        direct method test
                           self new bar!
                    end"
            eval: "BacktraceTest test"
            expectError: DoesNotUnderstand
            where: { |e|
                     e selector == #nope
                         ifTrue: { let bt = e context backtrace.
                                   let selectors = bt collect: { |f| f selector :: Selector }.
                                   selectors isEquivalent: [#value, #bang:, #foo, #bar, #test] }}!

    method testAstSource
        self load: "class SourceTest \{}
                         is Object
                         method foo
                            let x = 1 + 2.
                            self bar: x
                                 quux: x.
                            self quux.
                            self zot.
                            2 + 3!
                    end"
            eval: "SourceTest new foo"
            expectError: DoesNotUnderstand
            where: { |e|
                     -- FIXME: this is only for "bar:", should include the
                     -- whole selector!
                     e source location == (168 to: 171) } !

    method testOutOfOrderDefine
        self load: "define Two
                       One + One!
                    define One
                       1!"
            eval: "Two"
            expect: 2!

    method testOutOfOrderClasses
        self load: "class Two \{}
                       direct method fini
                          42!
                       method test
                          One new test!
                    end
                    class One \{}
                      method test
                          Two fini!
                    end"
            eval: "Two new test"
            expect: 42!

    method testString1
        self eval: " \"foo\" "
             expect: "foo"!

    method testString2
        self eval: " \"foo\\\"bar\" "
             expect: "foo\"bar"!

    method testString3
        self eval: " \"foo\\nbar\" "
             expect: "foo\nbar"!

    method transpile: string
        let env = Environment new.
        let cst = Parser parseExpressions: string.
        let ast = cst collect: { |syntax|
                                 SyntaxTranslator
                                     translate: syntax
                                     in: env }.
        let c = CTranspiler transpile: ast in: env.
        (system files path: "host/generated_selectors.h")
            forWrite truncateExisting
                createOrOpen: { |f| f writeString: c selectors }.
        (system files path: "host/generated_blocks.c")
            forWrite truncateExisting
                createOrOpen: { |f| f writeString: c blocks }.
        (system files path: "host/generated_main.c")
            forWrite truncateExisting
                createOrOpen: { |f| f writeString: c main }!

    method testTranspile
        self transpile: "let x = 20.
                         let b1 = \{ x + 11 * 2 }.
                         let b2 = \{ let x = 0. b1 value }.
                         let x = 1.
                         b2 value debug"!

end

class Main {}
    direct method run: cmd in: system
        system output
            println: ((Tests runIn: system) ok
                          ifTrue: { "All tests ok!" }
                          ifFalse: { "Tests failed!" })!
end
