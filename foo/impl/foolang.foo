import .environment.Environment
import .parser.Parser
import .utils.Debug
import .syntaxTranslator.SyntaxTranslator
import .syntaxPrinter.SyntaxPrinter
import .cTranspiler.CTranspiler

class TestSelfHosting { system ok }
    is TestSuite

    direct method runIn: system
        let tests = (self system: system ok: True).
        tests doTests: { |each| tests runTest: each }!

    method runTest: selector
        { Debug print: selector name.
          selector sendTo: self.
          Debug println: " ok" }
            on: Error
            do: { |e|
                  Debug println: " FAILED:\n{e description}".
                  ok = False.
                  return False }.
        True!

    method checkParsingBy: block for: source
        -- Check Syntax print/parse consistency.
        -- Debug println: "/parse1".
        let syntaxList = block value: source.
        -- Debug println: "/pretty".
        let output = StringOutput new.
        syntaxList do: { |syntax|
                         SyntaxPrinter print: syntax to: output }.
        let printed = output content.
        -- Debug println: printed.
        -- Debug println: "/parse2 + compare".
        { syntaxList checkEqual: (block value: printed) }
            on: Error
            do: { |err|
                  panic "CST print/parse inconsistency!
original:\n{source}
printed:\n{printed}
problem: {err description}" }!

    method parse: source expect: pretty
        -- Checks that parse pretty-prints as expected
        -- Debug println: "\n/parse source".
        let syntaxList1 = Parser parseMixed: source.
        -- Debug println: "\n/parse pretty".
        let syntaxList2 = Parser parseMixed: pretty.
        -- Debug println: "/check".
        { syntaxList1 checkEqual: syntaxList2 }
            on: Error
            do: { |err|
                  Error raise: "parse inconsistent with desired pretty-print!
source:\n{source}
pretty:\n{pretty}
problem: {err description}" }.
        let printed
            = StringOutput
                  with: { |out|
                          syntaxList1 do: { |syntax| SyntaxPrinter print: syntax to: out } }.
        printed == pretty
            ifFalse: { Error raise: "print inconsistent with desired pretty-print!
source:\n{source}
printed:\n{printed}
pretty:\n{pretty}" }!

    method eval: exprSource expect: expected
        self checkParsingBy: { |source| Parser parseExpressions: source }
             for: exprSource.
        let result = Environment new eval: exprSource.
        (result == expected)
            ifFalse: { Error raise: "Expected {expected}, got: {result}
from: '{exprSource}'" }!

    method eval: exprSource expectError: errorType where: test
        self checkParsingBy: { |source| Parser parseExpressions: source }
             for: exprSource.
        let result = False.
        { result = Environment new eval: exprSource }
            on: errorType
            do: { |e|
                  (test value: e)
                      ifTrue: { return True }
                      ifFalse: { Error raise: "Expected error did not pass test, got: {e}" }}.
        Error raise: "Expected error, got: {result}"!


    method load: defSource eval: exprSource
        -- Debug println: "\n/parseDef".
        self checkParsingBy: { |source| Parser parseDefinitions: source }
             for: defSource.
        -- Debug println: "/parseExpr".
        self checkParsingBy: { |source| Parser parseExpressions: source }
             for: exprSource.
        let env = Environment new.
        -- Debug println: "/load".
        env load: defSource.
        -- Debug println: "/eval".
        env eval: exprSource!

    method load: defSource eval: exprSource expect: expected
        let result = self load: defSource eval: exprSource.
        (result == expected)
            ifFalse: { Error raise: "Expected {expected}, got: {result}
from: {exprSource}
with: {defSource}" }!

    method load: defSource eval: exprSource expectError: type where: test
        { self load: defSource eval: exprSource }
            on: type
            do: { |err|
                  (test value: err)
                      ifTrue: { return True }
                      ifFalse: { Error raise: "Error did not match expectations: {err description}
from: {exprSource}
with: {defSource}" }}.
        Error raise: "Expected error, didn't get one
from: {exprSource}
with: {defSource}"!

    method testInterface1
        self load: "interface TestInterface1
                        direct method answer
                           42!
                    end"
            eval: "TestInterface1 answer"
            expect: 42!

    method testInterface2
        self load: "interface TestInterface2
                    end"
            eval: "TestInterface2 includes: 42"
            expect: False!

    method testInterface3
        self load: "interface TestInterface3
                        method foo
                            self!
                    end
                    class TestInterface3Impl \{}
                        is TestInterface3
                    end"
            eval: "TestInterface3 includes: (TestInterface3Impl new foo)"
            expect: True!

    method test42
        self eval: "42" expect: 42!

    method testPlus
        self eval: "100 + 1000 + 10 + 1" expect: 1111!

    method testPrecedence1
        self eval: "12 + 10 * 10 - 1" expect: 111!

    method testPrecedence2
        self eval: "let x = -40. let y = -2. x abs + y abs" expect: 42!

    method testPrefixMethod
        self eval: "- 42" expect: -42!

    method testUnaryMethod
        self eval: "- 42 abs" expect: 42!

    method testKeywordMethod
        self eval: "1 to: 10 by: 2" expect: (1 to: 10 by: 2)!

    method testIs
        self eval: "1 is 1" expect: True.
        self eval: "1 is 2" expect: False!

    method testLet
        self eval: "let x = 1. x + x"
             expect: 2!

    method testParens
        self eval: "(1 + 1) * 2"
             expect: 4!

    method testAssign1
        self eval: "let x = 20. x = x + 1. x * 2"
             expect: 42!

    method testAssign2
        self eval: "let y = 0.
                    let x = 20.
                    (let x = 2000. x = x + 100. y = x * 2).
                    x = x + 1. y + x * 2"
            expect: 4242!

    method testSimpleBlock
        self eval: "\{ 32 + 10 } value"
             expect: 42!

    method testArgBlock
        self eval: "\{ |x| x + 1 } value: 41"
             expect: 42!

    method testBlockClosure
        self eval: "let block = (let x = 21. \{ x = x * 2 }).
                    let x = 0.
                    block value. block value"
            expect: 84!

    method testDefine
        self load: "define FourtyTwoForTestDefine
                       42!"
             eval: "FourtyTwoForTestDefine"
             expect: 42!

    method testSimpleClass
        self load: "class MyClass \{ x } is Object end"
             eval: "let c = MyClass x: 42. c x"
             expect: 42.
         self load: "class MyClass \{ x y } is Object end"
             eval: "let c = MyClass x: 40 y: 2. c x + c y"
             expect: 42!

    method testClassWithMethod
        self load: "class MyClass \{ slot }
                        method foo: x
                           slot + x!
                    end"
             eval: "(MyClass slot: 40) foo: 2"
             expect: 42!

    method testSlotAssign
        self load: "class MyClass \{ slot }
                        method bar
                           slot = slot * 2!
                        method foo
                           self bar.
                           slot!
                    end"
             eval: "(MyClass slot: 21) foo"
             expect: 42!

    method testClassWithPrefixMethod
        self load: "class MyClass \{ slot }
                        method prefix%
                            slot * slot!
                    end"
             eval: "%(MyClass slot: -2)"
             expect: 4!

    method testTwoClasses
        self load: "class Class1 \{ slot }
                        is Object
                        method foo: x
                           x bar + slot * 2!
                    end
                    class Class2 \{ slot }
                        is Object
                        method bar
                           slot!
                        method foo: y
                           y foo: self!
                    end"
             eval: "(Class2 slot: 2) foo: (Class1 slot: 20)"
             expect: 42!

    method testBlockInMethod
        self load: "class ClassAA \{ slot }
                        method capture: x
                           \{ x }!
                        method captureSlot
                           \{ slot }!
                        method capture
                           let z = 2.
                           \{ (self captureSlot) value + (self capture: z) value }!
                    end
                    class ClassBB \{ slot }
                        method ctor: x
                           \{ (ClassAA slot: x + slot) }!
                        method run: x
                           (self ctor: x * 2) value capture value!
                    end"
             eval: "(ClassBB slot: 20) run: 10"
             expect: 42!

    method testDirectMethod
        self load: "class ClassDirectMethod \{}
                        direct method gimme1
                            self new gimme2!
                        method gimme2
                            42!
                    end"
             eval: "ClassDirectMethod gimme1"
             expect: 42!

    method testReturn
        self load: "class ReturnTest \{}
                        direct method test: ok
                            ok
                               ifTrue: \{ return 42 }.
                            666!
                    end"
            eval: "ReturnTest test: True"
            expect: 42!

    method testComment1
        -- Prefix comment to let value
        self
            parse: "           let x = -- boop\n 21.     x     *  2"
            expect: "let x = -- boop\n        21.\nx * 2"!

    method testComment2
        -- Suffix comment to let value
        self
            parse: "let x = 21 -- boop\n.\nx * 2"
            expect: "let x = 21. -- boop\nx * 2".
        self
            parse: "let x = 21. -- boop\n\nx * 2"
            expect: "let x = 21. -- boop\nx * 2"!

    method testComment3
        -- Prefix comment in sequence
        self
            parse: "    doo daa.\n    -- boop\n   self bar. \n x * 2"
            expect: "doo daa.\n-- boop\nself bar.\nx * 2"!

    method testComment4
        -- Suffix comment in sequence
        self
            parse: "self bar. -- boop\n x * 2"
            expect: "self bar. -- boop\nx * 2".
        self
            parse: "self bar -- boop\n. x * 2"
            expect: "self bar. -- boop\nx * 2"!

    method testComment5
        -- Prefix comment to class
        self
            parse: "-- boop\n    class   X   \{}   end"
            expect: "-- boop\nclass X \{}\nend\n"!

    method testComment6
        -- Suffix comment to class
        self
            parse: "class   X   \{}   end -- boop"
            expect: "class X \{}\nend -- boop\n"!

    method testComment7
        -- Suffix comment to method signature == prefix comment to body
        self
            parse: "class   X   \{}method bar -- boop\n42!\nend"
            expect: "class X \{}\n    method bar\n        -- boop\n        42!\nend\n"!

    method testComment8
        -- Suffix comment to method body
        self
            parse: "class X \{} method bar\n42! -- boop\nend"
            expect: "class X \{}\n    method bar\n        42! -- boop\nend\n"!

    method testComment9
        -- Prefix comment to method (does not work currently!)
        self
            parse: "class X \{} -- boop\n method bar\n 42!\n end\n"
            expect: "class X \{}\n    -- boop\n    method bar\n        42!\nend\n"!

    method testComment10
        -- block comment
        self eval: "---
                    This is a test.
                    ---
                    42"
            expect: 42!

    method testComment11
        -- block comment
        self parse: "---\nThis is a test.\n---\n      42"
            expect: "---\nThis is a test.\n---\n42"!

    method testComment12
        -- Line comment without space after
        self eval: "--> 42\n 42"
             expect: 42!

    method testComment13
        -- Block comment without space after
        self eval: "---XXX 42--- 42"
             expect: 42!

    method testComment14
        -- long comment fences
        self eval: "----
                    --- This is a test.
                    ----
                    42"
            expect: 42!

    method testArray1
        self eval: "[1, 1+1, 3]"
             expect: [1,2,3]!

    method testArray2
        self eval: "[1, 1+1, 3, ]"
             expect: [1,2,3]!

    method testArray3
        self eval: "[1, 1+1, 3,]"
             expect: [1,2,3]!

    method testArray4
        self eval: "[1]"
             expect: [1]!

    method testArray5
        self eval: "[]"
             expect: []!

    method testRecord1
        self eval: "\{foo: 42, bar: 123}"
             expect: {foo: 42, bar: 123}!

    method testRecord2
        self eval: "\{foo: 42, bar: 123,}"
             expect: {foo: 42, bar: 123}!

    method testDictionary1
        self eval: "let x = 42. let y = 13. \{ x -> y, y + 1 -> x * 2 }"
             expect: { 42 -> 13, 14 -> 84 }!

    method testDictionary2
        self eval: "let x = 42. let y = 13. \{ x -> y, y + 1 -> x * 2, }"
             expect: { 42 -> 13, 14 -> 84 }!

    method testBacktrace
        self load: "class BacktraceTest \{}
                        is Object
                        method bang: block
                           block value!
                        method foo
                            self bang: \{ self nope }!
                        method bar
                           self foo!
                        direct method test
                           self new bar!
                    end"
            eval: "BacktraceTest test"
            expectError: DoesNotUnderstand
            where: { |e|
                     e selector == #nope
                         ifTrue: { let bt = e context backtrace.
                                   let selectors = bt collect: { |f| f selector :: Selector }.
                                   selectors isEquivalent: [#value, #bang:, #foo, #bar, #test] }}!

    method testAstSource
        self load: "class SourceTest \{}
                         is Object
                         method foo
                            let x = 1 + 2.
                            self bar: x
                                 quux: x.
                            self quux.
                            self zot.
                            2 + 3!
                    end"
            eval: "SourceTest new foo"
            expectError: DoesNotUnderstand
            where: { |e|
                     -- FIXME: this is only for "bar:", should include the
                     -- whole selector!
                     e source location == (168 to: 171) } !

    method testOutOfOrderDefine
        self load: "define Two
                       One + One!
                    define One
                       1!"
            eval: "Two"
            expect: 2!

    method testOutOfOrderClasses
        self load: "class Two \{}
                       direct method fini
                          42!
                       method test
                          One new test!
                    end
                    class One \{}
                      method test
                          Two fini!
                    end"
            eval: "Two new test"
            expect: 42!

    method testString1
        self eval: " \"foo\" "
             expect: "foo"!

    method testString2
        self eval: " \"foo\\\"bar\" "
             expect: "foo\"bar"!

    method testString3
        self eval: " \"foo\\nbar\" "
            expect: "foo\nbar"!

    method testHex1
        self eval: "0xfb"
             expect: 251!

    method testHex2
        self eval: "0xfb4"
             expect: 4020!

    method testHex3
        self eval: "0x0"
             expect: 0!

    method testBinary1
        self eval: "0b101"
             expect: 5!

    method testBinary2
        self eval: "0b001110"
             expect: 14!

    method testBinary3
        self eval: "0x0"
             expect: 0!

    method testSelector1
        self eval: "#foo"
             expect: #foo!

    method testSelector2
        self eval: "#+"
             expect: #+ !

    method testSelector3
        self eval: "#foo:bar:"
             expect: #foo:bar: !

    method transpile: string
        let env = Environment new.
        let cst = Parser parseExpressions: string.
        let ast = cst collect: { |syntax|
                                 SyntaxTranslator
                                     translate: syntax
                                     in: env }.
        let c = CTranspiler transpile: ast in: env.
        (system files path: "host/generated_selectors.h")
            forWrite truncateExisting
                createOrOpen: { |f| f writeString: c selectors }.
        (system files path: "host/generated_blocks.c")
            forWrite truncateExisting
                createOrOpen: { |f| f writeString: c blocks }.
        (system files path: "host/generated_main.c")
            forWrite truncateExisting
                createOrOpen: { |f| f writeString: c main }!

    method testTypeDecl01
        self eval: "42::Integer"
             expect: 42!

    method testTypeDecl02
        self eval: "42::String"
             expectError: TypeError
             where: { |e|
                      e value is 42 and: e expected is String }!

    method testTypeDecl03
        self eval: "let x::Integer = 12. 12 + 30"
             expect: 42!

    method testTypeDecl04
        self eval: "let x::String = 12. 12 + 30"
             expectError: TypeError
             where: { |e|
                      e value is 12 and: e expected is String }!

    method testTypeDecl05
        self eval: "let x::String = \"foo\". x = 123"
             expectError: TypeError
             where: { |e|
                      e value is 123 and: e expected is String }!

    method testTypeDecl06
        self load: "class Foo \{ baz::Integer }
                       method quux
                          baz!
                   end"
            eval: "(Foo baz: 42) quux"
            expect: 42!

    method testTypeDecl07
        self load: "class Foo \{ bar::String }
                    end"
            eval: "Foo bar: 42"
            expectError: TypeError
            where: { |e|
                     e value is 42 and: e expected is String }!

    method testTypeDecl08
        self load: "class Foo \{ bar::String }
                        method boop: x
                            bar = x!
                    end"

            eval: "(Foo bar: \"beep\") boop: 42"
            expectError: TypeError
            where: { |e|
                     e value is 42 and: e expected is String }!

    method testTypeDecl09
        self load: "class Foo \{}
                        direct method bar: x::Integer
                            x + 1!
                    end"
            eval: "Foo bar: 41"
            expect: 42!

    method testTypeDecl10
        self load: "class Foo \{}
                        direct method bar: x::String
                            x at: 1!
                    end"
            eval: "Foo bar: 41"
            expectError: TypeError
            where: { |e|
                     e value is 41 and: e expected is String }!

    method testTypeDecl11
        self load: "class Foo \{}
                        direct method @ x::Integer
                            x + 1!
                    end"
            eval: "Foo @ 41"
            expect: 42!

    method testTypeDecl12
        self load: "class Foo \{}
                        direct method @ x::String
                            x at: 1!
                    end"
            eval: "Foo @ 41"
            expectError: TypeError
            where: { |e|
                     e value is 41 and: e expected is String }!

    method testTypeDecl13
        self load: "class Foo \{}
                        direct method @ x::String
                            let res = (x at: 1) code.
                            x = \"ok\".
                            [res, x]!
                    end"
            eval: "Foo @ \"a\""
            expect: [97, "ok"]!

    method testTypeDecl14
        self load: "class Foo \{}
                        direct method @ x::String
                            let res = (x at: 1) code.
                            x = res.
                            [res, x]!
                    end"
            eval: "Foo @ \"a\""
            expectError: TypeError
            where: { |e|
                     e value is 97 and: e expected is String }!

    method testTypeDecl15
        self eval: "\{ |x::Integer| x } value: 42"
             expect: 42!

    method testTypeDecl16
        self eval: "\{ |x::String| x } value: 42"
             expectError: TypeError
             where: { |e|
                      e value is 42 and: e expected is String }!

    method testTypeDecl17
        self eval: "\{ |x::String| x = x size. x } value: \"ok\""
             expectError: TypeError
             where: { |e|
                      e value is 2 and: e expected is String }!

    method testTypeDecl18
        self load: "class Foo \{}
                       direct method bar -> Integer
                           42!
                    end"
            eval: "Foo bar"
            expect: 42!

    method testTypeDecl19
        self load: "class Foo \{}
                       direct method bar -> Integer
                           \"oops\"!
                    end"
            eval: "Foo bar"
            expectError: TypeError
            where: { |e|
                     e value is "oops" and: e expected is Integer }!

    method testTypeDecl20
        self eval: "\{ -> Integer 42 } value"
             expect: 42!

    method testTypeDecl21
        self eval: "\{ |x| -> Integer x * 2 } value: 21"
             expect: 42!

    method testTypeDecl22
        self eval: "\{ -> String 42 } value"
             expectError: TypeError
             where: { |e|
                      e value is 42 and: e expected is String }!

    method testTypeDecl23
        self eval: "\{ |x| -> String x * 2 } value: 21"
             expectError: TypeError
             where: { |e|
                      e value is 42 and: e expected is String }!

    method testFloat1
        self eval: "123.123"
             expect: 123.123!

    method testFloat2
        self eval: "1.1e2"
             expect: 110.0!

    method testPanic1
        { self eval: "panic \"foo\"" expect: #nothing. return False }
            onPanic: { |p|
                       (p description == "foo") assert.
                       return True }!

    method testExtend1
        self load: "class Foo \{}
                    end
                    extend Foo
                        direct method bar
                           42!
                    end"
            eval: "Foo bar"
            expect: 42!

    method testExtend2
        self load: "class Foo \{}
                    end
                    extend Foo
                        method bar
                           42!
                    end"
            eval: "Foo new bar"
            expect: 42!

    method testExtend3
        self load: "interface Foo
                    end
                    extend Integer
                        is Foo
                        method foofoo
                           123!
                    end"
            eval: "[Foo includes: 42, 42 foofoo]"
            expect: [True, 123]!

    method testTranspile
        self transpile: "let x = 20.
                         let b1 = \{ x + 11 * 2 }.
                         let b2 = \{ let x = 0. b1 value }.
                         let x = 1.
                         b2 value debug"!

end

class Main {}
    direct method run: cmd in: system
        system output
            println: ((TestSelfHosting runIn: system) ok
                          ifTrue: { "All tests ok!" }
                          ifFalse: { "Tests failed!" })!
end
