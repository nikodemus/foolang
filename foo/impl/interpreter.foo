import .environment.Environment
import .utils.FileModuleDictionary
import .ast.AstClass
import .ast.AstSlot

class Delegator { target }
    method selector
        #perform:with:!

    method invoke: args on: _receiver
        args first sendTo: target
                   with: args second!

    method isRequired
        False!
end

---
TODO:
- Would be cleaner if AstClass linked directly to the generated class: the
  delegation block could then fetch the delegate from the receiver.
---

extend AstClass
    method delegateTo: builtin
        self __addDirectMethod: (Delegator target: builtin)!
end

class AllInterpreterBuiltins { env }
    direct method redefineIn: env
        (self env: env)
            redefineAll!

    method redefineAll
        self
            ; redefine: Array
            ; redefine: ByteArray
            ; redefine: Boolean
            ; redefine: Character
            ; redefine: Class
            ; redefine: Closure
            ; redefine: Clock
            ; redefine: False
            ; redefine: File
            ; redefine: FilePath
            ; redefine: FileStream
            ; redefine: Float
            ; redefine: Input
            ; redefine: Integer
            ; redefine: Layout
            ; redefine: Object
            ; redefine: Output
            ; redefine: Record
            ; redefine: System
            ; redefine: Selector
            ; redefine: String
            ; redefine: Time
            ; redefine: True!

    method redefine: builtin
        -- Output debug println: "redefining: {builtin name}".
        -- Creating the class is easy..
        --
        -- More work: define explicit wrapper methods for the builtin
        -- methods, so that their return values get wrapped as well.
        --
        -- More work: the interpreter needs to create instances of these
        -- classes for constants.
        --
        -- Then instead of this implicit creation this will replace
        -- the list of AstBuiltins in environment.foo.
        --
        -- Easy, Simple Matter of Programming!
        --
        -- This gets us through loading prelude, but breaks on
        -- first method call to one of these.
        --
        -- ...which is Array #of:new:value: when trying to
        -- run hello_dict.foo.
        --
        -- And then starting from Array it's time to add the methods.
        let theClass = AstClass
                           name: builtin name
                           slots: [AstSlot name: "secret" index: 1 type: builtin]
                           interfaces: []
                           env: env
                           isBuiltin: True.
        theClass directMethods: List new.
        theClass instanceMethods: List new.
        theClass delegateTo: builtin!
end

class Interpreter { system }
    direct method run: program in: system with: args
        let modules = FileModuleDictionary
                          new: { "lang"     -> system files / "foo/lang",
                                 "impl"     -> system files / "foo/impl",
                                 "lib"      -> system files / "foo/lib",
                                 "examples" -> system files / "foo/examples" }.
        let source = (system files / program) readString.
        let builtinEnv = Environment modules: modules
                             -- These are things defined in the prelude.
                             ; removeBuiltins: [
                                 "Any",
                                 "DoesNotUnderstand",
                                 "Error",
                                 "List",
                                 "Object",
                                 "TypeError" ].
        -- These are the actual builtins. We need to replace AstBuiltins with fresh
        -- AstClasses so that the host environment stays separate from the
        -- interpreter.
        --
        -- One this is done the AstClass definitions can move to Environment
        -- instead, and we can get rid of the AstBuiltins, which were a dodgy
        -- shortcut for referring to the host environment.
        AllInterpreterBuiltins redefineIn: builtinEnv.
        let env = builtinEnv
                      ; importPrelude: ["lang", "prelude"]
                      ; load: source.
        let main = env global: "Main".
        main eval run: args in: system!
end
