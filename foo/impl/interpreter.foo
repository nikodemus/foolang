import .environment.Environment
import .utils.FileModuleDictionary
import .ast.AstClass
import .ast.AstSlot

class BuiltinMethodWrapper { selector block }
    direct method method: selector returns: astClass
        self selector: selector
             block: { |this args|
                      Output debug println: "method: {selector}".
                      astClass eval
                          secret: (selector
                                       sendTo: this secret
                                       with: args) }! -- FIXME: should map to secrets!

    direct method method: selector
        self selector: selector
             block: { |this args|
                      Output debug println: "method: {selector}".
                      selector
                          sendTo: this secret
                          with: args. -- FIXME: should map to secrets!
                      this }!

    direct method ctor: selector returns: builtin
        self selector: selector
             block: { |this args|
                      Output debug println: "ctor: {selector}".
                      this secret: (selector
                                        sendTo: builtin
                                        with: args) }! -- FIXME: should map to secrets!

    method invoke: args on: receiver
        block value: receiver value: args!

    method isRequired
        False!
end

---
TODO:
- AstInterpreter needs wrap constants.
- AstInterpreter Main needs to also have the command and system wrapped.
- Would be cleaner if AstClass linked directly to the generated class.
- AstInterpreter needs to be careful about `is`.
---

extend AstClass
    method defineDirectMethod: selector as: block
        self __addDirectMethod: (BuiltinMethodWrapper
                                     selector: selector
                                     block: block)!

    method defineInstanceMethod: selector as: block
        self __addInstanceMethod: (BuiltinMethodWrapper
                                       selector: selector
                                       block: block)!

    method method: selector returns: astClass
        self __addInstanceMethod: (BuiltinMethodWrapper
                                       method: selector
                                       returns: astClass)!

    method method: selector
        self __addInstanceMethod: (BuiltinMethodWrapper
                                       method: selector)!

    method ctor: selector returns: builtin
        self __addDirectMethod: (BuiltinMethodWrapper
                                     ctor: selector
                                     returns: builtin)!
end

class AllInterpreterBuiltins { env }
    direct method redefineIn: env
        (self env: env)
            redefineAll!

    method redefineAll
        let integer = (self redefine: Integer)
                          ; defineInstanceMethod: #debug
                              as: { |this|
                                    Output debug println: "#<Integer secret: {this secret}>".
                                    this }
                          ; yourself.
        (self redefine: Array)
            ; ctor: #of:new:value: returns: Array
            ; ctor: #new: returns: Array
            ; ctor: #new:value: returns: Array
            ; method: #debug
            -- ; method: #at: returns: FUCK
            ; method: #size returns: integer.
        (self redefine: Selector)
            ; defineInstanceMethod: #toSelector
                as: { |this| this }.
        -- FIXME: need to return a wrapped integer!
        self
            ; redefine: ByteArray
            ; redefine: Boolean
            ; redefine: Character
            ; redefine: Class
            ; redefine: Closure
            ; redefine: False
            ; redefine: File
            ; redefine: FilePath
            ; redefine: FileStream
            ; redefine: Float
            ; redefine: Input
            ; redefine: Integer
            ; redefine: Layout
            ; redefine: Object
            ; redefine: Output
            ; redefine: Record
            ; redefine: System
            ; redefine: String
            ; redefine: Time
            ; redefine: True!

    method redefine: builtin
        -- Output debug println: "redefining: {builtin name}".
        -- Creating the class is easy..
        --
        -- More work: define explicit wrapper methods for the builtin
        -- methods, so that their return values get wrapped as well.
        --
        -- More work: the interpreter needs to create instances of these
        -- classes for constants.
        --
        -- Then instead of this implicit creation this will replace
        -- the list of AstBuiltins in environment.foo.
        --
        -- Easy, Simple Matter of Programming!
        --
        -- This gets us through loading prelude, but breaks on
        -- first method call to one of these.
        --
        -- ...which is Array #of:new:value: when trying to
        -- run hello_dict.foo.
        --
        -- And then starting from Array it's time to add the methods.
        let theClass = AstClass
                           name: builtin name
                           slots: [AstSlot name: "secret" index: 1 type: builtin]
                           interfaces: []
                           env: env
                           isBuiltin: True.
        theClass directMethods: List new.
        theClass instanceMethods: List new.
        theClass!
end

class Interpreter { system }
    direct method run: program in: system with: args
        let modules = FileModuleDictionary
                          new: { "lang"     -> system files / "foo/lang",
                                 "impl"     -> system files / "foo/impl",
                                 "lib"      -> system files / "foo/lib",
                                 "examples" -> system files / "foo/examples" }.
        let source = (system files / program) readString.
        let builtinEnv = Environment modules: modules
                             -- These are things defined in the prelude.
                             ; removeBuiltins: [
                                 "Any",
                                 "DoesNotUnderstand",
                                 "Error",
                                 "List",
                                 "Object",
                                 "TypeError" ].
        -- These are the actual builtins. We need to replace AstBuiltins with fresh
        -- AstClasses so that the host environment stays separate from the
        -- interpreter.
        --
        -- One this is done the AstClass definitions can move to Environment
        -- instead, and we can get rid of the AstBuiltins, which were a dodgy
        -- shortcut for referring to the host environment.
        AllInterpreterBuiltins redefineIn: builtinEnv.
        let env = builtinEnv
                      ; importPrelude: ["lang", "prelude"]
                      ; load: source.
        let main = env global: "Main".
        main eval run: args in: system!
end
