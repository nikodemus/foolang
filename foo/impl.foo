---
Ok, I like this context and process stuff.
---

class Process { localVariables }
end

class AstContext {
        sender         -- context which activated this one
        receiver       -- value of self
        frame          -- arguments to method/block and local variables
        astMethod      -- executing method
        astReturn      -- block to excute to return from this context
        astClosure     -- current AstBlockClosure or False
    }
    method at: offset in: frameNumber
        frameNumber > 1
            ifTrue: { sender at: offset in: frameNumber - 1 }
            ifFalse: { frame at: offset }
    method put: value at: offset in: frameNumber
        frameNumber > 1
            ifTrue: { sender put: value at: offset in: frameNumber - 1 }
            ifFalse: { frame put: value at: offset }
end

class AstBlockClosure {
        outerContext
        block
    }
    method apply: arguments with: context in: process
        let frame = Array new: block frameSize.
        let nArgs = arguments size.
        block argumentCount == nArgs
            ifFalse: { Error raise: "Block argument count mismatch!" }.
        1 to: nArgs
          do: { |i| frame put: (arguments at: i) at: i }.
        block body
            evalWith: (AstContext
                         sender: context sender
                         receiver: context receiver
                         frame: frame
                         astMethod: context astMethod
                         astReturn: outerContext astReturn
                         astClosure: self)
            in: process
end

class AstSend {
        astReceiver
        selector
        astArguments
    }
    method evalWith: context in: process
        let receiver = astReceiver evalWith: context in: process.
        let astMethod = receiver astMethod: selector.
        let frame = Array new: code frameSize.
        let nArgs = astArguments size.
        astMethod argumentCount == nArgs
            ifFalse: { panic "method Argument count mismatch!" }.
        1 to: nArgs
          do: { |i|
                let arg = (astArguments at: i)
                              evalWith: context
                              in: process.
                frame put: arg at: i }.
        astMethod
            evalWith: (AstContext
                         sender: context
                         receiver: receiver
                         frame: frame
                         astMethod: astMethod
                         astReturn: { |value| return value }
                         astClosure: False)
            in: process.
end

class AstBlock { argumentCount frameSize body }
    method evalWith: context in: process
        AstBlockClosure
            context: context
            block: self
end

class AstMethod { selector argumentCount frameSize body }
    method evalWith: context in: process
        body evalWith: context in: process
end

class AstSelf {}
    method evalWith: context in: process
        context receiver
end

class AstReturn { value }
    method evalWith: context in: process
        context astReturn value: (value evalWith: context in: process)
end

class AstDynamicRef { index }
    method evalWith: context in: process
        process localStorage at: index
end

class AstLocalRef { frame index closedOver }
    method evalWith: context in: process
        closedOver
            ifTrue: { context astClosure outerContext
                          at: index
                          in: frame }
            ifFalse: { context
                           at: index
                           in: frame }
end

class AstLocalSet { frame index closedOver ast }
    method evalWith: context in: process
        let value = ast evalWith: context in: process.
        closedOver
            ifTrue: { context astClosure outerContext
                          put: value
                          at: index
                          in: frame }
end


class AstLocalBind { index value body }
    method evalWith: context in: process
        context frame
            put: (value evalWith: context in: process)
            at: index.
        body evalWith: context in process.
end

class AstDynamicBind { index value body }
    method evalWith: context in: process
        let oldValue = process localStorage at: index.
        { process localStorage
              put: (value evalWith: context in: process)
              at: index.
          body evalWith: context in: process }
        finally: { process localStorage
                       put: oldValue
                       at: index }
end

-- OLD


class Context { stack }
    class method new
        self stack: List from: [List new]
    method at: index in: frame
        (stack at: frame) at: index
    method add: value
        (stack at: 1) add: value
end

interface Expr
    required method evalWith: context
end

class Constant { value }
    is Expr
    method evalWith: context
        value.
end

class Bind { value body }
    is Expr
    method evalWith: context
        context pushValue: (value evalWith: context).
        body evalWith: context
end

class Variable { frame index }
    is Expr
    method evalWith: context
        context at: index in: frame
end

class Send { receiverExpr selectorExpr argumentExprs }
    is Expr
    method evalWith: context
        (selectorExpr evalWith: context)
            sendTo: (receiverExpr evalWith: context)
            with: (argumentExprs collect: { |arg| arg evalWith: context })
end

class AstTest {}
    class method run
        (Send receiverExpr: (Constant value: 40)
             selectorExpr: (Constant value: "+")
             argumentExprs: [(Constant value: 2)])
        evalWith: Context new
end

interface Binding
    required method at: offset in: frame
end

class VariableBinding { name next }
    is Binding
    method at: offset in: frame
        Variable frame: frame offset: offset
end

class ConstantBinding { name value next }
    is Binding
    method at: offset in: frame
        Constant value: value
end

class Environment { bindings parent }
    class method new
        self bindings: False parent: False
    method reference: name
        self reference: name frame: 0
    method reference: name frame: frame
        -- FIXME:
        -- if we're in a block AND the variable is not local
        -- then we mark it as closed over
        let offset = bindings position: { |binding| binding name == name }.
        offset is False
            ifTrue: { return parent reference: name frame: frame + 1 }.
        (bindings at: offset) at: offset in: frame
    method addVariable: name
        Environment bindings: (bindings copy add: (VariableBinding name: name))
                    parent: parent
end

interface Syntax
    required method translateIn: environment
end

class Literal { value }
    is Syntax
    method translateIn: environment
        Constant value: value
end

class LetSyntax { name value body }
    is Syntax
    method translateIn: environment
        Bind value: value translateIn: environment
             body: (body translateIn: (environment extend: name))
end

class Reference { name }
    is Syntax
    method translateIn: environment
        environment reference: name
end

class PrefixSend { receiver selector }
    is Syntax
    method translateIn: environment
        Send receiverExpr: (receiver translateIn: environment)
             selectorExpr: (Constant value: "prefix{selector}")
             argumentExprs: []
end

class UnarySend { receiver selector }
    is Syntax
    method translateIn: environment
        Send receiverExpr: (receiver translateIn: environment)
             selectorExpr: (Constant value: selector)
             argumentExprs: []
end

class BinarySend { receiver selector argument }
    is Syntax
    method translateIn: environment
        Send receiverExpr: (receiver translateIn: environment)
             selectorExpr: (Constant value: selector)
             argumentExprs: [argument translateIn: environment]
end

class CstTest {}
    class method run
        self new
            ; test1
            ; test2
    method makeAddition
        BinarySend receiver: (Literal value: 40) selector: "+" argument: (Literal value: 2)
    method negate: receiver
        PrefixSend receiver: receiver selector: "-".
    method asFloat: receiver
        UnarySend receiver: receiver selector: "asFloat".
    method run: cst
        (cst translateIn: Environment new) evalWith: (Context new)
    method test1
        self run: self makeAddition run
    method test2
        self run: (self negate: self makeAddition)
    method test3
        self run: (self asFloat: (self negate: self makeAddition))
    method test4
        self run: (LetSyntax
                       name: "a"
                       value: (Literal value: 40)
                       body: (BinarySend
                                  receiver: (Reference name: "a")
                                  selector: "+"
                                  argument: (Literal value: 2)))
    method test5
        self run: (UnarySend receiver: (BlockSyntax parameters: []))
end
