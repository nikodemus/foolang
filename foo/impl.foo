---
Ok, I like this context and process stuff.

However: note that thisContext type thing is very leaky: using it you can get
access to object you weren't supposed to have -- so it should be hidden behind
System... and right now I'm not exposing it at all.

AstContext and friends aren't quite as powerful as a VM context,
but almost:

- CAN do dynamic variables
- CAN do backtraces
- CAN do debug, edit, continue
- CAN do exceptions (though don't need to, necessarily)
- NOPE for tco, backtracking, callcc, process persistence, coroutines
  (part of the interpreter state is on host stack in this setup!)

--> So this is good enough for now, plan being:
    - source -> Syntax
    - Syntax -> Expr
    - Expr eval
    - Expr to C/Rust/Bitcode -> self-hosted native interpreter

This will take me far enough right now.
---

class Process { localVariables }
end

class RestartMarker {}
end

define NoReturn
    { panic "No return continuation!" }
end

define DeadReturn
    { panic "Cannot return from a dead context!" }
end

class AstContext {
        sender         -- context which activated this one
        receiver       -- value of self
        frame          -- arguments to method/block and local variables
        astMethod      -- executing method
        astClosure     -- current AstBlockClosure or False
        returnCont
    }

    direct method sender: sender
                 receiver: receiver
                 frame: frame
                 astMethod: astMethod
                 astClosure: astClosure
        self
            sender: sender
            receiver: receiver
            frame: frame
            astMethod: astMethod
            astClosure: astClosure
            returnCont: NoReturn

    method at: index inFrame: frameNumber
        frameNumber > 1
            ifTrue: { sender at: index in: frameNumber - 1 }
            ifFalse: { frame at: index }

    method put: value at: index inFrame: frameNumber
        frameNumber > 1
            ifTrue: { sender put: value at: index in: frameNumber - 1 }
            ifFalse: { frame put: value at: index }

    method _runIn: process
        {
            returnCont is NoReturn
                ifTrue: { returnCont = { |value| return value } }.
            self asClosure is False
                ifTrue: { self astMethod body evalWith: self in: process }
                ifFalse: { self asClosure body evalWith: self in: process }
        }
            finally: { returnCont = DeadReturn }

    method runIn: process
        let res = False.
        { res = self _runIn: process.
          res is RestartMarker } whileTrue.
        astClosure is False
            ifTrue: { res }
            ifFalse: { astClosure outerContext returnCont value: res }

    method restart
        self returnCont value: RestartMarker
end

class AstBlockClosure {
        outerContext
        block
    }
    method apply: arguments with: context in: process
        let frame = Array new: block frameSize.
        let nArgs = arguments size.
        block argumentCount is nArgs
            ifFalse: { Error raise: "Block argument count mismatch!" }.
        1 to: nArgs
          do: { |i| frame put: (arguments at: i) at: i }.
        (AstContext
               sender: context sender
               receiver: context receiver
               frame: frame
               astMethod: context astMethod
               astClosure: self
               returnCont: outerContext returnCont)
        runIn: process
end

class AstSend {
        astReceiver
        selector
        astArguments
    }
    method evalWith: context in: process
        let receiver = astReceiver evalWith: context in: process.
        let astMethod = receiver astMethod: selector.
        let frame = Array new: code frameSize.
        let nArgs = astArguments size.
        astMethod argumentCount == nArgs
            ifFalse: { panic "method Argument count mismatch!" }.
        1 to: nArgs
          do: { |i|
                let arg = (astArguments at: i)
                              evalWith: context
                              in: process.
                frame put: arg at: i }.

        (AstContext
             sender: context
             receiver: receiver
             frame: frame
             astMethod: astMethod
             astClosure: False)
        runIn: process.
end

class AstBlock { argumentCount frameSize body }
    method evalWith: context in: process
        AstBlockClosure
            context: context
            block: self
end

class AstMethod { selector argumentCount frameSize body }
    method evalWith: context in: process
        body evalWith: context in: process
end

class AstSelf {}
    method evalWith: context in: process
        context receiver
end

class AstReturn { value }
    method evalWith: context in: process
        context astReturn value: (value evalWith: context in: process)
end

class AstDynamicRef { index }
    method evalWith: context in: process
        process localStorage at: index
end

class AstDynamicBind { index value body }
    method evalWith: context in: process
        let oldValue = process localStorage at: index.
        { process localStorage
              put: (value evalWith: context in: process)
              at: index.
          body evalWith: context in: process }
        finally: { process localStorage
                       put: oldValue
                       at: index }
end

class AstLocalRef { frame index closedOver }
    method evalWith: context in: process
        closedOver
            ifTrue: { context astClosure outerContext
                          at: index
                          in: frame }
            ifFalse: { context
                           at: index
                           in: frame }
end

class AstLocalSet { frame index closedOver ast }
    method evalWith: context in: process
        let value = ast evalWith: context in: process.
        closedOver
            ifTrue: { context astClosure outerContext
                          put: value
                          at: index
                          in: frame }
end


class AstLocalBind { index value body }
    method evalWith: context in: process
        context frame
            put: (value evalWith: context in: process)
            at: index.
        body evalWith: context in process.
end

class AstSeq { first next }
    method evalWith: context in: process
        first evalWith: context in: process.
        next evalWith: context in: process.
end

class AstConstantRef { value }
    method evalWith: context in: process cont: cont
        cont value: value
end

-- CST --

interface Binding
    required method at: index in: frame
end

class VariableBinding { name next }
    is Binding
    method ref: index in: frame
        AstLocalRef frame: frame index: index closedOver: False
end

class ConstantBinding { name value next }
    is Binding
    method ref: index in: frame
        AstConstantRef value: value
end

class Environment { bindings parent }
    direct method new
        self bindings: False parent: False
    method reference: name
        (name startsWith: "$")
            ifTrue: { AstDynamicRef
                          index: (self dynamicVariableIndex: name) }
            ifFalse: { self reference: name frame: 1 }
    method reference: name frame: frame
        -- FIXME: closed over variables -- need home information in environment
        -- if we're in a block AND the variable is not local
        -- then we should mark it as closed over
        let index = bindings
                        position: { |binding| binding name == name }
                        ifNone: { return parent reference: name frame: frame + 1 }.
        (bindings at: offset) ref: offset in: frame
    method addVariable: name
        Environment bindings: (bindings copy add: (VariableBinding name: name))
                    parent: parent
    method size
        bindings size
end

interface Syntax
    required method translateIn: environment
end

class SyntaxLiteral { value }
    is Syntax
    method translateIn: environment
        AstConstant value: value
end

class SyntaxLet { name value body }
    is Syntax
    method translateIn: environment
        let astValue = value translateIn: environment.
        (name startsWith: "$")
            ifTrue: { AstDynamicBind
                          index: (environment dynamicVariableIndex: name)
                          astValue: astValue
                          body: (body translateIn: environment) }
            ifFalse: { AstLocalBind
                           index: environment size + 1
                           astValue: astValue
                           body: (body translateIn: (environment addVariable: name)) }.
end

class SyntaxRef { name }
    is Syntax
    method translateIn: environment
        (name startsWith: "$")
            ifTrue: { AstDynamicRef
                          index: (environment dynamicVariableIndex: name) }
            ifFalse: { environment reference: name }
end

class SyntaxPrefixSend { receiver selector }
    is Syntax
    method translateIn: environment
        AstSend astReceiver: (receiver translateIn: environment)
                astSelector: "prefix{selector}"
                astArguments: []
end

class UnarySend { receiver selector }
    is Syntax
    method translateIn: environment
        AstSend astReceiver: (receiver translateIn: environment)
                astSelector: selector
                astArguments: []
end

class BinarySend { receiver selector argument }
    is Syntax
    method translateIn: environment
        AstSend astReceiver: (receiver translateIn: environment)
                astSelector: selector
                astArgument: [argument translateIn: environment]
end

class CstTest {}
    direct method run
        self new
            ; test1
            ; test2
    method makeAddition
        BinarySend receiver: (Literal value: 40) selector: "+" argument: (Literal value: 2)
    method negate: receiver
        PrefixSend receiver: receiver selector: "-".
    method asFloat: receiver
        UnarySend receiver: receiver selector: "asFloat".
    method run: cst
        (cst translateIn: Environment new) evalWith: (Context new)
    method test1
        self run: self makeAddition run
    method test2
        self run: (self negate: self makeAddition)
    method test3
        self run: (self asFloat: (self negate: self makeAddition))
    method test4
        self run: (LetSyntax
                       name: "a"
                       value: (Literal value: 40)
                       body: (BinarySend
                                  receiver: (Reference name: "a")
                                  selector: "+"
                                  argument: (Literal value: 2)))
    method test5
        self run: (UnarySend receiver: (BlockSyntax parameters: []))
end
