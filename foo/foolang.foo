class Debug {}
    class method println: what
        Output debug println: what!
end

class Process {}
    is Object
end

class InterpreterContext {
        sender
        receiver
        frame::Array
    }
    is Object

    class method new: size
        self sender: False
             receiver: False
             frame: (Array new: size value: "<unbound>")!

    method slot: index
        -- FIXME: Replace this with Primitive readSlot: index of: receiver.
        -- which breaks encapsulation. Dammit, so it needs to be:
        --
        --    system primitives readSlot: index of: receiver.
        --
        -- so primitives need to be passed down here. Yuck.
        --
        -- Maybe some of the auth should be statically handled?
        -- Like:
        --
        --    import foolang allowing: Primitive
        --
        -- ?
        receiver __slot: (index - 1)!

    method at: index inFrame: frameNumber
        frameNumber > 1
            ifTrue: { sender at: index inFrame: frameNumber - 1 }
            ifFalse: { frame at: index }!

    method put: value at: index inFrame: frameNumber
        frameNumber > 1
            ifTrue: { sender put: value at: index inFrame: frameNumber - 1 }
            ifFalse: { frame put: value at: index }!
end

class VariableBinding { name index::Integer }
    is Object
    method referenceInFrame: frame
        AstLexicalRef name: name frame: frame index: index!
end

class SlotBinding { name index::Integer }
    is Object
    method referenceInFrame: frame
        AstSlotRef name: name index: index!
end

class FrameAllocation { size::Integer }
    class method new
        -- Debug println: "** frame allocation **".
        self size: 0!
    method nextIndex
        size = size + 1.
        size!
    method index
        size!
end

class Environment { bindings parent allocation globals }
    is Object

    class method new
        Environment
            bindings: List new
            parent: False
            allocation: FrameAllocation new
            globals: Dictionary new!

    method newFrame
        Environment
            bindings: List new
            parent: self
            allocation: FrameAllocation new
            globals: globals!

    method addVariable: name
        Environment
            bindings: (bindings copy
                           add: (VariableBinding
                                     name: name
                                     index: allocation nextIndex))
            parent: parent
            allocation: allocation
            globals: globals!

    method addVariables: names
        let newBindings = bindings copy.
        names do: { |name|
                    newBindings
                        add: (VariableBinding
                                  name: name
                                  index: allocation nextIndex) }.
        Environment
            bindings: newBindings
            parent: parent
            allocation: allocation
            globals: globals!

    method addSlots: names
        let newBindings = bindings copy.
        let slotAllocation = FrameAllocation new.
        names do: { |name|
                    newBindings
                        add: (SlotBinding
                                  name: name
                                  index: slotAllocation nextIndex) }.
        Environment
            bindings: newBindings
            parent: parent
            allocation: allocation
            globals: globals!

    method load: definition
        definition defineIn: self.
        self!

    method eval: string
        let env = Environment
                      bindings: List new
                      parent: False
                      allocation: FrameAllocation new
                      globals: globals.
        let res = False.
        (Parser parse: string)
            do: { |syntax|
                  res = (syntax translateIn: env)
                                evalWith: (InterpreterContext new: env allocation size)
                                in: Process new }.
        res!

    method global: name
        globals at: name
                ifNone: { Error raise: "Unbound variable: {name}" }!

    method reference: name
        self reference: name inFrame: 1!

    method reference: name inFrame: frame::Integer
        let binding = bindings reversed -- SLOW!
                          find: { |binding| binding name == name }
                          ifNone: { parent is False
                                        ifTrue: { return self global: name }
                                        ifFalse: { return parent reference: name inFrame: frame + 1 } }.
        binding referenceInFrame: frame!
end

interface AstObject
end

interface AstNode
    is Object
    method debug
        Debug println: "#<AST {self}>"!
end

class AstConstantRef { value }
    is AstNode
    method evalWith: context in: process
        value!
end

class AstIs { left right }
    is AstNode
    method evalWith: context in: process
        (left evalWith: context in: process)
            is (right evalWith: context in: process)!
end

class AstSeq { first then }
    is AstNode
    method evalWith: context in: process
        first evalWith: context in: process.
        then evalWith: context in: process!
end

class AstSend {
        receiver
        selector
        arguments
    }
    is AstNode

    method evalWith: context in: process
        let object = receiver
                         evalWith: context
                         in: process.
        let arguments = arguments
                            collect: { |arg|
                                       arg
                                           evalWith: context
                                           in: process }.
        let $context = context.
        let $process = process.
        selector sendTo: object with: arguments!
end

define $context
    False!

define $process
    False!

class AstGlobal { name value }
    is AstNode
    method evalWith: context in: process
        value!
end

class AstDefine { name body frameSize }
    is AstNode
    method defineIn: environment
        environment globals
            put: (AstGlobal
                      name: name
                      value: self _eval)
            at: name!
    method _eval
        body evalWith: (InterpreterContext new: frameSize)
             in: Process new!
end

class AstMethod { selector argumentCount body frameSize }
    is Object
    method invoke: arguments on: receiver
        let frame = Array new: frameSize.
        let nArgs = arguments size.
        argumentCount is nArgs
            ifFalse: { Error raise: "Method argument count mismatch!" }.
        1 to: nArgs
          do: { |i| frame put: (arguments at: i) at: i }.
        body
            evalWith: (InterpreterContext
                           sender: $context
                           receiver: receiver
                           frame: frame)
            in: $process!
end

class AstClass { name slots methods }
    is AstNode
    method defineIn: environment
        environment globals
            put: (AstGlobal
                      name: name
                      value: self _eval)
            at: name!
    -- Class methods should be translated in a specific environment
    -- that contains the instance variables.
    method _eval
        Class
            new: name
            slots: (Array from: slots)
            interfaces: ["Object"]
            methods: (Array from: methods)!
    method checkEqualInternal: other
        name checkEqual: other name.
        slots checkEqual: other slots.
        methods checkEqual: other methods!
end

class AstBlockClosure { context block }
    is AstNode
    method value
        self apply: []!
    method value: arg
        self apply: [arg]!
    method apply: arguments
        let frame = Array new: block frameSize.
        let nArgs = arguments size.
        block argumentCount is nArgs
            ifFalse: { Error raise: "Block argument count mismatch!" }.
        1 to: nArgs
          do: { |i| frame put: (arguments at: i) at: i }.
        block body
            evalWith: (InterpreterContext
                           sender: context
                           receiver: context receiver
                           frame: frame)
            in: $process!
end

class AstBlock { body argumentCount frameSize }
    method evalWith: context in: process
        AstBlockClosure
            context: context
            block: self!
    method frameSize
        frameSize!
end

class AstSelfRef {}
    is AstNode
    method evalWith: context in: process
        context receiver!
end

class AstSlotRef { name index::Integer }
    is AstNode
    method evalWith: context in: process
        context slot: index!
end

class AstBindLexical { name index value body }
    is AstNode
    method evalWith: context in: process
        let object = value evalWith: context in: process.
        context
            put: object
            at: index
            inFrame: 1.
        body evalWith: context in: process!
end

class AstLexicalRef { name
                      frame::Integer
                      index::Integer }
    is AstNode
    method evalWith: context in: process
        context at: index inFrame: frame!
end

class AstLexicalSet { name
                      frame::Integer
                      index::Integer
                      value }
    is AstNode
    method evalWith: context in: process
        context
            put: (value evalWith: context in: process)
            at: index
            inFrame: frame!
end

interface Syntax
    is Object
    ---
    method eval
        let env = Environment new.
        (self translateIn: env)
            evalWith: (InterpreterContext new: (env allocation size))
            in: Process new!
    method load
        Environment new load: (self translateIn: Environment new)!
    ---
    method debug
        self toString!
end

class SyntaxLiteral { value }
    is Syntax
    method translateIn: environment
        AstConstantRef value: value!
    method isEquivalent: other
        self value == other value!
    method toString
        value toString!
end

class SyntaxSeq { first then }
    is Syntax
    method translateIn: environment
        -- FIXME: Would be nicer to flatten this out.
        AstSeq
            first: (first translateIn: environment)
            then: (then translateIn: environment)!
    method checkEqualInternal: other
        self first checkEqual: other first.
        self then checkEqual: other then!
    method toString
        "{first}. {then}"!
end

class SyntaxPrefix { receiver selector }
    is Syntax
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: (Selector name: "prefix{selector name}")
                arguments: []!
    method checkEqualInternal: other
        receiver checkEqual: other receiver.
        selector checkEqual: other selector!
    method toString
        "{selector name}{receiver}"!
end

class SyntaxUnary { receiver selector }
    is Syntax
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: selector
                arguments: []!
    method checkEqualInternal: other
        receiver checkEqual: other receiver.
        selector checkEqual: other selector!
    method toString
        "{receiver} {selector name}"!
    method debug
        "({receiver debug} {selector name})"!
end

class SyntaxBinary { receiver selector argument }
    is Syntax
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: selector
                arguments: [argument translateIn: environment]!
    method checkEqualInternal: other
        receiver checkEqual: other receiver.
        selector checkEqual: other selector.
        argument checkEqual: other argument!
    method toString
        "{receiver} {selector name} {argument}"!
    method debug
        "({receiver debug} {selector name} {argument debug})"!
end

class SyntaxKeyword { receiver selector arguments }
    is Syntax
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: selector
                arguments: (arguments
                                collect: { |arg|
                                           arg translateIn: environment })!
    method checkEqualInternal: other
        receiver checkEqual: other receiver.
        selector checkEqual: other selector.
        List typecheck: arguments.
        List typecheck: other arguments.
        arguments
            with: other arguments
            do: { |arg1 arg2| arg1 checkEqual: arg2 }!
    method toString
        let string = StringOutput new: "{receiver} ".
        selector parts with: arguments
                       do: { |part arg|
                             string print: "{part} {arg}" }.
        string content!
    method debug
        let string = StringOutput new: "({receiver debug} ".
        selector parts with: arguments
                       do: { |part arg|
                             string print: "{part} {arg debug}" }.
        string print: ")".
        string content!
end

class SyntaxIs { left right }
    is Syntax
    method translateIn: environment
        AstIs left: (left translateIn: environment)
              right: (right translateIn: environment)!
    method checkEqualInternal: other
        left checkEqual: other left.
        right checkEqual: other right!
    method toString
        "{left} is {right}"!
    method debug
        "({left debug} is {right debug})"!
end

class SyntaxLet { name value body }
    is Syntax
    method translateIn: environment
        let bindEnv = environment addVariable: name.
        AstBindLexical
            name: name
            index: environment allocation index
            value: (value translateIn: environment)
            body: (body translateIn: bindEnv)!
    method checkEqualInternal: other
        value checkEqual: other value.
        name checkEqual: other name.
        body checkEqual: other body!
    method toString
        "let {name} = {value}. {body}"!
    method debug
        "(let {name} = {value debug}. {body debug})"!
end

class SyntaxSelf {}
    is Syntax
    method translateIn: environment
        AstSelfRef new!
    method toString
        "self"!
    method checkEqualInternal: other
        True!
end

class SyntaxVariable { name }
    is Syntax
    method translateIn: environment
        environment reference: name!
    method isEquivalent: other
        name == other name!
    method toString
        name!
    method debug
        name!
end

class SyntaxAssign { variable value }
    is Syntax
    method translateIn: environment
        let binding = environment reference: variable name.
        AstLexicalSet
            name: variable name
            frame: binding frame :: Integer
            index: binding index :: Integer
            value: (value translateIn: environment)!
    method checkEqualInternal: other
        variable checkEqual: other variable.
        value checkEqual: other value!
    method toString
        "{variable} = {value}"!
end

class SyntaxParens { body }
    is Syntax
    method translateIn: environment
        body translateIn: environment!
    method checkEqualInternal: other
        body checkEqual: other body!
    method toString
        "({body})"!
end

class SyntaxBlock { arguments body }
    is Syntax
    method translateIn: environment
        let bodyEnv = environment newFrame addVariables: arguments.
        AstBlock
            body: (body translateIn: bodyEnv)
            argumentCount: arguments size
            frameSize: arguments size + bodyEnv allocation size!
    method checkEqualInternal: other
        arguments checkEqual: other arguments.
        body checkEqual: other body!
    method toString
        let args = StringOutput new: "".
        arguments
            ifNotEmpty: { args print: "|".
                          arguments do: { |arg| args print: "{arg}" }
                                    interleaving: { args print: " " }.
                          args print: "| " }.
        "\{ {args content}{body} }"!
end

class SyntaxDefine { name body }
    is Syntax
    method translateIn: environment
        AstDefine
            name: name
            body: (body translateIn: environment)
            frameSize: environment allocation size!
    method checkEqualInternal: other
        name checkEqual: other name.
        body checkEqual: other body!
    method toString
        "define {name} {body}!"!
end

class SyntaxMethod { signature body }
    is Syntax

    method selector
        signature selector!

    method translateIn: environment
        let bodyEnv = environment newFrame
                          addVariables: signature parameters.
        let body = body translateIn: bodyEnv.
        AstMethod
            selector: signature selector name
            argumentCount: signature parameters size
            body: body
            frameSize: bodyEnv allocation size!

    method checkEqualInternal: other
        signature checkEqual: other signature.
        body checkEqual: other body!

    method toString
        "method {signature}\n{body}!"!
end

class SyntaxMethodSignature { selector parameters }
    is Syntax
    method toString
        parameters
            ifEmpty: { return selector name }.
        let index = 1.
        let out = StringOutput new.
        selector parts do: { |part|
                             out print: "{part} {parameters at: index}" }.
        out content!
    method checkEqualInternal: other
        selector checkEqual: other selector.
        parameters checkEqual: other parameters!
end

class SyntaxClass { name slots methods }
    is Syntax
    method translateIn: environment
        let classEnv = environment addSlots: slots.
        AstClass
            name: name
            slots: slots
            methods: (methods collect: { |m| m translateIn: classEnv })!
    method checkEqualInternal: other
        name checkEqual: other name.
        slots checkEqual: other slots.
        methods checkEqual: other methods!
    method toString
        let slotDesc = StringOutput new: "\{".
        slots ifNotEmpty: { slotDesc print: " " }.
        slots do: { |name| slotDesc print: "{name} " }.
        slotDesc print: "}".
        let methodDesc = StringOutput new.
        methods do: { |m| methodDesc println: m toString }.
        "class {name} {slotDesc content}\n{methodDesc content}end\n"!
end

define SeqPrecedence
    1!

define SingleExpressionPrecedence
    2! -- dot has precedence 2

define KeywordPrecedence
    9!

define UnknownOperatorPrecedence
    10!

define PrefixPrecedence
    1000!

define UnaryPrecedence
    1000!

define TokenPrecedence
    let tokens = Dictionary new.
    tokens put: 90 at: "*".
    tokens put: 90 at: "/".
    tokens put: 80 at: "-".
    tokens put: 80 at: "+".
    tokens put: 10 at: "is".
    tokens put: 4 at: "=".
    tokens put: 3 at: "let".
    tokens put: 3 at: "(".
    tokens put: 3 at: "\{".
    tokens put: 2 at: ".".
    tokens put: 1 at: "!".
    tokens put: 0 at: ")".
    tokens put: 0 at: "}".
    tokens put: 0 at: "define".
    tokens put: 0 at: "class".
    tokens!

interface Token
    is Object

    class method from: first to: last in: parser
        self
            string: (parser source from: first to: last)
            first: first last: last!

    method precedence
        Error raise: "{self string} is not valid in suffix position in self-hosted parser!"!

    method parseAsSuffixOf: prefix with: parser
        Error raise: "Self-hosted parser cannot parse {self} ({self first}) in suffix position!"!

    method parseAsPrefixWith: parser
        Error raise: "Self-hosted parser cannot parse {self} ({self first}) in prefix position!"!

    method toString
        "#<Token {self string}>"!
end

interface SuffixToken
    is Token

    method precedence
        TokenPrecedence
            at: self string
            ifNone: { UnknownOperatorPrecedence }!
end

class TokenDecimal { string first last }
    is Token

    method parseAsPrefixWith: parser
        let n = 0.
        1 to: string size
          do: { |pos|
                n = n * 10 + (string at: pos) digit }.
        SyntaxLiteral value: n!
end

class TokenEof { position }
    is Token

    class method at: position in: parser
        self position: position!

    method precedence
        0!

    method string
        "EOF"!
end

interface ReservedToken
    is SuffixToken
    class method string: string first: first last: last
        self first: first last: last!
end

class TokenReservedWordDefine { first last }
    is ReservedToken

    method parseAsPrefixWith: parser
        let def = SyntaxDefine
                      name: parser parseVariableName
                      body: (parser parseWithPrecedence: SeqPrecedence).
        parser expect: "!".
        def!

    method string
        "define"!
end

class TokenReservedWordEnd { first last }
    is ReservedToken

    method string
        "end"!
end

class TokenReservedWordIs { first last }
    is ReservedToken

    method parseAsSuffixOf: prefix with: parser
        SyntaxIs
            left: prefix
            right: (parser parseWithPrecedence: (self precedence))!

    method string
        "is"!
end

class TokenReservedWordLet { first last }
    is ReservedToken

    method parseAsPrefixWith: parser
        let name = parser parseVariableName.
        parser expect: "=".
        let value = (parser parseWithPrecedence: SingleExpressionPrecedence).
        parser expect: ".".
        SyntaxLet
            name: name
            value: value
            body: (parser parseWithPrecedence: SeqPrecedence)!

    method string
        "let"!
end

class TokenReservedSigilDot { first last }
    is ReservedToken

    method parseAsSuffixOf: prefix with: parser
        SyntaxSeq
            first: prefix
            then: (parser parseWithPrecedence: SeqPrecedence)!

    method string
        "."!
end

class TokenReservedSigilOpenParen { first last }
    is ReservedToken

    method parseAsPrefixWith: parser
        let body = parser parseWithPrecedence: SeqPrecedence.
        parser expect: ")".
        SyntaxParens
            body: body!

    method string
        "("!
end

class TokenReservedSigilCloseParen { first last }
    is ReservedToken
    method string
        ")"!
end

class TokenReservedSigilOpenBrace { first last }
    is ReservedToken

    method parseAsPrefixWith: parser
        let arguments = List new.
        parser
            when: "|"
            then: { parser until: "|"
                           do: { arguments add: (parser parseVariableName) } }.
        let body = parser parseWithPrecedence: SeqPrecedence.
        parser expect: "}".
        SyntaxBlock arguments: arguments body: body!

    method string
        "\{"!
end

class TokenReservedSigilCloseBrace { first last }
    is ReservedToken

    method precedence
        0!

    method string
        "}"!
end

class TokenReservedSigilEqual { first last }
    is ReservedToken

    method parseAsSuffixOf: prefix with: parser
        SyntaxAssign
            variable: prefix::SyntaxVariable
            value: (parser parseWithPrecedence: SingleExpressionPrecedence)!

    method string
        "="!
end

class TokenReservedWordSelf { first last }
    is ReservedToken

    method parseAsPrefixWith: parser
        SyntaxSelf new!
end

class TokenReservedWordClass { first last }
    is ReservedToken

    method parseAsPrefixWith: parser
        let name = parser parseVariableName.
        parser expect: "\{".
        let slots = List new.
        { TokenWord includes: parser lookahead }
            whileTrue: { slots add: parser parseVariableName }.
        let methods = List new.
        parser expect: "}".
        parser while: "method"
               do: { methods add: (self parseMethodWith: parser) }.
        parser expect: "end".
        SyntaxClass
            name: name
            slots: slots
            methods: methods!

    method parseMethodWith: parser
        let syntax = SyntaxMethod
            signature: (self parseMethodSignatureWith: parser)
            body: (parser parseWithPrecedence: SeqPrecedence).
        parser expect: "!".
        syntax!

    method parseMethodSignatureWith: parser
        let selector = StringOutput new.
        let parameters = List new.
        parser nextToken
            parseAsMethodSignatureWith: parser
            selector: selector
            parameters: parameters.
        SyntaxMethodSignature
            selector: (Selector new: selector content)
            parameters: parameters!

    method string
        "class"!
end

define ReservedTokens
    let tokens = Dictionary new.
    tokens put: TokenReservedSigilCloseBrace at: "}".
    tokens put: TokenReservedSigilCloseParen at: ")".
    tokens put: TokenReservedSigilDot at: ".".
    tokens put: TokenReservedSigilEqual at: "=".
    tokens put: TokenReservedSigilOpenBrace at: "\{".
    tokens put: TokenReservedSigilOpenParen at: "(".
    tokens put: TokenReservedWordClass at: "class".
    tokens put: TokenReservedWordDefine at: "define".
    tokens put: TokenReservedWordIs at: "is".
    tokens put: TokenReservedWordLet at: "let".
    tokens put: TokenReservedWordSelf at: "self".
    tokens!

interface LookupToken
    is SuffixToken

    class method from: first to: last in: parser
        let tokenString = parser source from: first to: last.
        -- Reserved words get their own classes!
        let tokenClass = ReservedTokens
                             at: tokenString
                             ifNone: { Self }.
        tokenClass string: tokenString first: first last: last!
end

class TokenSigil { string first last }
    is LookupToken

    method parseAsPrefixWith: parser
        SyntaxPrefix
            receiver: (parser parseWithPrecedence: PrefixPrecedence)
            selector: (Selector name: string)!

    method parseAsSuffixOf: prefix with: parser
        SyntaxBinary
            receiver: prefix
            selector: (Selector name: string)
            argument: (parser parseWithPrecedence: (self precedence))!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        parameters add: parser parseVariableName!
end

class TokenWord { string first last }
    is LookupToken

    method precedence
        UnaryPrecedence!

    class method from: first to: last in: parser
        let tokenString = parser source from: first to: last.
        -- Reserved words get their own classes!
        let tokenClass = ReservedTokens
                             at: tokenString
                             ifNone: { TokenWord }.
        tokenClass string: tokenString first: first last: last!

    method parseAsPrefixWith: parser

        SyntaxVariable
            name: string!

    method parseAsSuffixOf: prefix with: parser
           SyntaxUnary
            receiver: prefix
            selector: (Selector name: string)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        string == "prefix"
            ifTrue: { let op = parser nextToken.
                      (TokenSigil includes: op)
                          ifFalse: { Error raise: "Expected prefix sigil, got: {op string}" }.
                      selector print: op string }!
end

class TokenKeyword { string first last }
    is SuffixToken

    method precedence
        KeywordPrecedence!

    method parseAsSuffixOf: prefix with: parser
        let arguments = List new.
        let selector = StringOutput new: string.
        { arguments push: (parser parseWithPrecedence: (self precedence)).
          let token = parser lookahead.
          (TokenKeyword includes: token)
              ifTrue: { parser nextToken.
                        selector print: token string.
                        True } }
        whileTrue.
        SyntaxKeyword
            receiver: prefix
            selector: (Selector name: selector content)
            arguments: arguments!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        parameters add: parser parseVariableName.
        (TokenKeyword includes: parser lookahead)
            ifTrue: { parser nextToken
                          parseAsMethodSignatureWith: parser
                          selector: selector
                          parameters: parameters }!
end

define SpecialCharacters
    ["(" character,
     ")" character,
     "[" character,
     "]" character,
     "\{" character,
     "}" character,
     "!" character,
     "." character,
     ";" character,
     "," character]!

define UnderscoreCharacter
    "_" character!

define ColonCharacter
    ":" character!

-- FIXME: Broken for unicode input!
class Parser { source::String
               position::Integer
               first::Integer
               last::Integer
               lookahead::List }
    is Object

    class method new: source
        source
            ifEmpty: { Error raise: "Cannot parse empty string!" }.
        self
            source: source
            position: 1
             first: 1
             last: (source size)
             lookahead: List new!

    class method parse: source
        let parser = (self new: source).
        let syntax = List new.
        { parser skipWhitespace. parser atEof }
            whileFalse: { syntax add: (parser parse) }.
        -- syntax do: { |s| Debug println: "=> {s}" }.
        syntax!

    method parse
        self parseWithPrecedence: 0!

    method parseVariableName
        let token = self nextToken.
        (TokenWord includes: token)
            ifFalse: { panic "Invalid variable name: {token string}" }.
        token string!

    method expect: expected
        let got = self nextToken string.
        got == expected
            ifFalse: { Error raise: "Self-hosted parser expected '{expected}', got '{got}'
Context: {source}" }!

    method when: test then: action
        self lookahead string == test
            ifTrue: { self nextToken. action value }!

    method until: test do: action
        { self lookahead string == test }
            whileFalse: action.
        self nextToken!

    method while: test do: action
        { self lookahead string == test }
            whileTrue: { self nextToken. action value }!

    method parseWithPrecedence: precedence
        self parseSuffixOf: self parsePrefix with: precedence!

    method parsePrefix
        self nextToken parseAsPrefixWith: self!

    method parseSuffixOf: prefix with: precedence
        let expr = prefix.

        { -- Debug println: "expr: {expr}, precedence={precedence}, next={self lookahead}? {self nextPrecedence}".
          precedence < self nextPrecedence }
        whileTrue: { -- Debug println: " -> go".
                     expr = self parseSuffixOf: expr }.
        -- Debug println: " -> no".
        expr!

    method parseSuffixOf: prefix
        self nextToken parseAsSuffixOf: prefix with: self!

    method nextPrecedence
        self lookahead precedence!

    method lookahead
        lookahead
            ifEmpty: { lookahead push: self scanNext }.
        lookahead first!

    method nextToken
        lookahead isEmpty
            ifTrue: { self scanNext }
            ifFalse: { lookahead pop }!

    method scanNext
        self skipWhitespace.
        self atEof
            ifTrue: { return TokenEof at: position in: self }.
        self atSpecial
            ifTrue: { return self scanSpecial }.
        self atDigit
            ifTrue: { return self scanDecimal }.
        self atSigil
            ifTrue: { return self scanSigil }.
        self atWord
            ifTrue: { return self scanWord }.
        Error raise: "Don't know how to scan pos: {position} in: {source}"!

    method atEof
        position > last!

    method atSpecial
        self isAt: { |char|
                     SpecialCharacters
                         anySatisfy: { |special| special == char } }!

    method atDigit
        self isAt: #isDigit!

    method atWord
        self isAt: { |char|
                     char isAlphanumeric or: char == UnderscoreCharacter }!

    method atTerminating
        self atSpecial or: self atWhitespace!

    method atSigil
        self atEof not
            ifTrue: { (self atWord or: self atTerminating) not }!

    method atWhitespace
        self isAt: #isWhitespace!

    method atChar: char1 thenNot: char2
        self atEof
            ifTrue: { return False }.
        (source at: position) == char1
            ifFalse: { return False }.
        (position + 1 > last)
            ifFalse: { ((source at: position + 1) == char2) not }!

    method isAt: block
        self atEof
            ifTrue: { False }
            ifFalse: { block value: (source at: position) }!

    method skipWhile: test
        -- Debug println: "/skipWhile: {test}".
        let start = position.
        { test value: self }
            whileTrue: { self advance }.
        position - 1!

    method skipWhitespace
        self skipWhile: #atWhitespace!

    method scanSpecial
        -- Debug println: "/scanSpecial".
        let start = position.
        self advance.
        TokenSigil
            from: start
            to: start
            in: self!

    method scanDecimal
        -- Debug println: "/scanDecimal".
        TokenDecimal
            from: position
            to: (self skipWhile: #atDigit)
            in: self!

    method scanSigil
        -- Debug println: "/scanSigil".
        TokenSigil
            from: position
            to: (self skipWhile: #atSigil)
            in: self!

    method scanWord
        -- Debug println: "/scanWord".
        let first = position.
        self skipWhile: #atWord.
        (self atChar: ColonCharacter thenNot: ColonCharacter)
            ifTrue: { self advance.
                      TokenKeyword
                          from: first
                          to: position - 1
                          in: self }
            ifFalse: { TokenWord
                           from: first
                           to: position - 1
                           in: self }!

    method advance
        position <= last
            ifFalse: { panic "Tried to advance beyond end: \"{source}\"" }.
        position = position + 1!

end

class Tests {}

    class method run
        self new run!

    method run
        self
            ; test42
            ; testPlus
            ; testPrecedence
            ; testPrefixMethod
            ; testUnaryMethod
            ; testKeywordMethod
            ; testIs
            ; testLet
            ; testPrecedence2
            ; testParens
            ; testAssign
            ; testSimpleBlock
            ; testArgBlock
            ; testBlockClosure
            ; testDefine
            ; testSimpleClass
            ; testClassWithMethod
            ; testClassWithPrefixMethod
            ; testTwoClasses
            ; testBlockInMethod
            !

    method parse: source
        -- Check Syntax print/parse consistency.
        let syntaxList = Parser parse: source.
        let output = StringOutput new.
        syntaxList do: { |syntax| output print: syntax toString }.
        let printed = output content.
        { (syntaxList checkEqual: (Parser parse: printed)) }
            on: Error
            do: { |err|
                  panic "CST print/parse inconsistency!
original: {source}
printed: {printed}
problem: {err description}" }.
        syntaxList!

    method load: defSource eval: exprSource expect: expected
        let defs = List new.
        let env = Environment new.
        -- FIXME: Requires definitions to be in order.
        (self parse: defSource)
            do: { |def| env load: (def translateIn: env) }.
        let result = env eval: exprSource.
        (result == expected)
            ifFalse: { Error raise: "Expected {expected}, got: {result}
from: {exprSource}
with: {defSource}" }!

    method eval: exprSource expect: expected
        let process = Process new.
        let result = False.
        (self parse: exprSource)
            do: { |expr|
                  let env = Environment new.
                  result = (expr translateIn: env)
                      evalWith: (InterpreterContext new: env allocation size)
                      in: process }.
        (result == expected)
            ifFalse: { Error raise: "Expected {expected}, got: {result}
from: '{expr}'" }!

    method test42
        self eval: "42" expect: 42!
    method testPlus
        self eval: "100 + 1000 + 10 + 1" expect: 1111!
    method testPrecedence
        self eval: "12 + 10 * 10 - 1" expect: 111!
    method testPrefixMethod
        self eval: "- 42" expect: -42!
    method testUnaryMethod
        self eval: "- 42 abs" expect: 42!
    method testKeywordMethod
        self eval: "1 to: 10 by: 2" expect: (1 to: 10 by: 2)!
    method testIs
        self eval: "1 is 1" expect: True.
        self eval: "1 is 2" expect: False!
    method testLet
        self eval: "let x = 1. x + x"
             expect: 2!
    method testPrecedence2
        self eval: "let x = -40. let y = -2. x abs + y abs" expect: 42!
    method testParens
        self eval: "(1 + 1) * 2"
             expect: 4!
    method testAssign
        self eval: "let x = 20. x = x + 1. x * 2"
             expect: 42.
        self eval: "let y = 0.
                    let x = 20.
                    (let x = 2000. x = x + 100. y = x * 2).
                    x = x + 1. y + x * 2"
            expect: 4242!
    method testSimpleBlock
        self eval: "\{ 32 + 10 } value"
             expect: 42!
    method testArgBlock
        self eval: "\{ |x| x + 1 } value: 41"
             expect: 42!
    method testBlockClosure
        self eval: "let block = (let x = 21. \{ x = x * 2 }).
                    let x = 0.
                    block value. block value"
            expect: 84!
    method testDefine
        self load: "define FourtyTwoForTestDefine
                       42!"
             eval: "FourtyTwoForTestDefine"
             expect: 42!
    method testSimpleClass
        self load: "class MyClass \{ x } end"
             eval: "let c = MyClass x: 42. c x"
             expect: 42.
         self load: "class MyClass \{ x y } end"
             eval: "let c = MyClass x: 40 y: 2. c x + c y"
             expect: 42!
    method testClassWithMethod
        self load: "class MyClass \{ slot }
                        method foo: x
                           slot + x!
                    end"
             eval: "(MyClass slot: 40) foo: 2"
             expect: 42!
    method testClassWithPrefixMethod
        self load: "class MyClass \{ slot }
                        method prefix%
                            slot * slot!
                    end"
             eval: "%(MyClass slot: -2)"
             expect: 4!
    method testTwoClasses
        self load: "class Class1 \{ slot }
                        method foo: x
                           x bar + slot * 2!
                    end
                    class Class2 \{ slot }
                        method bar
                           slot!
                        method foo: y
                           y foo: self!
                    end"
             eval: "(Class2 slot: 2) foo: (Class1 slot: 20)"
             expect: 42!
    method testBlockInMethod
        self load: "class ClassAA \{ slot }
                        method capture: x
                           \{ x }!
                        method captureSlot
                           \{ slot }!
                        method capture
                           let z = 2.
                           \{ (self captureSlot) value + (self capture: z) value }!
                    end
                    class ClassBB \{ slot }
                        method ctor: x
                           \{ (ClassAA slot: x + slot) }!
                        method run: x
                           (self ctor: x * 2) value capture value!
                    end"
             eval: "(ClassBB slot: 20) run: 10"
             expect: 42!
end

class Main {}
    class method run: cmd in: system
        Tests run.
        system output println: "ok!"!
end
