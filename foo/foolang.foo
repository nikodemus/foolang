class Debug {}
    class method println: what
        Output debug println: what
end

class HostMethod { receiver selector }
    is Object
    method invoke: arguments
        selector sendTo: receiver with: arguments
end

class Process {}
    is Object
end

class InterpreterContext {
        sender
        frame::Array
    }
    is Object
    method at: index inFrame: frameNumber
        frameNumber > 1
            ifTrue: { sender at: index in: frameNumber - 1 }
            ifFalse: { frame at: index }

    method put: value at: index inFrame: frameNumber
        frameNumber > 1
            ifTrue: { sender put: value at: index in: frameNumber - 1 }
            ifFalse: { frame put: value at: index }
end

define EmptyInterpreterContext
    -- FIXME: wrap expressions in blocks so that we can query the AST for the frame
    -- size before executing.
    InterpreterContext sender: False frame: (Array new: 100)
end

class Binding { name index }
    is Object
    method referenceInFrame: frame
        AstLexicalRef frame: frame index: index
end

class Environment { bindings parent }
    is Object

    class method new
        Environment
            bindings: List new
            parent: False

    method addVariable: name
        Environment
            bindings: (bindings copy
                           add: (Binding
                                     name: name
                                     index: bindings size + 1))
            parent: parent

    method reference: name
        self reference: name inFrame: 1

    method reference: name inFrame: frame
        let binding = bindings
                          find: { |binding| binding name == name }
                          ifNone: { return parent reference: name inFrame: frame + 1 }.
        binding referenceInFrame: frame

    method size
        bindings size
end

define EmptyEnvironment
    Environment new
end

class AstConstantRef { value }
    is Object
    method evalWith: context in: process
        value
end

class AstIs { left right }
    is Object
    method evalWith: context in: process
        (left evalWith: context in: process)
            is (right evalWith: context in: process)
end

class AstSend {
        receiver
        selector
        arguments
    }
    method evalWith: context in: process
        let receiver = receiver evalWith: context in: process.
        (self getMethod: selector for: receiver)
            invoke: (arguments
                         collect: { |arg|
                                    arg evalWith: context in: process })

    method getMethod: selector for: receiver
        -- Later this will distinguish between host and interpreter methods.
        HostMethod receiver: receiver selector: selector

end

class AstBindLexical { index value body }
    method evalWith: context in: process
        context
            put: (value evalWith: context in: process)
            at: index
            inFrame: 1.
        body evalWith: context in: process.
end

class AstLexicalRef { frame index }
    method evalWith: context in: process
        context at: index inFrame: frame
end

class SyntaxLiteral { value }
    is Object
    method translateIn: environment
        AstConstantRef value: value
    method toString
        value toString
end

class SyntaxVariable { name }
    is Object
    method translateIn: environment
        environment reference: name
    method toString
        name
end

class SyntaxPrefix { receiver selector }
    is Object
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: (Selector name: "prefix{selector name}")
                arguments: []
    method toString
        "({selector name} {receiver})"
end

class SyntaxUnary { receiver selector }
    is Object
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: selector
                arguments: []
end

class SyntaxBinary { receiver selector argument }
    is Object
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: selector
                arguments: [argument translateIn: environment]
    method toString
        "({receiver} {selector name} {argument})"
end

class SyntaxKeyword { receiver selector arguments }
    is Object
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: selector
                arguments: (arguments
                                collect: { |arg|
                                           arg translateIn: environment })
end

class SyntaxIs { left right }
    is Object
    method translateIn: environment
        AstIs left: (left translateIn: environment)
              right: (right translateIn: environment)
    method toString
        "({left} is {right})"
end

class SyntaxLet { name value body }
    is Object
    method translateIn: environment
        AstBindLexical
            index: environment size + 1
            value: (value translateIn: environment)
            body: (body translateIn: (environment addVariable: name))
    method toString
        "(let {name} = {value}. {body})"
end

class SyntaxParens { body }
    is Object
    method translateIn: environment
        body translateIn: environment
    method toString
        "({body})"
end

define SeqPrecedence
    1
end

define SingleExpressionPrecedence
    2 -- dot has precedence 2
end

define KeywordPrecedence
    9
end

define UnknownOperatorPrecedence
    10
end

define PrefixPrecedence
    1000
end

define TokenPrecedence
    let tokens = Dictionary new.
    tokens put: 90 at: "*".
    tokens put: 90 at: "/".
    tokens put: 80 at: "-".
    tokens put: 80 at: "+".
    tokens put: 10 at: "is".
    tokens put: 3 at: "let".
    tokens put: 3 at: "(".
    tokens put: 2 at: ".".
    tokens put: 0 at: ")".
    tokens
end

interface Token
    is Object

    class method from: first to: last in: parser
        self
            string: (parser source from: first to: last)
            first: first last: last

    method precedence
        Error raise: "{self string} is not valid in suffix position!"

    method parseAsSuffixOf: prefix with: parser
        Error raise: "Cannot parse {self} in suffix position!"

    method parseAsPrefixWith: parser
        Error raise: "Cannot parse {self} in prefix position!"

    method toString
        "#<Token {self string}>"
end

interface SuffixToken
    is Token

    method precedence
        TokenPrecedence
            at: self string
            ifNone: { UnknownOperatorPrecedence }
end

class TokenDecimal { string first last }
    is Token

    method parseAsPrefixWith: parser
        let n = 0.
        1 to: string size
          do: { |pos|
                n = n * 10 + (string at: pos) digit }.
        SyntaxLiteral value: n
end

class TokenEof { position }
    is Token

    class method at: position in: parser
        self position: position

    method precedence
        0

    method string
        "EOF"
end

interface ReservedToken
    is SuffixToken
    class method string: string first: first last: last
        self first: first last: last
end

class TokenReservedWordIs { first last }
    is ReservedToken

    method parseAsSuffixOf: prefix with: parser
        SyntaxIs
            left: prefix
            right: (parser parseWithPrecedence: (self precedence))

    method string
        "is"
end

class TokenReservedWordLet { first last }
    is ReservedToken

    method parseAsPrefixWith: parser
        let name = parser parseVariableName.
        parser expect: "=".
        let value = (parser parseWithPrecedence: SingleExpressionPrecedence).
        parser expect: ".".
        SyntaxLet
            name: name
            value: value
            body: (parser parseWithPrecedence: SeqPrecedence)

    method string
        "let"
end

class TokenReservedSigilDot { first last }
    is ReservedToken

    method parseAsSuffixOf: prefix with: parser
        SyntaxSeq
            first: prefix
            then: (parser parseWithPrecedence: SeqPrecedence)

    method string
        "."
end

class TokenReservedSigilOpenParen { first last }
    is ReservedToken

    method parseAsPrefixWith: parser
        let body = parser parseWithPrecedence: SeqPrecedence.
        parser expect: ")".
        SyntaxParens
            body: body

    method string
        "("
end

class TokenReservedSigilCloseParen { first last }
    is ReservedToken
    method string
        ")"
end

define ReservedTokens
    let tokens = Dictionary new.
    tokens put: TokenReservedWordIs at: "is".
    tokens put: TokenReservedWordLet at: "let".
    tokens put: TokenReservedSigilDot at: ".".
    tokens put: TokenReservedSigilOpenParen at: "(".
    tokens put: TokenReservedSigilCloseParen at: ")".
    tokens
end

interface LookupToken
    is SuffixToken

    class method from: first to: last in: parser
        let tokenString = parser source from: first to: last.
        -- Reserved words get their own classes!
        let tokenClass = ReservedTokens
                             at: tokenString
                             ifNone: { Self }.
        tokenClass string: tokenString first: first last: last
end

class TokenSigil { string first last }
    is LookupToken

    method parseAsPrefixWith: parser
        SyntaxPrefix
            receiver: (parser parseWithPrecedence: PrefixPrecedence)
            selector: (Selector name: string)

    method parseAsSuffixOf: prefix with: parser
        SyntaxBinary
            receiver: prefix
            selector: (Selector name: string)
            argument: (parser parseWithPrecedence: (self precedence))
end

class TokenWord { string first last }
    is LookupToken

    class method from: first to: last in: parser
        let tokenString = parser source from: first to: last.
        -- Reserved words get their own classes!
        let tokenClass = ReservedTokens
                             at: tokenString
                             ifNone: { TokenWord }.
        tokenClass string: tokenString first: first last: last

    method parseAsPrefixWith: parser
        SyntaxVariable
            name: string

    method parseAsSuffixOf: prefix with: parser
           SyntaxUnary
            receiver: prefix
            selector: (Selector name: string).
end

class TokenKeyword { string first last }
    is SuffixToken

    method precedence
        KeywordPrecedence

    method parseAsSuffixOf: prefix with: parser
        let arguments = List new.
        let selector = StringOutput new: string.
        { arguments push: (parser parseWithPrecedence: (self precedence)).
          let token = parser lookahead.
          (TokenKeyword includes: token)
              ifTrue: { parser nextToken.
                        selector print: token string.
                        True } }
        whileTrue.
        SyntaxKeyword
            receiver: prefix
            selector: (Selector name: selector content)
            arguments: arguments
end

define SpecialCharacters
    ["(" character,
     ")" character,
     "[" character,
     "]" character]
end

define UnderscoreCharacter
    "_" character
end

define ColonCharacter
    ":" character
end

-- FIXME: Broken for unicode input!
class Parser { source::String
               position::Integer
               first::Integer
               last::Integer
               lookahead::List }
    is Object
    class method parse: source
        (self
             source: source
             position: 1
             first: 1
             last: (source size)
             lookahead: List new)
        parse

    method parse
        self parseWithPrecedence: 0

    method parseVariableName
        let token = self nextToken.
        (TokenWord includes: token)
            ifFalse: { panic "Invalid variable name: {token string}" }.
        token string

    method expect: expected
        let got = self nextToken string.
        got == expected
            ifFalse: { Error raise: "Expected '{expected}', got '{got}'" }.

    method parseWithPrecedence: precedence
        self parseSuffixOf: self parsePrefix with: precedence

    method parsePrefix
        self nextToken parseAsPrefixWith: self

    method parseSuffixOf: prefix with: precedence
        let expr = prefix.

        { -- Debug println: "expr: {expr}, precedence={precedence}, next={self nextPrecedence}".
          precedence < self nextPrecedence }
        whileTrue: { -- Debug println: " -> go".
                     expr = self parseSuffixOf: expr }.
        -- Debug println: " -> no".
        expr

    method parseSuffixOf: prefix
        self nextToken parseAsSuffixOf: prefix with: self

    method nextPrecedence
        self lookahead precedence

    method lookahead
        lookahead
            ifEmpty: { lookahead push: self scanNext }.
        lookahead first

    method nextToken
        lookahead isEmpty
            ifTrue: { self scanNext }
            ifFalse: { lookahead pop }.

    method scanNext
        self skipWhitespace.
        self atEof
            ifTrue: { return TokenEof at: position in: self }.
        self atSpecial
            ifTrue: { return self scanSpecial }.
        self atDigit
            ifTrue: { return self scanDecimal }.
        self atSigil
            ifTrue: { return self scanSigil }.
        self atWord
            ifTrue: { return self scanWord }.
        Error raise: "Don't know how to scan pos: {position} in: {source}"

    method atEof
        position > last

    method atSpecial
        self isAt: { |char|
                     SpecialCharacters
                         anySatisfy: { |special| special == char } }

    method atDigit
        self isAt: #isDigit

    method atWord
        self isAt: { |char|
                     char isAlphanumeric or: char == UnderscoreCharacter }

    method atTerminating
        self atSpecial or: self atWhitespace

    method atSigil
        (self atWord or: self atTerminating) not

    method atWhitespace
        self isAt: #isWhitespace

    method atChar: char1 thenNot: char2
        self atEof
            ifTrue: { return False }.
        (source at: position) == char1
            ifFalse: { return False }.
        (position + 1 > last)
            ifFalse: { ((source at: position + 1) == char2) not }

    method isAt: block
        self atEof
            ifTrue: { False }
            ifFalse: { block value: (source at: position) }

    method skipWhile: test
        let start = position.
        { test value: self }
            whileTrue: { self advance }.
        position - 1

    method skipWhitespace
        self skipWhile: #atWhitespace

    method scanSpecial
        let start = position.
        self advance.
        TokenSigil
            from: start
            to: start
            in: self.

    method scanDecimal
        TokenDecimal
            from: position
            to: (self skipWhile: #atDigit)
            in: self.

    method scanSigil
        TokenSigil
            from: position
            to: (self skipWhile: #atSigil)
            in: self.

    method scanWord
        let first = position.
        self skipWhile: #atWord.
        (self atChar: ColonCharacter thenNot: ColonCharacter)
            ifTrue: { self advance.
                      TokenKeyword
                          from: first
                          to: position - 1
                          in: self }
            ifFalse: { TokenWord
                           from: first
                           to: position - 1
                           in: self }

    method advance
        position <= last assert: "can advance".
        position = position + 1.

end

extend String
    method parse
        Parser parse: self
    method eval
        (self parse translateIn: EmptyEnvironment)
            evalWith: EmptyInterpreterContext
            in: Process new.
end

class Tests {}
    class method run
        self new run
    method run
        self
            ; test42
            ; testPlus
            ; testPrecedence
            ; testPrefixMethod
            ; testUnaryMethod
            ; testKeywordMethod
            ; testIs
            ; testLet
            ; testParens
    method test42
        ("42" eval == 42) assert: "Constant evaluation".
    method testPlus
        ("100 + 1000 + 10 + 1" eval == 1111) assert: "Constant addition".
    method testPrecedence
        ("12 + 10 * 10 - 1" eval == 111) assert: "Binary precedence".
    method testPrefixMethod
        ("- 42" eval == -42) assert: "Prefix method".
    method testUnaryMethod
        ("- 42 abs" eval == 42) assert: "Unary method".
    method testKeywordMethod
        ("1 to: 10 by: 2" eval == (1 to: 10 by: 2)) assert: "Keyword method".
    method testIs
        ("1 is 1" eval == True) assert: "Builtin 'is' --> True".
        ("1 is 2" eval == False) assert: "Builtin 'is' --> False".
    method testLet
        ("let x = 1. x + x" eval == 2) assert: "Let binding".
    method testParens
        ("(1 + 1) * 2" eval == 4) assert: "Parens".
end

class Main {}
    class method run: cmd in: system
        Tests run.
        system output println: "ok!"
end
