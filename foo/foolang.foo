class Debug {}
    direct method println: what
        Output debug println: what!
    direct method print: what
        Output debug print: what!
end

class Process {}
    is Object
end

class InterpreterContext {
        sender
        receiver
        frame::Array
        returnBlock
    }
    is Object

    direct method new: size
        self new: size
             returnBlock: { |value|
                            Error raise: "Invalid return: {value}" }!

    direct method new: size returnBlock: returnBlock
        self sender: False
             receiver: False
             frame: (Array new: size value: "<unbound>")
             returnBlock: returnBlock!

    method invalidate
        returnBlock = { |value|
                        Error raise: "Cannot return from dead context: {value}" }!

    method slot: index
        -- FIXME: Replace this with Primitive readSlot: index of: receiver.
        -- which breaks encapsulation. Dammit, so it needs to be:
        --
        --    system primitives readSlot: index of: receiver.
        --
        -- so primitives need to be passed down here. Yuck.
        --
        -- Maybe some of the auth should be statically handled?
        -- Like:
        --
        --    import foolang allowing: Primitive
        --
        -- ?
        receiver __slot: (index - 1)!

    method at: index inFrame: frameNumber
        frameNumber > 1
            ifTrue: { sender at: index inFrame: frameNumber - 1 }
            ifFalse: { frame at: index }!

    method put: value at: index inFrame: frameNumber
        frameNumber > 1
            ifTrue: { sender put: value at: index inFrame: frameNumber - 1 }
            ifFalse: { frame put: value at: index }!
end

class VariableBinding { name index::Integer }
    is Object
    method referenceInFrame: frame
        AstLexicalRef name: name frame: frame index: index!
end

class SlotBinding { name index::Integer }
    is Object
    method referenceInFrame: frame
        AstSlotRef name: name index: index!
end

class FrameAllocation { size::Integer }
    direct method new
        -- Debug println: "** frame allocation **".
        self size: 0!
    method nextIndex
        size = size + 1.
        size!
    method index
        size!
end

interface AstNode
    is Object
    method debug
        Debug println: "#<AST {self}>"!
end

class AstComment { comment value source }
    is Object
    method evalWith: context in: process
        value evalWith: context in: process!
end

class StandardUndefinedPolicy {}
    -- Called during translation when encountering an undefined variable
    -- This particular method gets called when an undefined variable is
    -- encountered outside a definition.
    direct method reference: name in: environment
        Error raise: "Undefined variable: {name}"!

    -- Called during evaluation when encountering a lazily resolved undefined
    -- variable. This particilar method should never be called.
    direct method resolve: name
        panic "Unresolved undefined variable: {name}! This should not happen."!
end

class AllowReferenceToUndefined {}
    -- During translation of definitions we allow references to undefined
    -- variables.
    direct method reference: name in: env
        let global = (AstGlobal name: name).
        env globals
            put: global
            at: name.
        return global!

    direct method resolve: name
        StandardUndefinedPolicy resolve: name!

end

class ResolveUndefinedsWith { definitions environment }
    direct method definitions: definitions in: environment
        self definitions: definitions environment: environment!

    method reference: name in: environment
        StandardUndefinedPolicy reference: name in: environment!

    -- During evaluation of definition bodies we resolve undefineds to
    -- as-of-yet evaluated definitions.
    method resolve: name
        (definitions
             at: name
             ifNone: { StandardUndefinedPolicy reference: name in: environment })
        defineIn: environment!
end

define $UndefinedPolicy
    StandardUndefinedPolicy!

class UndefinedMarker {}
end

class AstGlobal { name _value }
    is AstNode

    direct method name: name
        self
            name: name
            value: UndefinedMarker!

    direct method name: name value: value
        self
            name: name
            _value: value!

    method isUndefined
        _value is UndefinedMarker!

    method value
        self isUndefined
            ifTrue: { return $UndefinedPolicy resolve: self name }.
        _value!

    method value: newValue
        _value = newValue!

    method evalWith: context in: process
        self value!
end

define BuiltinGlobals
    let globals = Dictionary new.
    globals put: (AstGlobal name: "True" value: True) at: "True".
    globals put: (AstGlobal name: "False" value: False) at: "False".
    globals!

class Environment { bindings parent allocation globals }
    is Object

    direct method new
        Environment
            bindings: List new
            parent: False
            allocation: FrameAllocation new
            globals: BuiltinGlobals copy!

    method toplevel
        Environment
            bindings: List new
            parent: False
            allocation: FrameAllocation new
            globals: globals!

    method newFrame
        Environment
            bindings: List new
            parent: self
            allocation: FrameAllocation new
            globals: globals!

    method addVariable: name
        Environment
            bindings: (bindings copy
                           add: (VariableBinding
                                     name: name
                                     index: allocation nextIndex))
            parent: parent
            allocation: allocation
            globals: globals!

    method addVariables: names
        let newBindings = bindings copy.
        names do: { |name|
                    newBindings
                        add: (VariableBinding
                                  name: name
                                  index: allocation nextIndex) }.
        Environment
            bindings: newBindings
            parent: parent
            allocation: allocation
            globals: globals!

    method addSlots: names
        let newBindings = bindings copy.
        let slotAllocation = FrameAllocation new.
        names do: { |name|
                    newBindings
                        add: (SlotBinding
                                  name: name
                                  index: slotAllocation nextIndex) }.
        Environment
            bindings: newBindings
            parent: parent
            allocation: allocation
            globals: globals!

    method load: string
        let defs = Dictionary new.
        (Parser parse: string)
            do: { |syntax|
                  let $UndefinedPolicy = AllowReferenceToUndefined.
                  let def = SyntaxTranslator
                                translate: syntax
                                in: (self toplevel) .
                  defs put: def at: def name }.
        let $UndefinedPolicy = ResolveUndefinedsWith definitions: defs in: self.
        defs doValues: { |def| def defineIn: self }.
        self checkGlobals.
        self!

    method eval: string
        let env = Environment
                      bindings: List new
                      parent: False
                      allocation: FrameAllocation new
                      globals: globals.
        let res = False.
        (Parser parse: string)
            do: { |syntax|
                  res = (SyntaxTranslator translate: syntax in: env)
                                evalWith: (InterpreterContext new: env allocation size)
                                in: Process new }.
        res!

    method checkGlobals
        globals doValues: { |global|
                            global isUndefined
                                ifTrue: { Error raise: "Undefined variable: {global name}" } }!

    method global: name
        globals at: name ifNone: { self undefined: name }!

    method undefined: name
        $UndefinedPolicy reference: name in: self!

    method define: name value: value
        let global = globals
                         at: name
                         ifNone: { globals
                                       put: (AstGlobal name: name value: value)
                                       at: name.
                                   return value }.
        global isUndefined
            ifTrue: { global value: value.
                      value }
            ifFalse: { Error raise: "Cannot redefined a global: {name}" }!

    method reference: name
        self reference: name inFrame: 1!

    method reference: name inFrame: frame::Integer
        let binding = bindings reversed -- SLOW!
                          find: { |binding| binding name == name }
                          ifNone: { parent is False
                                        ifTrue: { return self global: name }
                                        ifFalse: { return parent reference: name inFrame: frame + 1 } }.
        binding referenceInFrame: frame!
end

interface AstObject
end

class AstConstantRef { value }
    is AstNode
    method evalWith: context in: process
        value!
end

class AstIs { left right }
    is AstNode
    method evalWith: context in: process
        (left evalWith: context in: process)
            is (right evalWith: context in: process)!
end

class AstSeq { first then }
    is AstNode
    method evalWith: context in: process
        first evalWith: context in: process.
        then evalWith: context in: process!
end

class AstReturn { value }
    is AstNode
    method evalWith: context in: process
        context returnBlock value: (value evalWith: context in: process)!
end

class AstSend {
        receiver
        selector
        arguments
        source
    }
    is AstNode

    method evalWith: context in: process
        let object = receiver
                         evalWith: context
                         in: process.
        let arguments = arguments
                            collect: { |arg|
                                       arg
                                           evalWith: context
                                           in: process }.
        let $context = context.
        let $process = process.
        -- Debug println: "<- {selector}".
        { selector sendTo: object with: arguments }
            on: DoesNotUnderstand
            do: { |ex|
                  -- Add the source location to the error.
                  (object is ex receiver and: selector == ex selector)
                      ifTrue: { DoesNotUnderstand
                                    raise: selector
                                    with: arguments
                                    on: object
                                    source: source }} !
end

define $context
    False!

define $process
    False!

define $DefinitionsInProgress
    False!

class DefinitionsInProgress { this next }
    direct method with: definition do: block
        let old = $DefinitionsInProgress.
        old is False
            ifFalse: { old checkCycle: definition }.
        let $DefinitionsInProgress = DefinitionsInProgress this: definition next: old.
        block value!

    method checkCycle: definition
        this is definition
            ifTrue: { Error raise: "Cyclic definition!" }.
        next is False
            ifFalse: { next checkCycle: definition }!
end

interface AstDefinition
    is AstNode
    required method done
    required method _eval
    method defineIn: environment
        self done
            ifTrue: { (environment globals at: name) value }
            ifFalse: { DefinitionsInProgress
                           with: self
                           do: { { environment define: name value: self _eval }
                                     finally: { done = True } } }!
end

class AstDefine { name body frameSize done }
    is AstDefinition
    direct method name: name body: body frameSize: frameSize
        self name: name body: body frameSize: frameSize done: False!
    method _eval
        -- return inside define should work
        let context = InterpreterContext new: frameSize
                                         returnBlock: { |value| return value }.
        { body evalWith: context in: Process new }
            finally: { context invalidate } !
end

class AstMethod { selector argumentCount body frameSize }
    is Object
    method invoke: arguments on: receiver
        let frame = Array new: frameSize.
        let nArgs = arguments size.
        argumentCount is nArgs
            ifFalse: { Error raise: "Method argument count mismatch!" }.
        1 to: nArgs
          do: { |i| frame put: (arguments at: i) at: i }.
        let context = InterpreterContext
                          sender: $context
                          receiver: receiver
                          frame: frame
                          returnBlock: { |value| return value }.
        { body evalWith: context in: $process }
            finally: { context invalidate } !
end

class AstClass { name directMethods slots methods done }
    is AstDefinition
    direct method name: name
                  directMethods: directMethods
                  slots: slots
                  methods: methods
        self
            name: name
            directMethods: directMethods
            slots: slots
            methods: methods
            done: False!
    -- Class methods should be translated in a specific environment
    -- that contains the instance variables.
    method _eval
        Class
            new: name
            interfaces: ["Object"]
            directMethods: (Array from: directMethods)
            slots: (Array from: slots)
            methods: (Array from: methods)!
    method checkEqualInternal: other
        name checkEqual: other name.
        directMethods checkEqual: other directMethods.
        slots checkEqual: other slots.
        methods checkEqual: other methods!
end

class AstBlockClosure { context block }
    is AstNode
    method value
        self apply: []!
    method value: arg
        self apply: [arg]!
    method apply: arguments
        let frame = Array new: block frameSize.
        let nArgs = arguments size.
        block argumentCount is nArgs
            ifFalse: { Error raise: "Block argument count mismatch!" }.
        1 to: nArgs
          do: { |i| frame put: (arguments at: i) at: i }.
        block body
            evalWith: (InterpreterContext
                           sender: context
                           receiver: context receiver
                           frame: frame
                           returnBlock: context returnBlock)
            in: $process!
end

class AstBlock { body argumentCount frameSize }
    is AstNode
    method evalWith: context in: process
        AstBlockClosure
            context: context
            block: self!
    method frameSize
        frameSize!
end

class AstSelfRef {}
    is AstNode
    method evalWith: context in: process
        context receiver!
end

class AstSlotRef { name index::Integer }
    is AstNode
    method evalWith: context in: process
        context slot: index!
end

class AstBindLexical { name index value body }
    is AstNode
    method evalWith: context in: process
        let object = value evalWith: context in: process.
        context
            put: object
            at: index
            inFrame: 1.
        body evalWith: context in: process!
end

class AstLexicalRef { name
                      frame::Integer
                      index::Integer }
    is AstNode
    method evalWith: context in: process
        context at: index inFrame: frame!
end

class AstLexicalSet { name
                      frame::Integer
                      index::Integer
                      value }
    is AstNode
    method evalWith: context in: process
        context
            put: (value evalWith: context in: process)
            at: index
            inFrame: frame!
end

interface SyntaxVisitor
    is Object
    required method visitLiteral: value
    required method visitSeqFirst: first then: then
    required method visitReturn: syntax
    required method visitPrefixComment: comment value: value source: source
    required method visitSuffixComment: comment value: value source: source
    required method visitLet: name value: value body: body
    required method visitPrefixMessage: selector receiver: receiver source: source
    required method visitUnaryMessage: selector receiver: receiver source: source
    required method visitBinaryMessage: selector receiver: receiver argument: argument source: source
    required method visitKeywordMessage: selector receiver: receiver arguments: arguments source: source
    required method visitIsLeft: left right: right
    required method visitSelf
    required method visitVariable: name
    required method visitAssign: value to: variable
    required method visitParens: body
    required method visitBlockWith: parameters body: body
    required method visitDefine: name body: body
    required method visitMethodDefinition: signature body: body
    required method visitClassDefinition: name directMethods: directMethods slots: slots methods: methods
end

class SyntaxPrinter { output indent printed blockStart }
    is SyntaxVisitor

    direct method print: syntax to: output
        syntax visitBy: (self
                             output: output
                             indent: 0
                             printed: 0
                             blockStart: False)!

    method indentBody
        SyntaxPrinter
            output: output
            indent: indent + 4
            printed: printed
            blockStart: False!

    method indentHere
        SyntaxPrinter
            output: output
            indent: printed
            printed: printed
            blockStart: False!

    method indentBlock
        SyntaxPrinter
            output: output
            indent: printed
            printed: printed
            blockStart: True!

    method print: string::String
        output print: string.
        printed = printed + string size!

    method println: string::String
        output println: string.
        indent times: { output print: " " }.
        printed = indent!

    method handleBlockStart
        blockStart
            ifTrue: { self println: "".
                      blockStart = False }!

    method visitLiteral: value
        self print: value toString!

    method visitSeqFirst: first then: then
        self handleBlockStart.
        first visitBy: self.
        self println: ".".
        then visitBy: self!

    method visitReturn: value
        self print: "return ".
        value visitBy: self!

    method visitPrefixComment: comment value: value source: source
        self handleBlockStart.
        self print: "--".
        self println: comment.
        value visitBy: self indentBody!

    method visitSuffixComment: comment value: value source: source
        self handleBlockStart.
        value visitBy: self.
        self print: " --".
        self println: comment!

    method visitPrefixMessage: selector receiver: receiver source: source
        self print: selector name.
        receiver visitBy: self!

    method visitUnaryMessage: selector receiver: receiver source: source
        receiver visitBy: self.
        self print: " ".
        self print: selector name!

    method visitBinaryMessage: selector receiver: receiver argument: argument source: source
        receiver visitBy: self.
        self print: " ".
        self print: selector name.
        self print: " ".
        argument visitBy: self!

    method visitKeywordMessage: selector receiver: receiver arguments: arguments source: source
        receiver visitBy: self.
        selector parts
            with: arguments
            do: { |part arg|
                  self print: " ".
                  self print: part.
                  self print: " ".
                  arg visitBy: self }!

    method visitIsLeft: left right: right
        left visitBy: self.
        self print: " is ".
        right visitBy: self!

    method visitLet: name value: value body: body
        self handleBlockStart.
        self print: "let ".
        self print: name.
        self print: " = ".
        value visitBy: self.
        self println: ".".
        body visitBy: self!

    method visitSelf
        self print: "self"!

    method visitVariable: name
        self print: name!

    method visitAssign: value to: variable
        self print: variable name.
        self print: " = ".
        value visitBy: self!

    method visitParens: body
        self print: "(".
        body visitBy: self indentHere.
        self print: ")"!

    method visitBlockWith: parameters body: body
        self print: "\{ ".
        let bodyPrinter = self indentBlock.
        parameters
            ifNotEmpty: { self print: "|".
                          parameters do: { |param| self print: param }
                                     interleaving: { self print: " " }.
                          self print: "| " }.
        body visitBy: bodyPrinter.
        self print: " }"!

    method visitDefine: name body: body
        self print: "define ".
        let bodyVisitor = self indentBody.
        bodyVisitor println: name.
        body visitBy: bodyVisitor.
        self println: "!"!

    method visitMethodDefinition: signature body: body
        self print: "method".
        signature parameters isEmpty
            ifTrue: { self print: " ".
                      self print: signature selector name }
            ifFalse: { signature selector parts
                           withIndexDo: { |part index|
                                 self print: " ".
                                 self print: part.
                                 self print: " ".
                                          self print: (signature parameters at: index) } }.
        let bodyVisitor = self indentBody.
        bodyVisitor println: "".
        body visitBy: bodyVisitor.
        self print: "!"!

    method visitClassDefinition: name directMethods: directMethods slots: slots methods: methods
        self print: "class ".
        self print: name.
        self print: " \{".
        slots ifNotEmpty: { self print: " ".
                            slots do: { |slot|
                                        self print: slot.
                                        self print: " " } }.
        self print: "}".
        let methodVisitor = self indentBody.
        directMethods do: { |m|
                            methodVisitor println: "".
                            methodVisitor print: "direct ".
                            m visitBy: methodVisitor }.
        methods do: { |m|
                      methodVisitor println: "".
                      m visitBy: methodVisitor }.
        self println: "".
        self println: "end"!
end

class SyntaxTranslator { env }
    is SyntaxVisitor

    direct method translate: syntax in: env
        syntax
            visitBy: (SyntaxTranslator env: env)!

    method addVariable: name
        SyntaxTranslator env: (env addVariable: name)!

    method visitLiteral: value
        AstConstantRef
            value: value!

    method visitSeqFirst: first then: then
        -- FIXME: Would be nicer to flatten this out.
        AstSeq
            first: (first visitBy: self)
            then: (then visitBy: self)!

    method visitReturn: syntax
        AstReturn
            value: (syntax visitBy: self)!

    method visitPrefixComment: comment value: value source: source
        AstComment comment: comment
                   value: (value visitBy: self)
                   source: source!

    method visitSuffixComment: comment value: value source: source
        AstComment comment: comment
                   value: (value visitBy: self)
                   source: source!

    method visitLet: name value: value body: body
        let bodyVisitor = self addVariable: name.
        AstBindLexical
            name: name
            index: bodyVisitor env allocation index
            value: (value visitBy: self)
            body: (body visitBy: bodyVisitor)!

    method visitPrefixMessage: selector receiver: receiver source: source
        AstSend receiver: (receiver visitBy: self)
                selector: (Selector name: "prefix{selector name}")
                arguments: []
                source: source!

    method visitUnaryMessage: selector receiver: receiver source: source
        AstSend receiver: (receiver visitBy: self)
                selector: selector
                arguments: []
                source: source!

    method visitBinaryMessage: selector receiver: receiver argument: argument source: source
        AstSend receiver: (receiver visitBy: self)
                selector: selector
                arguments: [argument visitBy: self]
                source: source!

    method visitKeywordMessage: selector receiver: receiver arguments: arguments source: source
        AstSend receiver: (receiver visitBy: self)
                selector: selector
                arguments: (arguments
                                collect: { |arg|  arg visitBy: self })
                source: source!

    method visitIsLeft: left right: right
        AstIs left: (left visitBy: self)
              right: (right visitBy: self)!

    method visitSelf
        AstSelfRef new!

    method visitVariable: name
        env reference: name!

    method visitAssign: value to: variable
        let binding = env reference: variable name.
        AstLexicalSet
            name: variable name
            frame: binding frame :: Integer
            index: binding index :: Integer
            value: (value visitBy: self)!

    method visitParens: body
        body visitBy: self!

    method visitBlockWith: parameters body: body
        let bodyEnv = env newFrame addVariables: parameters.
        AstBlock
            body: (body visitBy: (SyntaxTranslator env: bodyEnv))
            argumentCount: parameters size
            frameSize: parameters size + bodyEnv allocation size!

    method visitDefine: name body: body
        -- FIXME: Is this right?? Should body not gets an environment of its own?
        AstDefine
            name: name
            body: (body visitBy: self)
            frameSize: env allocation size!

    method visitMethodDefinition: signature body: body
        let bodyEnv = env newFrame addVariables: signature parameters.
        AstMethod
            selector: signature selector name
            argumentCount: signature parameters size
            body: (body visitBy: (SyntaxTranslator env: bodyEnv))
            frameSize: bodyEnv allocation size!

    method visitClassDefinition: name directMethods: directMethods slots: slots methods: methods
        let astDirectMethods = directMethods collect: { |m| m visitBy: self }.
        let instanceMethodVisitor = SyntaxTranslator env: (env addSlots: slots).
        let astMethods = methods collect: { |m| m visitBy: instanceMethodVisitor }.
        AstClass
            name: name
            directMethods: astDirectMethods
            slots: slots
            methods: astMethods!
end

interface Syntax
    is Object

    required method visitBy: visitor

    required method parts

    method checkEqualInternal: other
        self parts with: other parts
                   do: #checkEqual:!

    method isEquivalent: other
        self parts with: other parts
                   do: { |a b| a == b ifFalse: { return False } }.
        True!

    method toString
        let out = StringOutput new.
        SyntaxPrinter print: self to: out.
        out content!
end

class SyntaxLiteral { value }
    is Syntax

    method visitBy: visitor
        visitor visitLiteral: value!

    method parts
        [value]!
end

class SyntaxSeq { first then }
    is Syntax

    method visitBy: visitor
        visitor visitSeqFirst: first then: then!

    method parts
        [first, then]!
end

class SyntaxReturn { value }
    is Syntax

    method visitBy: visitor
        visitor visitReturn: value!

    method parts
        [value]!
end

class SyntaxPrefixComment { comment value source }
    is Syntax

    method visitBy: visitor
        visitor visitPrefixComment: self comment
                value: self value
                source: self source!

    method parts
        -- Source left out intentionally, since it doesn't need to compere equal.
        [self comment, self value]!
end

class SyntaxSuffixComment { comment value source }
    is Syntax

    method visitBy: visitor
        visitor visitSuffixComment: self comment
                value: self value
                source: self source!

    method parts
        -- Source left out intentionally, since it doesn't need to compere equal.
        [comment, value]!
end

class SyntaxPrefix { receiver selector source }
    is Syntax

    method visitBy: visitor
        visitor visitPrefixMessage: selector
                receiver: receiver
                source: source!

    method parts
        -- Source left out intentionally, since it doesn't need to compere equal.
        [receiver, selector]!
end

class SyntaxUnary { receiver selector source }
    is Syntax

    method visitBy: visitor
        visitor visitUnaryMessage: selector
                receiver: receiver
                source: source!

    method parts
        -- Source left out intentionally, since it doesn't need to compere equal.
        [receiver, selector]!
end

class SyntaxBinary { receiver selector argument source }
    is Syntax

    method visitBy: visitor
        visitor visitBinaryMessage: selector
                receiver: receiver
                argument: argument
                source: source!

    method parts
        -- Source left out intentionally, since it doesn't need to compere equal.
        [receiver, selector, argument]!
end

-- FIXME: Currently multi-keyword syntax gets as source the first
-- keyword only. Should support non-contigous source regions for this.
class SyntaxKeyword { receiver selector arguments source }
    is Syntax

    method visitBy: visitor
        visitor visitKeywordMessage: selector
                receiver: receiver
                arguments: arguments
                source: source!

    method parts
        -- Source left out intentionally, since it doesn't need to compere equal.
        [receiver, selector, arguments]!
end

class SyntaxIs { left right }
    is Syntax

    method visitBy: visitor
        visitor visitIsLeft: left
                right: right!

    method parts
        [left, right]!
end

class SyntaxLet { name value body }
    is Syntax

    method visitBy: visitor
        visitor visitLet: name
                value: value
                body: body!

    method parts
        [value, name, body]!
end

class SyntaxSelf {}
    is Syntax

    method visitBy: visitor
        visitor visitSelf!

    method parts
        []!
end

class SyntaxVariable { name::String }
    is Syntax

    method visitBy: visitor
        visitor visitVariable: name!

    method parts
        [name]!
end

class SyntaxAssign { variable::String value }
    is Syntax

    method visitBy: visitor
        visitor visitAssign: value to: variable!

    method parts
        [variable, value]!
end

class SyntaxParens { body }
    is Syntax

    method visitBy: visitor
        visitor visitParens: body!

    method parts
        [body]!
end

class SyntaxBlock { arguments body }
    is Syntax

    method visitBy: visitor
        visitor visitBlockWith: arguments body: body!

    method parts
        [arguments, body]!
end

class SyntaxDefine { name body }
    is Syntax

    method visitBy: visitor
        visitor visitDefine: name body: body!

    method parts
        [name, body]!
end

class SyntaxMethod { signature body }
    is Syntax

    method visitBy: visitor
        visitor
            visitMethodDefinition: signature
            body: body!

    method selector
        signature selector!

    method parts
        [signature, body]!
end

class MethodSignature { selector parameters }
    is Object

    method isEquivalent: other
        selector == other selector and: parameters == other parameters!
end

class SyntaxClass { name directMethods slots methods }
    is Syntax

    method visitBy: visitor
        visitor visitClassDefinition: name
                directMethods: directMethods
                slots: slots
                methods: methods!

    method parts
        [name, directMethods, slots, methods]!
end

interface Source
    is Object
end

class SourceString { string first last }

    method location
        first to: last!

    method doLines: block
        let newline = 0.
        string
            doLines: { |line|
                       let linestart = newline + 1.
                       let linestop = linestart + line size - 1.
                       newline = linestop + 1.
                       block
                           value: linestart
                           value: linestop
                           value: line }!

    method findContext
        let leadingContext = 2.
        let trailingContext = 2.
        let totalContext = leadingContext + trailingContext.
        let context = List newOf: Record.
        let lineNumber = 0.
        let inMatch = False.
        self
            doLines: { |from to line|
                       lineNumber = lineNumber + 1.
                       first > to
                           ifTrue: { context size >= leadingContext
                                         ifTrue: { context popFirst }.
                                     context
                                         push: { lineNumber: lineNumber,
                                                 underline: False,
                                                 line: line } }.
                       last < from
                           ifTrue: { context size < totalContext
                                         ifTrue: { context
                                                       push: { lineNumber: lineNumber,
                                                               underline: False,
                                                               line: line } }.
                                     inMatch = False }.
                       (from <= first and: first <= to)
                           ifTrue: { inMatch = True }.
                       inMatch
                           ifTrue: { totalContext = totalContext + 1.
                                     context push: { lineNumber: lineNumber,
                                                     underline: { from: (first - from + 1 max: 1),
                                                                  to: (last - from + 1 min: line size) },
                                                     line: line } } }.
        context!

    method underlineFrom: from to: to note: note in: output
        output print: "    ". -- line number
        output print: (" " repeat: from - 1).
        output print: ("^" repeat: (to - from + 1)).
        note
            ifEmpty: { output newline }
            ifNotEmpty: { output print: " ".
                          output println: note }!

    method note: note
        let output = StringOutput new.
        self findContext
            do: { |ctxLine|
                  output print: (ctxLine lineNumber leftPad: 3 by: "0").
                  output print: " ".
                  output println: ctxLine line.
                  ctxLine underline is False
                      ifFalse: { self
                                     underlineFrom: ctxLine underline from
                                     to: ctxLine underline to
                                     note: note
                                     in: output } }.
        output content!

    method toString
        self note: ""!

end

define SeqPrecedence
    1!

define SingleExpressionPrecedence
    2! -- dot has precedence 2

define KeywordPrecedence
    9!

define UnknownOperatorPrecedence
    10!

define PrefixPrecedence
    1000!

define UnaryPrecedence
    1000!

define TokenPrecedence
    let tokens = Dictionary new.
    tokens put: 90 at: "*".
    tokens put: 90 at: "/".
    tokens put: 80 at: "-".
    tokens put: 80 at: "+".
    tokens put: 10 at: "is".
    tokens put: 4 at: "=".
    tokens put: 3 at: "let".
    tokens put: 3 at: "(".
    tokens put: 3 at: "\{".
    tokens put: 2 at: ".".
    tokens put: 1 at: "!".
    tokens put: 0 at: ")".
    tokens put: 0 at: "}".
    tokens put: 0 at: "define".
    tokens put: 0 at: "class".
    tokens!

interface Token
    is Object

    direct method from: first to: last in: parser
        self
            string: (parser source from: first to: last)
            first: first last: last!

    method precedence
        Error raise: "{self string} is not valid in suffix position in self-hosted parser!"!

    method parseAsSuffixOf: prefix with: parser
        Error raise: "Self-hosted parser cannot parse {self} ({self first}) in suffix position!"!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        Error raise: "Self-hosted parser cannot parse {self} ({self first}) in prefix position!"!

    method toString
        "#<Token \"{self string}\">"!
end

interface SuffixToken
    is Token

    method precedence
        TokenPrecedence
            at: self string
            ifNone: { UnknownOperatorPrecedence }!
end

class TokenDecimal { string first last }
    is Token

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let n = 0.
        1 to: string size
          do: { |pos|
                n = n * 10 + (string at: pos) digit }.
        SyntaxLiteral value: n!
end

class TokenEof { position }
    is Token

    direct method at: position in: parser
        self position: position!

    method precedence
        0!

    method string
        "EOF"!
end

interface ReservedToken
    is SuffixToken
    direct method string: string first: first last: last
        self first: first last: last!
end

class TokenReservedWordDefine { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let def = SyntaxDefine
                      name: parser parseVariableName
                      body: (parser parseAtPrecedence: SeqPrecedence).
        parser expect: "!".
        def!

    method string
        "define"!
end

class TokenReservedWordEnd { first last }
    is ReservedToken

    method string
        "end"!
end

class TokenReservedWordIs { first last }
    is ReservedToken

    method parseAsSuffixOf: prefix with: parser
        SyntaxIs
            left: prefix
            right: (parser parseAtPrecedence: SingleExpressionPrecedence)!

    method string
        "is"!
end

class TokenReservedWordReturn { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxReturn
            value: (parser parseAtPrecedence: SingleExpressionPrecedence)!

    method string
        "return"!
end

class TokenReservedWordLet { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let name = parser parseVariableName.
        parser expect: "=".
        let value = (parser parseAtPrecedence: SingleExpressionPrecedence).
        parser expect: ".".
        SyntaxLet
            name: name
            value: value
            body: (parser parseAtPrecedence: SeqPrecedence)!

    method string
        "let"!
end

class TokenReservedSigilDot { first last }
    is ReservedToken

    method parseAsSuffixOf: prefix with: parser
        SyntaxSeq
            first: prefix
            then: (parser parseAtPrecedence: SeqPrecedence)!

    method string
        "."!
end

class TokenReservedSigilOpenParen { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let body = parser parseAtPrecedence: SeqPrecedence.
        parser expect: ")".
        SyntaxParens
            body: body!

    method string
        "("!
end

class TokenReservedSigilCloseParen { first last }
    is ReservedToken
    method string
        ")"!
end

class TokenReservedSigilOpenBrace { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let arguments = List new.
        parser
            when: "|"
            then: { parser until: "|"
                           do: { arguments add: (parser parseVariableName) } }.
        let body = parser parseAtPrecedence: SeqPrecedence.
        parser expect: "}".
        SyntaxBlock arguments: arguments body: body!

    method string
        "\{"!
end

class TokenReservedSigilCloseBrace { first last }
    is ReservedToken

    method precedence
        0!

    method string
        "}"!
end

class TokenReservedSigilEqual { first last }
    is ReservedToken

    method parseAsSuffixOf: prefix with: parser
        SyntaxAssign
            variable: prefix::SyntaxVariable
            value: (parser parseAtPrecedence: SingleExpressionPrecedence)!

    method string
        "="!
end

class TokenReservedSigilDoubledash { first last }
    is ReservedToken

    ---
    FIXME: see below.

    -- Prefix comments make sense
    some expression.

    another expression. -- But what is intended as a suffix comment
                        -- to `another expression` becomes a prefix
                        -- comment to `next expression`!
    next expression
    ---

    method parseAsPrefixWith: parser atPrecedence: precedence
        -- NOTE: must continue at same precedence! Consider eg.
        --
        --    let x = -- comment
        --            -42 abs.
        --    123
        --
        -- where the comment while parsing at SingleExpressionPrecedence!
        SyntaxPrefixComment
            comment: parser readline
            value: (parser parseAtPrecedence: precedence)
            source: (parser sourceFrom: first to: last)!

    method parseAsSuffixOf: prefix with: parser
        SyntaxSuffixComment
            comment: parser readline
            value: prefix
            source: (parser sourceFrom: first to: last)!

    method string
        "--"!
end

class TokenReservedWordSelf { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxSelf new!
end

class TokenReservedWordClass { first last }
    is ReservedToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        let name = parser parseVariableName.

        let slots = List new.
        parser expect: "\{".
        parser until: "}"
               do: { slots add: parser parseVariableName }.

        let directMethods = List new.
        let methods = List new.
        parser until: "end"
               do: { parser while: "direct"
                            do: { parser expect: "method".
                                  directMethods add: (self parseMethodWith: parser) }.
                     parser while: "method"
                            do: { methods add: (self parseMethodWith: parser) } }.

        SyntaxClass
            name: name
            directMethods: directMethods
            slots: slots
            methods: methods!

    method parseMethodWith: parser
        let syntax = SyntaxMethod
            signature: (self parseMethodSignatureWith: parser)
            body: (parser parseAtPrecedence: SeqPrecedence).
        parser expect: "!".
        syntax!

    method parseMethodSignatureWith: parser
        let selector = StringOutput new.
        let parameters = List new.
        parser nextToken
            parseAsMethodSignatureWith: parser
            selector: selector
            parameters: parameters.
        MethodSignature
            selector: (Selector new: selector content)
            parameters: parameters!

    method string
        "class"!
end

define ReservedTokens
    let tokens = Dictionary new.
    tokens put: TokenReservedSigilCloseBrace at: "}".
    tokens put: TokenReservedSigilCloseParen at: ")".
    tokens put: TokenReservedSigilDot at: ".".
    tokens put: TokenReservedSigilEqual at: "=".
    tokens put: TokenReservedSigilOpenBrace at: "\{".
    tokens put: TokenReservedSigilOpenParen at: "(".
    tokens put: TokenReservedWordClass at: "class".
    tokens put: TokenReservedWordDefine at: "define".
    tokens put: TokenReservedWordIs at: "is".
    tokens put: TokenReservedWordLet at: "let".
    tokens put: TokenReservedWordSelf at: "self".
    tokens put: TokenReservedWordReturn at: "return".
    tokens put: TokenReservedSigilDoubledash at: "--".
    tokens!

interface LookupToken
    is SuffixToken

    direct method from: first to: last in: parser
        let tokenString = parser source from: first to: last.
        -- Reserved words get their own classes!
        let tokenClass = ReservedTokens
                             at: tokenString
                             ifNone: { Self }.
        tokenClass string: tokenString first: first last: last!
end

class TokenSigil { string first last }
    is LookupToken

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxPrefix
            receiver: (parser parseAtPrecedence: PrefixPrecedence)
            selector: (Selector name: string)
            source: (parser sourceFrom: first to: last)!

    method parseAsSuffixOf: prefix with: parser
        SyntaxBinary
            receiver: prefix
            selector: (Selector name: string)
            argument: (parser parseAtPrecedence: (self precedence))
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        parameters add: parser parseVariableName!
end

class TokenWord { string first last }
    is LookupToken

    method precedence
        UnaryPrecedence!

    direct method from: first to: last in: parser
        let tokenString = parser source from: first to: last.
        -- Reserved words get their own classes!
        let tokenClass = ReservedTokens
                             at: tokenString
                             ifNone: { TokenWord }.
        tokenClass string: tokenString first: first last: last!

    method parseAsPrefixWith: parser atPrecedence: _precedence
        SyntaxVariable
            name: string!

    method parseAsSuffixOf: prefix with: parser
        SyntaxUnary
            receiver: prefix
            selector: (Selector name: string)
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        string == "prefix"
            ifTrue: { let op = parser nextToken.
                      (TokenSigil includes: op)
                          ifFalse: { Error raise: "Expected prefix sigil, got: {op string}" }.
                      selector print: op string }!
end

class TokenKeyword { string first last }
    is SuffixToken

    method precedence
        KeywordPrecedence!

    method parseAsSuffixOf: prefix with: parser
        let arguments = List new.
        let selector = StringOutput new: string.
        { arguments push: (parser parseAtPrecedence: (self precedence)).
          let token = parser lookahead.
          (TokenKeyword includes: token)
              ifTrue: { parser nextToken.
                        selector print: token string.
                        True } }
        whileTrue.
        SyntaxKeyword
            receiver: prefix
            selector: (Selector name: selector content)
            arguments: arguments
            source: (parser sourceFrom: first to: last)!

    method parseAsMethodSignatureWith: parser selector: selector parameters: parameters
        selector print: string.
        parameters add: parser parseVariableName.
        (TokenKeyword includes: parser lookahead)
            ifTrue: { parser nextToken
                          parseAsMethodSignatureWith: parser
                          selector: selector
                          parameters: parameters }!
end

define SpecialCharacters
    ["(" character,
     ")" character,
     "[" character,
     "]" character,
     "\{" character,
     "}" character,
     "!" character,
     "." character,
     ";" character,
     "," character]!

define UnderscoreCharacter
    "_" character!

define ColonCharacter
    ":" character!

-- FIXME: Broken for unicode input!
class Parser { source::String
               position::Integer
               first::Integer
               last::Integer
               lookahead::List }
    is Object

    direct method new: source
        source
            ifEmpty: { Error raise: "Cannot parse empty string!" }.
        self
            source: source
            position: 1
             first: 1
             last: (source size)
             lookahead: List new!

    direct method parse: source
        let parser = self new: source.
        let syntax = List new.
        { parser skipWhitespace. parser atEof }
            whileFalse: { syntax add: (parser parse) }.
        -- syntax do: { |s| Debug println: "=> {s}" }.
        syntax!

    method readline
        let start = position.
        { self atEof or: self atNewline }
            whileFalse: { self advance }.
        let stop = position - 1.
        self advance.
        source from: start to: stop!

    method sourceFrom: first to: last
        SourceString string: source first: first last: last!

    method parse
        self parseAtPrecedence: 0!

    method parseVariableName
        let token = self nextToken.
        (TokenWord includes: token)
            ifFalse: { Error raise: "Invalid variable name in self-hosted parser: {token string}" }.
        token string!

    method expect: expected
        let got = self nextToken string.
        got == expected
            ifFalse: { Error raise: "Self-hosted parser expected '{expected}', got '{got}'
Context: {source}" }!

    method when: test then: action
        self lookahead string == test
            ifTrue: { self nextToken. action value }!

    method until: test do: action
        { self lookahead string == test }
            whileFalse: action.
        self nextToken!

    method while: test do: action
        { self lookahead string == test }
            whileTrue: { self nextToken. action value }!

    method parseAtPrecedence: precedence
        self
            parseSuffixOf: (self parsePrefixAtPrecedence: precedence)
            with: precedence!

    method parsePrefixAtPrecedence: precedence
        self nextToken parseAsPrefixWith: self atPrecedence: precedence!

    method parseSuffixOf: prefix with: precedence
        let expr = prefix.

        { -- Debug println: "expr: {expr}, precedence={precedence}, next={self lookahead}? {self nextPrecedence}".
          precedence < self nextPrecedence }
        whileTrue: { -- Debug println: " -> go".
                     expr = self parseSuffixOf: expr }.
        -- Debug println: " -> no".
        expr!

    method parseSuffixOf: prefix
        self nextToken parseAsSuffixOf: prefix with: self!

    method nextPrecedence
        self lookahead precedence!

    method lookahead
        lookahead
            ifEmpty: { lookahead push: self scanNext }.
        lookahead first!

    method nextToken
        lookahead isEmpty
            ifTrue: { self scanNext }
            ifFalse: { lookahead pop }!

    method scanNext
        self skipWhitespace.
        self atEof
            ifTrue: { return TokenEof at: position in: self }.
        self atSpecial
            ifTrue: { return self scanSpecial }.
        self atDigit
            ifTrue: { return self scanDecimal }.
        self atSigil
            ifTrue: { return self scanSigil }.
        self atWord
            ifTrue: { return self scanWord }.
        Error raise: "Don't know how to scan pos: {position} in: {source}"!

    method atEof
        position > last!

    method atSpecial
        self isAt: { |char|
                     SpecialCharacters
                         anySatisfy: { |special| special == char } }!

    method atDigit
        self isAt: #isDigit!

    method atWord
        self isAt: { |char|
                     char isAlphanumeric or: char == UnderscoreCharacter }!

    method atTerminating
        self atSpecial or: self atWhitespace!

    method atNewline
        self isAt: #isNewline!

    method atSigil
        self atEof not
            ifTrue: { (self atWord or: self atTerminating) not }!

    method atWhitespace
        self isAt: #isWhitespace!

    method atChar: char1 thenNot: char2
        self atEof
            ifTrue: { return False }.
        (source at: position) == char1
            ifFalse: { return False }.
        (position + 1 > last)
            ifFalse: { ((source at: position + 1) == char2) not }!

    method isAt: block
        self atEof
            ifTrue: { False }
            ifFalse: { block value: (source at: position) }!

    method skipWhile: test
        -- Debug println: "/skipWhile: {test}".
        let start = position.
        { test value: self }
            whileTrue: { self advance }.
        position - 1!

    method skipWhitespace
        self skipWhile: #atWhitespace!

    method scanSpecial
        -- Debug println: "/scanSpecial".
        let start = position.
        self advance.
        TokenSigil
            from: start
            to: start
            in: self!

    method scanDecimal
        -- Debug println: "/scanDecimal".
        TokenDecimal
            from: position
            to: (self skipWhile: #atDigit)
            in: self!

    method scanSigil
        -- Debug println: "/scanSigil".
        TokenSigil
            from: position
            to: (self skipWhile: #atSigil)
            in: self!

    method scanWord
        -- Debug println: "/scanWord".
        let first = position.
        self skipWhile: #atWord.
        (self atChar: ColonCharacter thenNot: ColonCharacter)
            ifTrue: { self advance.
                      TokenKeyword
                          from: first
                          to: position - 1
                          in: self }
            ifFalse: { TokenWord
                           from: first
                           to: position - 1
                           in: self }!

    method advance
        position <= last
            ifFalse: { panic "Tried to advance beyond end: \"{source}\"" }.
        position = position + 1!

end

class Tests { ok }

    direct method run
        (self ok: True) run!

    method test: selector
        { Debug print: selector name.
          selector sendTo: self.
          Debug println: " ok" }
            on: Error
            do: { |e|
                  Debug println: " FAILED:\n{e description}".
                  ok = False.
                  return False }.
        True!

    method run
        self
            ; test: #test42
            ; test: #testPlus
            ; test: #testPrecedence
            ; test: #testPrefixMethod
            ; test: #testUnaryMethod
            ; test: #testKeywordMethod
            ; test: #testIs
            ; test: #testLet
            ; test: #testPrecedence2
            ; test: #testParens
            ; test: #testAssign1
            ; test: #testAssign2
            ; test: #testSimpleBlock
            ; test: #testArgBlock
            ; test: #testBlockClosure
            ; test: #testDefine
            ; test: #testSimpleClass
            ; test: #testClassWithMethod
            ; test: #testClassWithPrefixMethod
            ; test: #testTwoClasses
            ; test: #testBlockInMethod
            ; test: #testDirectMethod
            ; test: #testReturn
            ; test: #testComment
            ; test: #testAstSource
            ; test: #testOutOfOrderDefine
            ; test: #testOutOfOrderClasses
               .
        self!

    method parse: source
        -- Check Syntax print/parse consistency.
        let syntaxList = Parser parse: source.
         let output = StringOutput new.
        syntaxList do: { |syntax|
                         -- Debug println: "".
                         -- SyntaxPrinter print: syntax to: Output debug.
                         output print: syntax toString }.
        let printed = output content.
        { syntaxList checkEqual: (Parser parse: printed) }
            on: Error
            do: { |err|
                  panic "CST print/parse inconsistency!
original: {source}
printed: {printed}
problem: {err description}" }.
        syntaxList!

    method load: defSource eval: exprSource
        let env = Environment new.
        env load: defSource.
        env eval: exprSource!

    method load: defSource eval: exprSource expect: expected
        let result = self load: defSource eval: exprSource.
        (result == expected)
            ifFalse: { Error raise: "Expected {expected}, got: {result}
from: {exprSource}
with: {defSource}" }!

    method load: defSource eval: exprSource expectError: type where: test
        { self load: defSource eval: exprSource }
            on: type
            do: { |err|
                  (test value: err)
                      ifTrue: { return True }
                      ifFalse: { Error raise: "Error did not match expectations: {err description}
from: {exprSource}
with: {defSource}" }}.
        Error raise: "Expected error, didn't get one
from: {exprSource}
with: {defSource}"!

    method eval: exprSource expect: expected
        let process = Process new.
        let result = False.
        (self parse: exprSource)
            do: { |expr|
                  let env = Environment new.
                  result = (SyntaxTranslator translate: expr in: env)
                      evalWith: (InterpreterContext new: env allocation size)
                      in: process }.
        (result == expected)
            ifFalse: { Error raise: "Expected {expected}, got: {result}
from: '{expr}'" }!

    method test42
        self eval: "42" expect: 42!
    method testPlus
        self eval: "100 + 1000 + 10 + 1" expect: 1111!
    method testPrecedence
        self eval: "12 + 10 * 10 - 1" expect: 111!
    method testPrefixMethod
        self eval: "- 42" expect: -42!
    method testUnaryMethod
        self eval: "- 42 abs" expect: 42!
    method testKeywordMethod
        self eval: "1 to: 10 by: 2" expect: (1 to: 10 by: 2)!
    method testIs
        self eval: "1 is 1" expect: True.
        self eval: "1 is 2" expect: False!
    method testLet
        self eval: "let x = 1. x + x"
             expect: 2!
    method testPrecedence2
        self eval: "let x = -40. let y = -2. x abs + y abs" expect: 42!
    method testParens
        self eval: "(1 + 1) * 2"
             expect: 4!
    method testAssign1
        self eval: "let x = 20. x = x + 1. x * 2"
             expect: 42!
    method testAssign2
        self eval: "let y = 0.
                    let x = 20.
                    (let x = 2000. x = x + 100. y = x * 2).
                    x = x + 1. y + x * 2"
            expect: 4242!
    method testSimpleBlock
        self eval: "\{ 32 + 10 } value"
             expect: 42!
    method testArgBlock
        self eval: "\{ |x| x + 1 } value: 41"
             expect: 42!
    method testBlockClosure
        self eval: "let block = (let x = 21. \{ x = x * 2 }).
                    let x = 0.
                    block value. block value"
            expect: 84!
    method testDefine
        self load: "define FourtyTwoForTestDefine
                       42!"
             eval: "FourtyTwoForTestDefine"
             expect: 42!
    method testSimpleClass
        self load: "class MyClass \{ x } end"
             eval: "let c = MyClass x: 42. c x"
             expect: 42.
         self load: "class MyClass \{ x y } end"
             eval: "let c = MyClass x: 40 y: 2. c x + c y"
             expect: 42!
    method testClassWithMethod
        self load: "class MyClass \{ slot }
                        method foo: x
                           slot + x!
                    end"
             eval: "(MyClass slot: 40) foo: 2"
             expect: 42!
    method testClassWithPrefixMethod
        self load: "class MyClass \{ slot }
                        method prefix%
                            slot * slot!
                    end"
             eval: "%(MyClass slot: -2)"
             expect: 4!
    method testTwoClasses
        self load: "class Class1 \{ slot }
                        method foo: x
                           x bar + slot * 2!
                    end
                    class Class2 \{ slot }
                        method bar
                           slot!
                        method foo: y
                           y foo: self!
                    end"
             eval: "(Class2 slot: 2) foo: (Class1 slot: 20)"
             expect: 42!
    method testBlockInMethod
        self load: "class ClassAA \{ slot }
                        method capture: x
                           \{ x }!
                        method captureSlot
                           \{ slot }!
                        method capture
                           let z = 2.
                           \{ (self captureSlot) value + (self capture: z) value }!
                    end
                    class ClassBB \{ slot }
                        method ctor: x
                           \{ (ClassAA slot: x + slot) }!
                        method run: x
                           (self ctor: x * 2) value capture value!
                    end"
             eval: "(ClassBB slot: 20) run: 10"
             expect: 42!
    method testDirectMethod
        self load: "class ClassDirectMethod \{}
                        direct method gimme1
                            self new gimme2!
                        method gimme2
                            42!
                    end"
             eval: "ClassDirectMethod gimme1"
             expect: 42!
    method testReturn
        self load: "class ReturnTest \{}
                        direct method test: ok
                            ok
                               ifTrue: \{ return 42 }.
                            666!
                    end"
            eval: "ReturnTest test: True"
            expect: 42!
    method testComment
        self load: "class CommentTest1 \{}
                       method foo
                          let x = -- boop
                                  21.
                          x * 2!
                    end"
            eval: "CommentTest1 new foo"
            expect: 42.
        self load: "class CommentTest2 \{}
                       method foo
                          let x = 21 -- boop
                          .
                          x * 2!
                    end"
            eval: "CommentTest2 new foo"
            expect: 42!
    method testAstSource
        self load: "class SourceTest \{}
                         method foo
                            let x = 1 + 2.
                            self bar: x
                                 quux: x.
                            self quux.
                            self zot.
                            2 + 3!
                    end"
            eval: "SourceTest new foo"
            expectError: DoesNotUnderstand
            where: { |e|
                     -- FIXME: this is only for "bar:", should include the
                     -- whole selector!
                     e source location == (133 to: 136) } !
    method testOutOfOrderDefine
        self load: "define Two
                       One + One!
                    define One
                       1!"
            eval: "Two"
            expect: 2!
    method testOutOfOrderClasses
        self load: "class Two \{}
                       direct method fini
                          42!
                       method test
                          One new test!
                    end
                    class One \{}
                      method test
                          Two fini!
                    end"
            eval: "Two new test"
            expect: 42!
end

class Main {}
    direct method run: cmd in: system
        system output
            println: (Tests run ok
                          ifTrue: { "All tests ok!" }
                          ifFalse: { "Tests failed!" })!
end
