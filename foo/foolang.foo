class Debug {}
    class method println: what
        Output debug println: what
end

class HostMethod { receiver selector }
    method invoke: arguments
        selector sendTo: receiver with: arguments
end

class Process {}
    is Object
end

class InterpreterContext {}
    is Object
end

define EmptyInterpreterContext
    InterpreterContext new
end

class Environment {}
    is Object
end

define EmptyEnvironment
    Environment new
end

class AstConstantRef { value }
    is Object
    method evalWith: context in: process
        value
end

class AstSend {
        receiver
        selector
        arguments
    }
    method evalWith: context in: process
        let receiver = receiver evalWith: context in: process.
        (self getMethod: selector for: receiver)
            invoke: (arguments
                         collect: { |arg|
                                    arg evalWith: context in: process })

    method getMethod: selector for: receiver
        -- Later this will distinguish between host and interpreter methods.
        HostMethod receiver: receiver selector: selector

end

class SyntaxLiteral { value }
    is Object
    method translateIn: environment
        AstConstantRef value: value
    method toString
        value toString
end

class SyntaxPrefix { receiver selector }
    is Object
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: (Selector name: "prefix{selector name}")
                arguments: []
    method toString
        "({selector name} {receiver})"
end

class SyntaxUnary { receiver selector }
    is Object
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: selector
                arguments: []
end

class SyntaxBinary { receiver selector argument }
    is Object
    method translateIn: environment
        AstSend receiver: (receiver translateIn: environment)
                selector: selector
                arguments: [argument translateIn: environment]
    method toString
        "({receiver} {selector name} {argument})"
end

define UnknownOperatorPrecedence
    10
end

define PrefixPrecedence
    1000
end

define TokenPrecedence
    let tokens = Dictionary new.
    tokens put: 90 at: "*".
    tokens put: 90 at: "/".
    tokens put: 80 at: "-".
    tokens put: 80 at: "+".
    tokens
end

interface Token
    is Object

    class method from: first to: last in: parser
        self
            string: (parser source from: first to: last)
            first: first last: last

    method precedence
        TokenPrecedence
            at: string
            ifNone: { UnknownOperatorPrecedence }

    method toString
        "#<Token {string}>"
end

class TokenDecimal { string first last }
    is Token

    method precedence
        Error raise: "{string} is not valid in suffix position!"

    method parseAsPrefixWith: parser
        let n = 0.
        1 to: string size
          do: { |pos|
                n = n * 10 + (string at: pos) digit }.
        SyntaxLiteral value: n
end

class TokenEof { position }
    is Token

    class method at: position in: parser
        self position: position

    method precedence
        0

    method toString
        "#<TokenEof>"
end

class TokenSigil { string first last }
    is Token

    method parseAsPrefixWith: parser
        SyntaxPrefix
            receiver: (parser parseWithPrecedence: PrefixPrecedence)
            selector: (Selector name: string)

    method parseAsSuffixOf: prefix with: parser
        SyntaxBinary
            receiver: prefix
            selector: (Selector name: string)
            argument: (parser parseWithPrecedence: (self precedence))
end

class TokenWord { string first last }
    is Token

    method parseAsSuffixOf: prefix with: parser
        SyntaxUnary
            receiver: prefix
            selector: (Selector name: string)
end

define SpecialCharacters
    ["(" character,
     ")" character,
     "[" character,
     "]" character]
end

define UnderscoreCharacter
    "_" character
end

-- FIXME: Broken for unicode input!
class Parser { source position first last lookahead }
    is Object
    class method parse: source
        (self
             source: source
             position: 1
             first: 1
             last: (source size)
             lookahead: List new)
        parse

    method parse
        self parseWithPrecedence: 0

    method parseWithPrecedence: precedence
        self parseSuffixOf: self parsePrefix with: precedence

    method parsePrefix
        self nextToken parseAsPrefixWith: self

    method parseSuffixOf: prefix with: precedence
        let expr = prefix.
        { precedence < self nextPrecedence }
            whileTrue: { expr = self parseSuffixOf: expr }.
        expr

    method parseSuffixOf: prefix
        self nextToken parseAsSuffixOf: prefix with: self

    method nextPrecedence
        self lookahead precedence

    method lookahead
        lookahead
            ifEmpty: { lookahead push: self scanNext }.
        lookahead first

    method nextToken
        lookahead isEmpty
            ifTrue: { self scanNext }
            ifFalse: { lookahead pop }.

    method scanNext
        self skipWhitespace.
        self atEof
            ifTrue: { return TokenEof at: position in: self }.
        self atDigit
            ifTrue: { return self scanDecimal }.
        self atSigil
            ifTrue: { return self scanSigil }.
        self atWord
            ifTrue: { return self scanWord }.
        Error raise: "Don't know how to scan pos: {position} in: {source}"

    method atEof
        position > last

    method atSpecial
        self isAt: { |char|
                     SpecialCharacters
                         anySatisfy: { |special| special == char } }

    method atDigit
        self isAt: #isDigit

    method atWord
        self isAt: { |char|
                     char isAlphanumeric or: char == UnderscoreCharacter }

    method atTerminating
        self atSpecial or: self atWhitespace

    method atSigil
        (self atWord or: self atTerminating) not

    method atWhitespace
        self isAt: #isWhitespace

    method isAt: block
        self atEof
            ifTrue: { False }
            ifFalse: { block value: (source at: position) }

    method skipWhile: test
        let start = position.
        { test value: self }
            whileTrue: { self advance }.
        position - 1

    method skipWhitespace
        self skipWhile: #atWhitespace

    method scanDecimal
        TokenDecimal
            from: position
            to: (self skipWhile: #atDigit)
            in: self.

    method scanSigil
        TokenSigil
            from: position
            to: (self skipWhile: #atSigil)
            in: self.

    method scanWord
        TokenWord
            from: position
            to: (self skipWhile: #atWord)
            in: self.

    method advance
        position <= last assert: "can advance".
        position = position + 1.

end

extend String
    method parse
        Parser parse: self
    method eval
        (self parse translateIn: EmptyEnvironment)
            evalWith: EmptyInterpreterContext
            in: Process new.
end

class Tests {}
    class method run
        self new run
    method run
        self
            ; test42
            ; testPlus
            ; testPrecedence
            ; testPrefixMethod
            ; testUnaryMethod
    method test42
        ("42" eval == 42) assert: "Constant evaluation".
    method testPlus
        ("100 + 1000 + 10 + 1" eval == 1111) assert: "Constant addition".
    method testPrecedence
        ("12 + 10 * 10 - 1" eval == 111) assert: "Binary precedence".
    method testPrefixMethod
        ("- 42" eval == -42) assert: "Prefix method".
    method testUnaryMethod
        ("- 42 abs" eval == 42) assert: "Unary method".
end

class Main {}
    class method run: cmd in: system
        Tests run.
        system output println: "ok!"
end
