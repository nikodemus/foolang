import lib.assert.Assert
import lib.si.SI_Tests
import lang.array.TestArray
import lang.closure.TestClosure
import lang.record.TestRecord
import lang.filepath.TestFilePath
import lang.filestream.TestFileStream

-- Generates signed integers small enough to add without overflowing.
class SmallIntegers {}
    direct method do: block
        -- First around zero
        block value: -1.
        block value: 0.
        block value: 1.
        -- Then random numbers
        let rng = Random new.
        100 times: { block value: (rng integer / 2) }!
end

class ShortStringSeqs {}
   direct method do: block
      -- FIXME: actual random generation, please
      block value: [].
      block value: [""].
      block value: ["", ""].
      block value: ["", "", ""].
      block value: ["123", "", ""].
      block value: ["", "123", ""].
      block value: ["", "", "123"]!
end

class Floats {}
   direct method do: block
      block value: -0.0.
      block value: 0.0.
      block value: 1.0.
      block value: -1.0.
      block value: 0.1.
      block value: -0.1.
      let rng = Random new.
      100 times: { block value: rng float }!
end

class Box { value }
    method *** other
        self value * other!
    method * other
        self value * other!
    method + other
        self value + other!
    method prefix-
        - (self value)!
end

define $testVar
    123!

class TestVar {}
    direct method read
        $testVar!
end

class Main { assert system }
    direct method run: cmd in: system
        let instance = self assert: (Assert reportingTo: system output)
                            system: system.
        instance test.
        system exit: instance assert exitCode!

    method test
        [
            ByteArray,
            Dictionary,
            TestArray,
            TestClosure,
            TestRecord,
            SI_Tests
        ] do: { |each| each runTests: assert }.
        [
            File,
            TestFilePath,
            TestFileStream
        ] do: { |each| each runTests: assert in: system }.
        self testIs.
        self testFloats.
        self testIntegers.
        self testStringOutput.
        self testPrecedence.
        self testPrefix.
        self testPanic.
        self testDynamicVars!

    method testIs
        assert true: { 1 is 1 } testing: "integer 'is' integer (match)".
        assert false: { 1 is 2 } testing: "integer 'is' integet (mismatch)".
        assert true: { "foo" is "foo" } testing: "string 'is' string (match)".
        assert false: { "foo" is "bar" } testing: "string 'is' string (mismatch)".
        assert false: { "foo" is 42 } testing: "string 'is' integer (mismatch)".
        assert true: { { (panic "Oops") is 42. False } onPanic: { |_| True } }
               testing: "'is' propagates errors from left".
        assert true: { { 42 is (panic "Oops"). False } onPanic: { |_| True } }
               testing: "'is' propagates errors from right"!

    method testPanic
        assert true: { ({ panic "BOOM" } onPanic: { |p| p description })
                           == "BOOM" }
               testing: "panic with string argument"!

    method testPrefix
        assert forAll: (1 to: 10)
               that: { |n|
                       let b = Box value: n.
                       -n == -b }
               testing: "custom prefix method"!

    method testPrecedence
       assert forAll: (2 to: 10)
              that: { |n|
                      let a1 = n * n + n.
                      let a2 = (n * n) + n.
                      let b1 = (Box value: n) *** n + n.
                      let b2 = n * (n + n).
                      (a1 == a2)
                        and: (b1 == b2)
                        and: (a1 == b1) not }
              testing: "operator precedence"!

    method testFloats
       assert forAll: Floats
              that: { |x| x + x == x * 2.0 }
              testing: "float addition"!

    method auxIntegerDivZeroError: x by: y
        { x / y }
            on: Error
            do: { |error| return "oops" }!

    method testIntegers
        assert forAll: SmallIntegers
               that: { |x| x + x == x * 2 }
               testing: "integer self addition".
        assert forAll: SmallIntegers
               that: { |x| x - x == 0 }
               testing: "integer self substraction".
        assert forAll: SmallIntegers
               that: { |x| x + 1 == 1 + x }
               testing: "integer addition commutates".
        assert forAll: SmallIntegers
               that: { |x| { x / 0 }
                           onPanic: { |p| p description startsWith: "Divide by zero:"} }
               testing: "division by zero (unhandled)".
        assert forAll: SmallIntegers
               that: { |x| ({ x / 0 } on: DivideByZero do: { |ex| 42 })
                           == 42 }
               testing: "division by zero (handled)".
        assert forAll: SmallIntegers
               that: { |x|
                       { { x / 0 } on: Error do: { |ex| 42 } }
                           onPanic: { |p| p description startsWith: "UNHANDLED ERROR" } }
               testing: "division by zero (bad catch)".
        assert forAll: SmallIntegers
               that: { |x|
                       x is 0
                           ifTrue: { x = 1 }.
                       [ self auxIntegerDivZeroError: x by: x,
                         self auxIntegerDivZeroError: x by: 0 ]
                       == [1, "oops"] }
               testing: "division by zero (good catch)"!

    method testStringOutput
       assert forAll: ShortStringSeqs
              that: { |seq|
                      let out = StringOutput new.
                      let cmp = "".
                      seq do: { |s|
                                 cmp = cmp append: s.
                                 out print: s }.
                      cmp == out content }
             testing: "string output"!

    method testDynamicVars
        assert that: { [ TestVar read,
                         { let $testVar = 42. TestVar read } value,
                         TestVar read ] }
               equals: [ 123, 42, 123 ]
               testing: "dynamic binding of dynamic variable"!
end
