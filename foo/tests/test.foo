import lib.assert.Assert

class TestArrays {}
   class method do: block
      block value: [1, 2, 3, 4].
      block value: [123, 10293810293, -123, 123].
      block
end

-- Generates signed integers small enough to add without overflowing.
class SmallIntegers {}
    class method do: block
        -- First around zero
        block value: -1.
        block value: 0.
        block value: 1.
        -- Then random numbers
        let rng = Random new.
        100 times: { block value: (rng integer / 2) }
end

class ShortStringSeqs {}
   class method do: block
      -- FIXME: actual random generation, please
      block value: [].
      block value: [""].
      block value: ["", ""].
      block value: ["", "", ""].
      block value: ["123", "", ""].
      block value: ["", "123", ""].
      block value: ["", "", "123"]
end

class Floats {}
   class method do: block
      block value: -0.0.
      block value: 0.0.
      block value: 1.0.
      block value: -1.0.
      block value: 0.1.
      block value: -0.1.
      let rng = Random new.
      100 times: { block value: rng float }
end

class Box { value }
    method *** other
        self value * other
    method * other
        self value * other
    method + other
        self value + other
    method prefix-
        - (self value)
end

class Main { assert system }
    class method run: cmd in: system
        let instance = self assert: (Assert reportingTo: system output)
                            system: system.
        instance test.
        system exit: instance assert exitCode

    method test
        self testIs.
        self testByteArrays.
        self testFloats.
        self testIntegers.
        self testStringOutput.
        self testPrecedence.
        self testPrefix.
        self testRecord.
        self testDictionary.
        self testRaise.
        self testFilePath

    method testIs
        assert true: { 1 is 1 } testing: "integer 'is' integer (match)".
        assert false: { 1 is 2 } testing: "integer 'is' integet (mismatch)".
        assert true: { "foo" is "foo" } testing: "string 'is' string (match)".
        assert false: { "foo" is "bar" } testing: "string 'is' string (mismatch)".
        assert false: { "foo" is 42 } testing: "string 'is' integer (mismatch)".
        assert true: { { (raise "Oops") is 42. False } onError: { |e c| True } }
               testing: "'is' propagates errors from left".
        assert true: { { 42 is (raise "Oops"). False } onError: { |e c| True } }
               testing: "'is' propagates errors from right"

    method testFilePath
        let dir = system currentDirectory.
        assert true: { dir exists }
               testing: "currentDirectory exists".
        assert true: { dir isDirectory }
               testing: "currentDirectory is directory".
        assert false: { dir isFile }
               testing: "currentDirectory is not a file".
        let none = dir path: "does-not-exists".
        assert false: { none exists }
               testing: "nonexistent file does not exist".
        assert false: { none isDirectory }
               testing: "nonexistent file is not a directory".
        assert false: { none isFile }
               testing: "nonexistent file is not a file".
        let readme = dir path: "README.md".
        assert true: { readme exists }
               testing: "readme exists".
        assert true: { readme isFile }
               testing: "readme is a file".
        assert false: { readme isDirectory }
               testing: "readme is not a directory"

    method testRaise
        assert true: { ({ raise "BOOM" } onError: { |e c| e })
                           == "BOOM" }
               testing: "raise with string argument"

    method testDictionary
        assert true: { let d = { 1 + 1 + 40 -> "the" append: "Answer" }.
                       (d at: 42) == "theAnswer" }
               testing: "dictionary syntax and accessor".
        assert true: { let d = Dictionary new.
                       d put: "foo" at: "bar".
                       (d at: "bar") == "foo" }
               testing: "dictionary new and put:at:"

    method testRecord
        assert true: { let r = {x: -10, y: 52}.
                       r x + r y == 42 }
               testing: "record creation and accessors".

    method testPrefix
        assert forAll: (1 to: 10)
               that: { |n|
                       let b = Box value: n.
                       -n == -b }
               testing: "custom prefix method"

    method testPrecedence
       assert forAll: (2 to: 10)
              that: { |n|
                      let a1 = n * n + n.
                      let a2 = (n * n) + n.
                      let b1 = (Box value: n) *** n + n.
                      let b2 = n * (n + n).
                      (a1 == a2)
                        and: (b1 == b2)
                        and: (a1 == b1) not }
              testing: "operator precedence"

    method testByteArrays
       assert forAll: (1 to: 10)
              that: { |n|
                      let bytes = ByteArray new: n.
                      let p = n / 2 + 1.
                      let old = bytes at: p.
                      bytes put: n at: p.
                      let new = bytes at: p.
                      (bytes size == n)
                         and: (old == 0)
                         and: (new == n)
                         and: (n > 0) }
              testing: "ByteArray creation and access"

    method testFloats
       assert forAll: Floats
              that: { |x| x + x == x * 2.0 }
              testing: "float addition"

    method testIntegers
       assert forAll: SmallIntegers
              that: { |x| x + x == x * 2 }
              testing: "integer self addition".
       assert forAll: SmallIntegers
              that: { |x| x - x == 0 }
              testing: "integer self substraction".
       assert forAll: SmallIntegers
              that: { |x| x + 1 == 1 + x }
              testing: "integer addition commutates"

    method testStringOutput
       assert forAll: ShortStringSeqs
              that: { |seq|
                      let out = StringOutput new.
                      let cmp = "".
                      seq do: { |s|
                                 cmp = cmp append: s.
                                 out print: s }.
                      cmp == out content }
             testing: "string output"

end
