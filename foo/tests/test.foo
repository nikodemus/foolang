import lib.assert.Assert
import lib.si.SI_Tests

-- Generates signed integers small enough to add without overflowing.
class SmallIntegers {}
    class method do: block
        -- First around zero
        block value: -1.
        block value: 0.
        block value: 1.
        -- Then random numbers
        let rng = Random new.
        100 times: { block value: (rng integer / 2) }
end

class ShortStringSeqs {}
   class method do: block
      -- FIXME: actual random generation, please
      block value: [].
      block value: [""].
      block value: ["", ""].
      block value: ["", "", ""].
      block value: ["123", "", ""].
      block value: ["", "123", ""].
      block value: ["", "", "123"]
end

class Floats {}
   class method do: block
      block value: -0.0.
      block value: 0.0.
      block value: 1.0.
      block value: -1.0.
      block value: 0.1.
      block value: -0.1.
      let rng = Random new.
      100 times: { block value: rng float }
end

class Box { value }
    method *** other
        self value * other
    method * other
        self value * other
    method + other
        self value + other
    method prefix-
        - (self value)
end

class Main { assert system }
    class method run: cmd in: system
        let instance = self assert: (Assert reportingTo: system output)
                            system: system.
        instance test.
        system exit: instance assert exitCode

    method test
        [
            ByteArray,
            Closure,
            Dictionary,
            TestArray,
            TestRecord,
            SI_Tests
        ] do: { |each| each runTests: assert }.
        [
            File,
            TestFilePath,
            TestFileStream
        ] do: { |each| each runTests: assert in: system }.
        self testIs.
        self testFloats.
        self testIntegers.
        self testStringOutput.
        self testPrecedence.
        self testPrefix.
        self testRaise

    method testIs
        assert true: { 1 is 1 } testing: "integer 'is' integer (match)".
        assert false: { 1 is 2 } testing: "integer 'is' integet (mismatch)".
        assert true: { "foo" is "foo" } testing: "string 'is' string (match)".
        assert false: { "foo" is "bar" } testing: "string 'is' string (mismatch)".
        assert false: { "foo" is 42 } testing: "string 'is' integer (mismatch)".
        assert true: { { (raise "Oops") is 42. False } onError: { |e c| True } }
               testing: "'is' propagates errors from left".
        assert true: { { 42 is (raise "Oops"). False } onError: { |e c| True } }
               testing: "'is' propagates errors from right"

    method testRaise
        assert true: { ({ raise "BOOM" } onError: { |e c| e })
                           == "BOOM" }
               testing: "raise with string argument"

    method testPrefix
        assert forAll: (1 to: 10)
               that: { |n|
                       let b = Box value: n.
                       -n == -b }
               testing: "custom prefix method"

    method testPrecedence
       assert forAll: (2 to: 10)
              that: { |n|
                      let a1 = n * n + n.
                      let a2 = (n * n) + n.
                      let b1 = (Box value: n) *** n + n.
                      let b2 = n * (n + n).
                      (a1 == a2)
                        and: (b1 == b2)
                        and: (a1 == b1) not }
              testing: "operator precedence"

    method testFloats
       assert forAll: Floats
              that: { |x| x + x == x * 2.0 }
              testing: "float addition"

    method testIntegers
       assert forAll: SmallIntegers
              that: { |x| x + x == x * 2 }
              testing: "integer self addition".
       assert forAll: SmallIntegers
              that: { |x| x - x == 0 }
              testing: "integer self substraction".
       assert forAll: SmallIntegers
              that: { |x| x + 1 == 1 + x }
              testing: "integer addition commutates"

    method testStringOutput
       assert forAll: ShortStringSeqs
              that: { |seq|
                      let out = StringOutput new.
                      let cmp = "".
                      seq do: { |s|
                                 cmp = cmp append: s.
                                 out print: s }.
                      cmp == out content }
             testing: "string output"

end
