import .array.Array
import .array.Specialized
import .collection.Collection
import .ordered.Ordered

class List { size data }
    is Ordered
    is Collection

    method asArray
        Array from: self!

    method popFirst
        let first = self first.
        1 to: self size - 1
          do: { |index|
                self data put: (self data at: index + 1) at: index }.
        size = size - 1.
        first!

    method printOn: stream
        "[" printOn: stream.
        self do: { |each| each printOn: stream }
             interleaving: { ", " printOn: stream }.
        "] asList" printOn: stream!

    method displayOn: stream
        "[" printOn: stream.
        self do: { |each| each displayOn: stream }
             interleaving: { ", " printOn: stream }.
        "] asList" printOn: stream.
        self elementType is Any
            ifFalse: { "Of: {self elementType}" printOn: stream }!

    method toString
        StringOutput with: { |out| self printOn: out }!

    method displayString
        StringOutput with: { |out| self displayOn: out }!

    direct method from: collection
        let new = self withCapacity: collection size.
        collection do: { |elt| new add: elt }.
        new!

    direct method new: size value: init
        let new = self withCapacity: size.
        1 to: size do: { |_| new push: init }.
        new!

    direct method with: element
        let new = self new.
        new add: element.
        new!

    direct method of: type withCapacity: capacity
        self size: 0 data: (Array of: type new: capacity)!

    direct method of: type
        Specialized class: List of: type!

    method elementType
        data elementType!

    method add: element
        self atCapacity
            ifTrue: { let newdata = Array new: (size + 1) * 2.
                      1 to: size
                        do: { |i|
                              newdata put: (data at: i) at: i }.
                      data = newdata }.
        data put: element at: size + 1.
        size = size + 1.
        self!

    method from: first to: last
        let list = List withCapacity: (last - first + 1).
        first to: last
              do: { |index| list add: (self at: index) }.
        list!

    method pop
        size > 0
            ifTrue: { let elt = data at: size.
                      size = size - 1.
                      elt }
            ifFalse: { Error raise: "Cannot pop from empty " }!

    method push: element
        self add: element!

    method put: element at: index
        self checkIndex: index.
        data put: element at: index!

    method at: index
        self checkIndex: index.
        data at: index!

    method checkIndex: index
        index > size
            ifTrue: { Error raise: "List index out of bounds: {index}" }!

    method capacity
        data size!

    method atCapacity
        size == self capacity!

    method clear
        size = 0.
        self!

    method concat: other
        let new = List withCapacity: self size + other size.
        self do: { |elt| new push: elt }.
        other do: { |elt| new push: elt }.
        new!

    method collect: block
        let size = self size.
        let result = List withCapacity: size.
        1 to: size
          do: { |i|
                result push: (block value: (self at: i)) }.
        result!

    method copy
        let copy = List withCapacity: self size.
        self do: { |elt| copy push: elt }.
        copy!

    method count: block
        let n = 0.
        1 to: size
          do: { |i|
                (block value: (self at: i))
                    ifTrue: { n = n + 1 } }.
        n!

    method with: list collect: block
        let size = (size min: list size).
        let result = List withCapacity: size.
        1 to: size
          do: { |i|
                result push: (block value: (self at: i)  value: (list at: i)) }.
        result!

    method with: list default: default collect: block
        let size1 = self size.
        let size2 = list size.
        let size = size1 max: size2.
        let result = List withCapacity: size.
        let common = size1 min: size2.
        1 to: common
          do: { |i| result push: (block value: (self at: i) value: (list at: i)) }.
        common == size
            ifTrue: { return result }.
        let tailHandler = size1 < size2
                              ifTrue: { { |i|
                                          block value: default value: (list at: i) } }
                              ifFalse: { { |i|
                                           block value: (self at: i) value: default } }.
        common + 1 to: size
                   do: { |i| result push: (tailHandler value: i) }.
        result!

    method select: block
        let selection = List withCapacity: 4.
        self do: { |elt|
                   (block value: elt) is True
                       ifTrue: { selection push: elt } }.
        selection!

    method reject: block
        let selection = List withCapacity: 4.
        self do: { |elt|
                   (block value: elt) is True
                       ifFalse: { selection push: elt } }.
        selection!

    method + x
        x broadcast: {|a b| a + b} to: self!
    method - x
        x broadcast: {|a b| a - b} to: self!
    method * x
        x broadcast: {|a b| a * b} to: self!
    method / x
        x broadcast: {|a b| a / b} to: self!

    method broadcast: block to: collection
        collection with: self collect: block!

    method dot: other
        self with: other sum: { |a b| a * b }!

    method norm
       (self inject: 0.0 into: { |abs elt| abs + (elt * elt) }) sqrt!

    method normalized
       let reciprocal = 1.0 / (self norm).
       self * reciprocal!

    method scalarProjectionOn: other
        (self dot: other) / other norm!

    method vectorProjectionOn: other
        ((self dot: other) / (other dot: other)) * other!

    method addNumber: left
       self collect: { |elt| left + elt }!
    method subNumber: left
       self collect: { |elt| left - elt }!
    method divNumber: left
       self collect: { |elt| left / elt }!
    method mulNumber: left
       self collect: { |elt| left * elt }!
end
