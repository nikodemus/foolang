import .any.Any
import .iterable.Iterator
import .iterable.Iterable
import .ordered.Ordered
import .stringOutput.StringOutput

class Specialized { containerClass elementType }
    direct method class: containerClass of: elementType
        self containerClass: containerClass elementType: elementType!
    method new
        containerClass of: elementType new: 0!
    method new: size
        containerClass of: elementType new: size!
    method new: size value: value
        containerClass of: elementType new: size value: value!
    method includes: thing
        (containerClass includes: thing)
            ifTrue: { thing elementType is elementType }!
    method typecheck: thing
        (self includes: thing)
             ifFalse: { panic "TYPE OOPSIE: {thing} is not {self}!"
                        -- TypeError raise: thing expected: self
                        }.
        thing!
    method displayOn: stream
        stream print: "{containerClass} of: {elementType}"!
end

extend Array
    is Ordered

    direct method from: ordered
        (Array includes: ordered)
            ifTrue: { return ordered }.
        let new = self new: ordered size.
        1 to: new size
          do: { |i| new put: (ordered at: i) at: i }.
        new!

    direct method new: size
        self of: Any new: size value: False!

    direct method new: size value: value
        self of: Any new: size value: value!

    direct method of: type
        Specialized class: Array of: type!

    direct method of: type new: size
        self of: type new: size value: type default!

    method from: first to: last
        let offset = first - 1.
        let new = Array of: self arrayElementType new: last - offset.
        1 to: new size
          do: { |i| new put: (self at: i + offset) at: i }.
        new!

    method append: other
        let n = self size + other size.
        let a = Array of: (self elementType) new: n.
        a replaceFrom: 1 to: self size with: self startingAt: 1.
        a replaceFrom: self size + 1 to: n with: other startingAt: 1.
        a!

    method + x
        x broadcast: {|a b| a + b} to: self!
    method - x
        x broadcast: {|a b| a - b} to: self!
    method * x
        x broadcast: {|a b| a * b} to: self!
    method / x
        x broadcast: {|a b| a / b} to: self!

    method broadcast: block to: collection
        collection with: self collect: block!

    method elementType
        -- KLUDGE: otherwise Iterator#elementType:
        -- need something like
        --  is Iterable except: [#elementType]
        self arrayElementType!

    method _emitOn: stream using: block
        stream print: "[".
        self do: { |x| block value: x }
             interleaving: { stream print: ", " }.
        stream print: "]"!

    method displayOn: stream
        self _emitOn: stream using: { |x| x displayOn: stream }!

    method printOn: stream
        self _emitOn: stream using: { |x| x printOn: stream }!

    method displayString
        StringOutput with: { |out| self displayOn: out }!

    method toString
        StringOutput with: { |out| self printOn: out }!

    method dot: other
        self with: other sum: { |a b| a * b }!

    method norm
       (self inject: 0.0 into: { |abs elt| abs + (elt * elt) }) sqrt!

    method normalized
        let reciprocal = 1.0 / (self norm).
        self * reciprocal!

    method scalarProjectionOn: other
        (self dot: other) / other norm!

    method vectorProjectionOn: other
        ((self dot: other) / (other dot: other)) * other!

    method addNumber: left
       self collect: { |elt| left + elt }!
    method subNumber: left
       self collect: { |elt| left - elt }!
    method divNumber: left
       self collect: { |elt| left / elt }!
    method mulNumber: left
       self collect: { |elt| left * elt }!
end
