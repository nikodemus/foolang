import .collection.Collection

extend Array
    is Collection

    method _emitOn: stream using: block
        stream print: "[".
        let first = True.
        self do: { |x|
                   first
                     ifTrue: { first = False }
                     ifFalse: { stream print: ", " }.
                   block value: x }.
        stream print: "]"

    method displayOn: stream
        self _emitOn: stream using: { |x| x displayOn: stream }

    method printOn: stream
        self _emitOn: stream using: { |x| x printOn: stream }

    method concat: other
        let new = Array withCapacity: self size + other size.
        self do: { |elt| new push: elt }.
        other do: { |elt| new push: elt }.
        new

    method collect: block
        let size = self size.
        let result = Array withCapacity: size.
        1 to: size
          do: { |i|
                result push: (block value: (self at: i)) }.
        result

    method with: array collect: block
        let size = self checkSize: array.
        let result = Array withCapacity: size.
        1 to: size
          do: { |i|
                result push: (block value: (self at: i)  value: (array at: i)) }.
        result

    method select: block
        let selection = Array withCapacity: 4.
        self do: { |elt|
                   (block value: elt) is True
                       ifTrue: { selection push: elt } }.
        selection

    method + x
        x broadcast: {|a b| a + b} to: self
    method - x
        x broadcast: {|a b| a - b} to: self
    method * x
        x broadcast: {|a b| a * b} to: self
    method / x
        x broadcast: {|a b| a / b} to: self

    method broadcast: block to: collection
        collection with: self collect: block

    method dot: other
        self with: other sum: { |a b| a * b }

    method norm
       (self inject: 0.0 into: { |abs elt| abs + (elt * elt) }) sqrt

    method normalized
       let reciprocal = 1.0 / (self norm).
       self * reciprocal

    method scalarProjectionOn: other
        (self dot: other) / other norm

    method vectorProjectionOn: other
        ((self dot: other) / (other dot: other)) * other

    method addInteger: x
       self collect: { |elt| elt addInteger: x }
    method addFloat: x
       self collect: { |elt| elt addFloat: x }

    method divFloat: x
       self collect: { |elt| elt divFloat: x }
    method divInteger: x
       self collect: { |elt| elt divInteger: x }

    method mulInteger: x
       self collect: { |elt| elt mulInteger: x }
    method mulFloat: x
       self collect: { |elt| elt mulFloat: x }

    method subInteger: x
       self collect: { |elt| elt subInteger: x }
    method subFloat: x
       self collect: { |elt| elt subFloat: x }
end

class TestArray {}
    class method testEquality: assert
        assert true: { [1, 2, 3] == [1, 2, 3] }
               testing: "Array#== (true 1)".
        assert true: { [1, 2, [3, 4]] == [1, 2, [3, 4]] }
               testing: "Array#== (true 2)".
        assert false: { [1, 2, 4] == [1, 2, 3] }
               testing: "Array#== (false 1)".
        assert false: { [1, 2, 3, 4] == [1, 2, 3] }
               testing: "Array#== (false 2)"
    class method runTests: assert
        self testEquality: assert
end
