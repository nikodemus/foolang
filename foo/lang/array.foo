import .collection.Collection

extend Array
    is Collection

    method _emitOn: stream using: block
        stream print: "[".
        self do: { |x| block value: x }
             interleaving: { stream print: ", " }.
        stream print: "]".

    method displayOn: stream
        self _emitOn: stream using: { |x| x displayOn: stream }.

    method printOn: stream
        self _emitOn: stream using: { |x| x printOn: stream }.

    method concat: other
        let new = Array withCapacity: self size + other size.
        self do: { |elt| new push: elt }.
        other do: { |elt| new push: elt }.
        new.

    method collect: block
        let size = self size.
        let result = Array withCapacity: size.
        1 to: size
          do: { |i|
                result push: (block value: (self at: i)) }.
        result.

    method copy
        let copy = Array withCapacity: self size.
        self do: { |elt| copy push: elt }.
        copy.

    method count: block
        let n = 0.
        1 to: size
          do: { |i|
                (block value: (self at: i))
                    ifTrue: { n = n + 1 } }.
        n.

    method with: array collect: block
        let size = self checkSize: array.
        let result = Array withCapacity: size.
        1 to: size
          do: { |i|
                result push: (block value: (self at: i)  value: (array at: i)) }.
        result.

    method select: block
        let selection = Array withCapacity: 4.
        self do: { |elt|
                   (block value: elt) is True
                       ifTrue: { selection push: elt } }.
        selection.

    method reject: block
        let selection = Array withCapacity: 4.
        self do: { |elt|
                   (block value: elt) is True
                       ifFalse: { selection push: elt } }.
        selection.

    method sorted
        self copy sort.

    method sorted: block
        self copy sort: block.

    method sort
        self sort: { |a b| a < b }.

    method sort: block
        -- Unfortunate a straigthforward rust-side wrapper for Vec::sort_by()
        -- cannot propagate errors from the comparison function, so instead
        -- here's a quick and dirty quicksort. O(N^2) worst case, since I
        -- was too lazy to do the center pivot.
        self _quicksort: 1 to: self size by: block.

    method _quicksort: left to: right by: block
        left < right
            ifTrue: { let p = self _partition: left to: right by: block.
                      self _quicksort: left to: p - 1 by: block.
                      self _quicksort: p + 1 to: right by: block }.
        self.

    method _partition: left to: right by: block
        let pivot = self at: right.
        let i = left.
        left to: right
                 do: { |j|
                       let x = self at: j.
                       (block value: x value: pivot)
                           ifTrue: { self swap: i with: j.
                                     i = i + 1 } }.
        self swap: i with: right.
        i.

    method swap: i with: j
        let tmp = self at: i.
        self put: (self at: j) at: i.
        self put: tmp at: j.
        self.

    method + x
        x broadcast: {|a b| a + b} to: self.
    method - x
        x broadcast: {|a b| a - b} to: self.
    method * x
        x broadcast: {|a b| a * b} to: self.
    method / x
        x broadcast: {|a b| a / b} to: self.

    method broadcast: block to: collection
        collection with: self collect: block.

    method dot: other
        self with: other sum: { |a b| a * b }.

    method norm
       (self inject: 0.0 into: { |abs elt| abs + (elt * elt) }) sqrt.

    method normalized
       let reciprocal = 1.0 / (self norm).
       self * reciprocal.

    method scalarProjectionOn: other
        (self dot: other) / other norm.

    method vectorProjectionOn: other
        ((self dot: other) / (other dot: other)) * other.

    method addInteger: x
       self collect: { |elt| elt addInteger: x }.
    method addFloat: x
       self collect: { |elt| elt addFloat: x }.

    method divFloat: x
       self collect: { |elt| elt divFloat: x }.
    method divInteger: x
       self collect: { |elt| elt divInteger: x }.

    method mulInteger: x
       self collect: { |elt| elt mulInteger: x }.
    method mulFloat: x
       self collect: { |elt| elt mulFloat: x }.

    method subInteger: x
       self collect: { |elt| elt subInteger: x }.
    method subFloat: x
       self collect: { |elt| elt subFloat: x }.
end

class TestArray {}
    class method testEquality: assert
        assert true: { [1, 2, 3] == [1, 2, 3] }
               testing: "Array#== (true 1)".
        assert true: { [1, 2, [3, 4]] == [1, 2, [3, 4]] }
               testing: "Array#== (true 2)".
        assert false: { [1, 2, 4] == [1, 2, 3] }
               testing: "Array#== (false 1)".
        assert false: { [1, 2, 3, 4] == [1, 2, 3] }
               testing: "Array#== (false 2)".

    class method testSort: assert
        assert that: { [] sort }
               equals: []
               testing: "sort, empty".
        assert that: { [1] sort }
               equals: [1]
               testing: "sort, singular".
        assert that: { [1, 1] sort }
               equals: [1, 1]
               testing: "sort, two identical".
        assert that: { [1, 2] sort }
               equals: [1, 2]
               testing: "sort, two in order".
        assert that: { [2, 1] sort }
               equals: [1, 2]
               testing: "sort, two in reverse order".
        assert that: { [1, 2, 3] sort }
               equals: [1, 2, 3]
               testing: "sort, three in order".
        assert that: { [3, 2, 1] sort }
               equals: [1, 2, 3]
               testing: "sort, three in reverse order".
        assert that: { [9, 2, 1, 8, 7, 3, 5, 4, 6, 0] sort }
               equals: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
               testing: "sort, ten".
    class method runTests: assert
        self testEquality: assert.
        self testSort: assert.
end
