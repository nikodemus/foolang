import .iterable.Iterator
import .iterable.Iterable
import .ordered.Ordered

class ArrayIterator { array index }
    is Iterator

    direct method new: array
        self array: array index: 1!

    method nextIfNone: block
        let next = index > array size
            ifTrue: { return block value }
            ifFalse: { array at: index }.
        index = index + 1.
        next!

    method hasNext
        index <= array size!
end

class Specialized { containerClass elementType }
    direct method class: containerClass of: elementType
        self containerClass: containerClass elementType: elementType!
    method new
        containerClass of: elementType new: 0!
    method new: size
        containerClass of: elementType new: size!
    method new: size value: value
        containerClass of: elementType new: size value: value!
    method includes: thing
        (containerClass includes: thing)
            ifTrue: { thing elementType is elementType }!
    method typecheck: thing
        self includes: thing
             ifFalse: { TypeError raise: thing expected: self }
        thing!
    method displayOn: stream
        stream print: "{containerClass} of: {elementType}"!
end

extend Array
    is Ordered

    direct method from: ordered
        (Array includes: ordered)
            ifTrue: { return ordered }.
        let new = self new: ordered size.
        1 to: new size
          do: { |i| new put: (ordered at: i) at: i }.
        new!

    direct method new: size
        self of: Any new: size value: False!

    direct method new: size value: value
        self of: Any new: size value: value!

    direct method of: type
        Specialized class: Array of: type!

    direct method of: type new: size
        self of: type new: size value: type default!

    method from: first to: last
        let offset = first - 1.
        let new = Array of: self arrayElementType new: last - offset.
        1 to: new size
          do: { |i| new put: (self at: i + offset) at: i }.
        new!

    method asList
        List from: self!

    method + x
        x broadcast: {|a b| a + b} to: self!
    method - x
        x broadcast: {|a b| a - b} to: self!
    method * x
        x broadcast: {|a b| a * b} to: self!
    method / x
        x broadcast: {|a b| a / b} to: self!

    method broadcast: block to: collection
        collection with: self collect: block!

    method iterator
        ArrayIterator new: self!

    method elementType
        -- KLUDGE: otherwise Iterator#elementType:
        -- need something like
        --  is Iterable except: [#elementType]
        self arrayElementType!

    method _emitOn: stream using: block
        stream print: "[".
        self do: { |x| block value: x }
             interleaving: { stream print: ", " }.
        stream print: "]"!

    method displayOn: stream
        self _emitOn: stream using: { |x| x displayOn: stream }!

    method printOn: stream
        self _emitOn: stream using: { |x| x printOn: stream }!

    method dot: other
        self with: other sum: { |a b| a * b }!

    method norm
       (self inject: 0.0 into: { |abs elt| abs + (elt * elt) }) sqrt!

    method normalized
        let reciprocal = 1.0 / (self norm).
        self * reciprocal!

    method scalarProjectionOn: other
        (self dot: other) / other norm!

    method vectorProjectionOn: other
        ((self dot: other) / (other dot: other)) * other!

    method addNumber: left
       self collect: { |elt| left + elt }!
    method subNumber: left
       self collect: { |elt| left - elt }!
    method divNumber: left
       self collect: { |elt| left / elt }!
    method mulNumber: left
       self collect: { |elt| left * elt }!
end

class TestArray { assert }

    method equalityCases
        [[ [1,2,3], [1,2,3], True ],
         [ [1, 2, [3, 4]], [1, 2, [3, 4]], True ],
         [ [1, 2, 4], [1, 2, 3], False ],
         [ [1, 2, 3, 4], [1, 2, 3], False ],
         [ ["one", 2, 3], [1, "two", 3], False ]]!

    method testEquality
        assert forAll: self equalityCases
               that: { |case|
                       (case first == case second) is case third }
               testing: "Array#=="!

    method sortingCases
        [[ [], [] ],
         [ [1], [1] ],
         [ [1, 1], [1, 1] ],
         [ [1, 2], [1, 2] ],
         [ [2, 1], [1, 2] ],
         [ [1, 2, 3], [1, 2, 3] ],
         [ [3, 2, 1], [1, 2, 3] ],
         [ [2, 1, 3], [1, 2, 3] ],
         [ [1, 3, 2], [1, 2, 3] ],
         [ [9, 2, 1, 8, 7, 3, 5, 4, 6, 0],
           [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ]]!

    method testSort
        assert forAll: self sortingCases
               that: { |case|
                       case first sort == case second }
               testing: "Array#sort return value".
        assert forAll: self sortingCases
               that: { |case|
                       case first sort.
                       case first == case second }
               testing: "Array#sort side effect"!

    method reverseCases
        [[ [], [] ],
         [ [1], [1] ],
         [ [1, 2], [2, 1] ],
         [ [1, 2, 3], [3, 2, 1] ]]!

    method testReverse
        assert forAll: self reverseCases
               that: { |case|
                       case first reverse == case second }
               testing: "Array#reverse return value".
        assert forAll: self reverseCases
               that: { |case|
                       case first reverse.
                       case first == case second }
               testing: "Array#reverse side effect"!

    method testReversed
        assert forAll: self reverseCases
               that: { |case|
                       case first reversed == case second }
               testing: "Array#reversed return value".
        assert forAll: self reverseCases
               that: { |case|
                       let orig = case first copy.
                       case first reversed.
                       case first == orig }
               testing: "Array#reversed no side effect"!

    direct method runTests: assert
        assert runAllTests: (self assert: assert)!

end
