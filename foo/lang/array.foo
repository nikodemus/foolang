import .collection.Collection

extend Array
    is Collection

    class method new: size value: init
        let new = Self withCapacity: size.
        1 to: size do: { |_| new push: init }.
        new

    method bytes
        let bytes = ByteArray new: self size.
        1 to: self size do: { |i| bytes put: (self at: i) at: i }.
        bytes

    method _emitOn: stream using: block
        stream print: "[".
        self do: { |x| block value: x }
             interleaving: { stream print: ", " }.
        stream print: "]".

    method displayOn: stream
        self _emitOn: stream using: { |x| x displayOn: stream }.

    method printOn: stream
        self _emitOn: stream using: { |x| x printOn: stream }.

    method concat: other
        let new = Array withCapacity: self size + other size.
        self do: { |elt| new push: elt }.
        other do: { |elt| new push: elt }.
        new.

    method collect: block
        let size = self size.
        let result = Array withCapacity: size.
        1 to: size
          do: { |i|
                result push: (block value: (self at: i)) }.
        result.

    method copy
        let copy = Array withCapacity: self size.
        self do: { |elt| copy push: elt }.
        copy.

    method count: block
        let n = 0.
        1 to: size
          do: { |i|
                (block value: (self at: i))
                    ifTrue: { n = n + 1 } }.
        n.

    method with: array collect: block
        let size = self checkSize: array.
        let result = Array withCapacity: size.
        1 to: size
          do: { |i|
                result push: (block value: (self at: i)  value: (array at: i)) }.
        result.

    method with: array default: default collect: block
        let size1 = self size.
        let size2 = array size.
        let size = size1 max: size2.
        let result = Array withCapacity: size.
        let common = size1 min: size2.
        1 to: common
          do: { |i| result push: (block value: (self at: i) value: (array at: i)) }.
        common == size
            ifTrue: { return result }.
        let tailHandler = size1 < size2
                              ifTrue: { { |i|
                                          block value: default value: (array at: i) } }
                              ifFalse: { { |i|
                                           block value: (self at: i) value: default } }.
        common + 1 to: size
                   do: { |i| result push: (tailHandler value: i) }.
        result

    method select: block
        let selection = Array withCapacity: 4.
        self do: { |elt|
                   (block value: elt) is True
                       ifTrue: { selection push: elt } }.
        selection.

    method reject: block
        let selection = Array withCapacity: 4.
        self do: { |elt|
                   (block value: elt) is True
                       ifFalse: { selection push: elt } }.
        selection.

    method reverse
        let n = self size + 1. -- 1 based indexing isn't all sunshine!
        1 to: n
          do: { |i|
                let j = n - i.
                j <= i
                    ifTrue: { return self }.
                let tmp = self at: i.
                self put: (self at: j) at: i.
                self put: tmp at: j }.
          panic "BUG: this should never happen."

    method reversed
        self copy reverse

    method sort
        self sort: { |a b| a < b }.

    method sort: block
        -- Unfortunate a straigthforward rust-side wrapper for Vec::sort_by()
        -- cannot propagate errors from the comparison function, so instead
        -- here's a quick and dirty quicksort. O(N^2) worst case, since I
        -- was too lazy to do the center pivot.
        self _quicksort: 1 to: self size by: block.

    method sorted
        self copy sort.

    method sorted: block
        self copy sort: block.

    method _quicksort: left to: right by: block
        left < right
            ifTrue: { let p = self _partition: left to: right by: block.
                      self _quicksort: left to: p - 1 by: block.
                      self _quicksort: p + 1 to: right by: block }.
        self.

    method _partition: left to: right by: block
        let pivot = self at: right.
        let i = left.
        left to: right
                 do: { |j|
                       let x = self at: j.
                       (block value: x value: pivot)
                           ifTrue: { self swap: i with: j.
                                     i = i + 1 } }.
        self swap: i with: right.
        i.

    method swap: i with: j
        let tmp = self at: i.
        self put: (self at: j) at: i.
        self put: tmp at: j.
        self.

    method + x
        x broadcast: {|a b| a + b} to: self.
    method - x
        x broadcast: {|a b| a - b} to: self.
    method * x
        x broadcast: {|a b| a * b} to: self.
    method / x
        x broadcast: {|a b| a / b} to: self.

    method broadcast: block to: collection
        collection with: self collect: block.

    method dot: other
        self with: other sum: { |a b| a * b }.

    method norm
       (self inject: 0.0 into: { |abs elt| abs + (elt * elt) }) sqrt.

    method normalized
       let reciprocal = 1.0 / (self norm).
       self * reciprocal.

    method scalarProjectionOn: other
        (self dot: other) / other norm.

    method vectorProjectionOn: other
        ((self dot: other) / (other dot: other)) * other.

    method addNumber: left
       self collect: { |elt| left + elt }.
    method subNumber: left
       self collect: { |elt| left - elt }.
    method divNumber: left
       self collect: { |elt| left / elt }.
    method mulNumber: left
       self collect: { |elt| left * elt }.
end

class TestArray {}
    class method testEquality: assert
        assert true: { [1, 2, 3] == [1, 2, 3] }
               testing: "Array#== (true 1)".
        assert true: { [1, 2, [3, 4]] == [1, 2, [3, 4]] }
               testing: "Array#== (true 2)".
        assert false: { [1, 2, 4] == [1, 2, 3] }
               testing: "Array#== (false 1)".
        assert false: { [1, 2, 3, 4] == [1, 2, 3] }
               testing: "Array#== (false 2)".
        assert false: { ["one", 2, 3] == [1, "two", 3] }
               testing: "Array#== (false 3)".

    class method testSort: assert
        assert that: { [] sort }
               equals: []
               testing: "sort, empty".
        assert that: { [1] sort }
               equals: [1]
               testing: "sort, singular".
        assert that: { [1, 1] sort }
               equals: [1, 1]
               testing: "sort, two identical".
        assert that: { [1, 2] sort }
               equals: [1, 2]
               testing: "sort, two in order".
        assert that: { [2, 1] sort }
               equals: [1, 2]
               testing: "sort, two in reverse order".
        assert that: { [1, 2, 3] sort }
               equals: [1, 2, 3]
               testing: "sort, three in order".
        assert that: { [3, 2, 1] sort }
               equals: [1, 2, 3]
               testing: "sort, three in reverse order".
        assert that: { [9, 2, 1, 8, 7, 3, 5, 4, 6, 0] sort }
               equals: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
               testing: "sort, ten".

    class method testReverse: assert
        assert that: { let a = [].
                       a reverse.
                       a }
               equals: []
               testing: "reverse array (empty)".
        assert that: { let a = [1].
                       a reverse.
                       a }
               equals: [1]
               testing: "reverse array (1)".
        assert that: { let a = [1,2].
                       a reverse.
                       a }
               equals: [2,1]
               testing: "reverse array (2)".
        assert that: { let a = [1,2,3].
                       a reverse.
                       a }
               equals: [3,2,1]
               testing: "reverse array (3)".
        assert that: { let a = [1,2,3].
                       a reverse }
               equals: [3,2,1]
               testing: "reverse array, retval (3)".

    class method testReversed: assert
        assert that: { let a = [].
                       a reversed }
               equals: []
               testing: "reversed array (empty)".
        assert that: { let a = [1].
                       a reversed }
               equals: [1]
               testing: "reversed array (1)".
        assert that: { let a = [1,2].
                       a reversed }
               equals: [2,1]
               testing: "reversed array (2)".
        assert that: { let a = [1,2,3].
                       a reversed }
               equals: [3,2,1]
               testing: "reversed array (3)".
        assert that: { let a = [1,2,3].
                       a reversed.
                       a }
               equals: [1,2,3]
               testing: "reversed array, side-effect (3)".

    class method runTests: assert
        self testEquality: assert.
        self testSort: assert.
        self testReverse: assert.
        self testReversed: assert.
end
