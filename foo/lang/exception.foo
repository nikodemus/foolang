import .object.Object

class Panic { description context }
    is Object
    method displayOn: stream
        stream print: "PANIC: ".
        stream println: self description.
        stream println: self context!
end

class FallbackHandler {}
    is Object
    direct method raise: ex
        panic "UNHANDLED ERROR: {ex description}"!
end

define $error
    FallbackHandler!

class Handler { on block next }
    direct method on: on block: block
        self
            on: on
            block: block
            next: $error!
    method raise: ex
        (on includes: ex)
            ifTrue: { let $error = next.
                      block value: ex }.
        next raise: ex!
    method toString
        "#<Handler {on}>"!
end

interface Error
    is Object
    direct method raise: description::String
        SimpleError raise: description!
    direct method withHandler: handler do: block
        let $error = Handler on: self block: handler.
        block value!
    method raise
        $error raise: self.
        panic "$error fallthrough!"!
    method printOn: stream
        stream print: "Error: {self description}>"!
    method displayOn: stream
        stream print: "#<Error {self description}>"!
    method backtrace
        False!
    method description
        { self _description }
            on: DoesNotUnderstand
            do: { |e|
                  -- Trying to print the receiver is likely the problem, but selector
                  -- should be safe, right?
                  (Selector includes: e selector)
                      ifTrue: { return "<<{e receiver} DoesNotUnderstand {e selector} when printing Error description!>>" } }
            on: Error
            do: { |e|
                  -- Catchall
                  return "<<Error when printing {self classOf name} description!>>" }!

end

define $return
    False!

interface ValueError
    is Error
    method return: value
        $return value: value!
    method raise
        let $return = { |value| return value }.
        $error raise: self.
        panic "$error fallthrough!"!
    method _description
        "ValueError: {self value displayString}"!
end

class SimpleError { _description }
    is Error
    method _description
        _description!
    direct method raise: description
        (self _description: description) raise!
end

class RequiredMethodMissing { from selector isDirect }
    is Error
    direct method raise: selector on: instance isDirect: isDirect
        (self
             from: instance classOf
             selector: selector
             isDirect: isDirect)
        raise!
    method _description
        let maybeDirect = self isDirect
                              ifTrue: { "direct " }
                              ifFalse: { "" }.
        "Required {maybeDirect}method {selector} missing from {from}"!
end

class DoesNotUnderstand { receiver selector arguments source context }
    is Error
    direct method raise: selector with: arguments on: receiver
        (self
            raise: selector
            with: arguments
            on: receiver
            source: False
            context: False)
        raise!
    direct method raise: selector with: arguments on: receiver source: source
        (self
             receiver: receiver
             selector: selector
             arguments: arguments
             source: source
             context: False)
        raise!
    direct method raise: selector with: arguments on: receiver source: source
                  context: context
        (self
             receiver: receiver
             selector: selector
             arguments: arguments
             source: source
             context: context)
        raise!
    method backtrace
        context is False
            ifTrue: { False }
            ifFalse: { context backtrace }!
    method _description
        let classOf = receiver classOf.
        -- FIXME: Workaround for the lack of metaclasses in transpiler
        -- kludge. (someClass classOf returns someClass!)
        let className = classOf is receiver
                            ifTrue: { "{classOf name} classOf" }
                            ifFalse: { classOf name }.
        let note = "Instances of {className} do not understand: {selector}".
        source is False
            ifTrue: { note }
            ifFalse: { "{note}\n{source note: note}" }!
end

class TypeError { value expected source }
    is Error

    direct method raise: value expected: type
        self
            raise: value
            expected: type
            source: False!

    direct method raise: value expected: type source: source
        (self
             value: value
             expected: type
             source: source)
        raise!

    method _description
        "Type error: {expected name} expected, got {value classOf name}: {value displayString}"!

    method displayOn: stream
        stream print: "#<TypeError {expected}, got: {value}>"!
end

class DivideByZero { value }
    is ValueError
    direct method raise: value
        (self value: value) raise!
    method _description
        "Divide by zero: {value} cannot be divided by zero"!
    method displayOn: stream
        stream print: "#<DivideByZero {value}>"!
end

class IteratorExhausted { value }
    is Error
    direct method raise: value
        (self value: value) raise!
    method _description
        "Iterator exhausted: {value}"!
    method displayOn: stream
        stream print: "#<IteratorExhausted {value}>"!
end

extend Object
    -- FIXME: Would be infinitely preferable for the host to handle this,
    -- in order to provide the source context -- but that takes a bit of
    -- doing.

    direct method perform: selector with: arguments
        DoesNotUnderstand
            raise: selector toSelector -- KLUDGE: string on bootstrap host
            with: arguments
            on: self!

    method perform: selector with: arguments
        DoesNotUnderstand
            raise: selector toSelector
            with: arguments
            on: self!

    -- Erg. This gets us a nice error, but loses the source locations I
    -- worked to get right. BLarggkashdaskjhfklajfshd.
    direct method typecheck: value
        -- Output debug println: "{Self} typecheck: {value}".
        (Self includes: value)
            ifTrue: { value }
            ifFalse: { TypeError raise: value expected: Self }!

    method error: message
        Error raise: message!
end
