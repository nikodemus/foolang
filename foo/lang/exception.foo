import .object.Object

class Panic { description context }
    is Object
    method displayOn: stream
        stream println: "PANIC: {self description}".
        stream println: self context!
end

class FallbackHandler {}
    direct method raise: ex
        panic "UNHANDLED ERROR: {ex}"!
end

define $error
    FallbackHandler!

class Handler { on block next }
    direct method on: on block: block
        self
            on: on
            block: block
            next: $error!
    method raise: ex
        (on includes: ex)
            ifTrue: { let $error = next.
                      block value: ex }.
        next raise: ex!
    method toString
        "#<Handler {on}>"!
end

interface Error
    is Object
    direct method raise: description::String
        SimpleError raise: description!
    direct method withHandler: handler do: block
        let $error = Handler on: self block: handler.
        block value!
    method raise
        $error raise: self.
        panic "$error fallthrough!"!
    method printOn: stream
        stream print: "Error: {self description}>"!
    method displayOn: stream
        stream print: "#<Error {self description}>"!
end

define $return
    False!

interface ValueError
    is Error
    method return: value
        $return value: value!
    method raise
        let $return = { |value| return value }.
        $error raise: self.
        panic "$error fallthrough!"!
end



class SimpleError { description }
    is Error
    direct method raise: description
        (self description: description) raise!
end

class DoesNotUnderstand { receiver selector arguments source context }
    is Error
    direct method raise: selector with: arguments on: receiver
        (self
            raise: selector
            with: arguments
            on: receiver
            source: False
            context: False)
        raise!
    direct method raise: selector with: arguments on: receiver source: source
        (self
             receiver: receiver
             selector: selector
             arguments: arguments
             source: source
             context: False)
        raise!
    direct method raise: selector with: arguments on: receiver source: source
                  context: context
        (self
             receiver: receiver
             selector: selector
             arguments: arguments
             source: source
             context: context)
        raise!
    method toString
        Output debug print: "\nDNU ".
        Output debug print: selector.
        Output debug print: " to ".
        Output debug println: receiver.
        "DNU {selector}"!
    method description
        let note = "{receiver} does not understand: {selector}".
        source is False
            ifTrue: { note }
            ifFalse: { "{note}\n{source note: note}" }!
end

class TypeError { value expected }
    is Error
    direct method raise: value expected: type
        (self value: value expected: type) raise!
    method description
        "Type error: {expected} expected, got: {value}"!
    method displayOn: stream
        stream print: "#<TypeError {expected}, got: {value}>"!
end

class DivideByZero { value }
    is ValueError
    direct method raise: value
        (self value: value) raise!
    method description
        "Divide by zero: {value} cannot be divided by zero"!
    method displayOn: stream
        stream print: "#<DivideByZero {value}>"!
end

class IteratorExhausted { value }
    is Error
    direct method raise: value
        (self value: value) raise!
    method description
        "Iterator exhausted: {value}"!
    method displayOn: stream
        stream print: "#<IteratorExhausted {value}>"!
end
