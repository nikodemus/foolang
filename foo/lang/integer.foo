import .number.Number

define $IntegerPrintBase 10!

extend Integer
    is Number

    direct method default
        0!

    direct method printBase: base do: block
        let $IntegerPrintBase = base.
        block value!

    method truncate
        self!

    method printOn: stream in: base radix: printRadix
        self < 0
            ifTrue: { stream print: "-".
                      return -self printOn: stream in: base radix: printRadix }.
        printRadix
            ifTrue: { stream print: base radixString }.
        self < base
            ifTrue: { let index = self + 1.
                      stream
                          print: ("0123456789ABCDEF" from: index to: index) }
            ifFalse: { let q = self / base.
                       q printOn: stream in: base radix: False.
                       let r = self - (q * base).
                       r printOn: stream in: base radix: False }!

    method printOn: stream in: base
        self printOn: stream in: base radix: True!

    method printOn: stream
        self printOn: stream in: $IntegerPrintBase!

    method radixString
        self is 2 ifTrue: { return "0b" }.
        self is 10 ifTrue: { return "" }.
        self is 16 ifTrue: { return "0x" }.
        Error raise: "No radixString for {self}"!

    method toString
        StringOutput with: { |s| self printOn: s }!

    method to: other
        self to: other by: 1!

    method downTo: other
        self to: other by: -1!

    method to: other do: block
        let i = self.
        { i <= other }
            whileTrue: { block value: i. i = i + 1 }.
        self!

    method downTo: other do: block
        let i = self.
        { i >= other }
            whileTrue: { block value: i. i = i - 1 }.
        self!

    method times: block
        let i = 0.
        { i < self }
           whileTrue: { block value. i = i + 1 }.
        self!

    method addNumber: left
        left integerAdd: self!
    method subNumber: left
        left integerSub: self!
    method mulNumber: left
        left integerMul: self!
    method divNumber: left
        left integerDiv: self!

    method eqNumber: left
        left integerEq: self!
    method ltNumber: left
        left integerLt: self!
    method gtNumber: left
        left integerGt: self!
    method lteNumber: left
        left integerLte: self!
    method gteNumber: left
        left integerGte: self!

    method floatAdd: right
        self asFloat floatAdd: right!
    method floatSub: right
        self asFloat floatSub: right!
    method floatMul: right
        self asFloat floatMul: right!
    method floatDiv: right
        self asFloat floatDiv: right!

    method floatEq: right
        self asFloat floatEq: right!
    method floatGt: right
        self asFloat floatGt: right!
    method floatLt: right
        self asFloat floatLt: right!
    method floatGte: right
        self asFloat floatGte: right!
    method floatLte: right
        self asFloat floatLte: right!
end

class TestInteger { assert }
    direct method runTests: assert
        (self assert: assert)
            ; testAdd
            ; testAdditionCommutative
            ; testSub
            ; testPrintBase
                !

    method testAdd
        assert forAll: SmallIntegers
               that: { |x| x + x == x * 2 }
               testing: "integer self addition"!

    method testSub
        assert forAll: SmallIntegers
               that: { |x| x - x == 0 }
               testing: "integer self substraction"!

    method testAdditionCommutative
        assert forAll: SmallIntegers
               that: { |x| x + 1 == 1 + x }
               testing: "integer addition commutates"!

    method auxIntegerDivZeroError: x by: y
        { x / y }
            on: Error
            do: { |error| return "oops" }!

    method testDivByZero
        assert forAll: SmallIntegers
               that: { |x| { x / 0 }
                           onPanic: { |p|
                                      p description startsWith: "UNHANDLED ERROR: Divide by zero:" } }
               testing: "division by zero (unhandled)".

        assert forAll: SmallIntegers
               that: { |x| ({ x / 0 } on: DivideByZero do: { |ex| ex return: 42 })
                           == 42 }
               testing: "division by zero (handled)".

        assert forAll: SmallIntegers
               that: { |x|
                       x is 0
                           ifTrue: { x = 1 }.
                       [ self auxIntegerDivZeroError: x by: x,
                         self auxIntegerDivZeroError: x by: 0 ]
                       == [1, "oops"] }
               testing: "division by zero (good catch)"!

    method testPrintBase
        assert that: { Integer printBase: 10 do: { 123 toString } }
               equals: "123"
               testing: "integer printbase 10 on 123".
        assert that: { Integer printBase: 10 do: { -123 toString } }
               equals: "-123"
               testing: "integer printbase 10 on -123".
        assert that: { Integer printBase: 10 do: { 0 toString } }
               equals: "0"
               testing: "integer printbase 10 on 0".

        assert that: { Integer printBase: 2 do: { 123 toString } }
               equals: "0b1111011"
               testing: "integer printbase 2 on 123".
        assert that: { Integer printBase: 2 do: { -123 toString } }
               equals: "-0b1111011"
               testing: "integer printbase 2 on -123".
        assert that: { Integer printBase: 2 do: { 0 toString } }
               equals: "0b0"
               testing: "integer printbase 2 on 0".

        assert that: { Integer printBase: 16 do: { 123 toString } }
               equals: "0x7B"
               testing: "integer printbase 16 on 123".
        assert that: { Integer printBase: 16 do: { -123 toString } }
               equals: "-0x7B"
               testing: "integer printbase 16 on -123".
        assert that: { Integer printBase: 16 do: { 0 toString } }
               equals: "0x0"
               testing: "integer printbase 16 on 0"!
end
