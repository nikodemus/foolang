import .object.Object

interface Composable
    is Object
    method then: then
        Composition
            first: self
            then: then!
end

class Composition { first then }
    is Composable
    method printOn: output
        output print: "#<Composition {first} then: {then}>"!
    method value
        self then value: first value!
    method value: arg
        self then value: (first value: arg)!
    method value: arg1 value: arg2
        self then value: (first value: arg1 value: arg2)!
end

extend Closure
    is Composable

    method displayOn: stream
        stream print: self toString!

    method whileTrue
        { self value } whileTrue: {}!

    method whileFalse
        { self value } whileFalse: {}!

    method whileFalse: bodyBlock
        { self value not } whileTrue: bodyBlock!

    method after: block
        let res = self value.
        block value.
        res!

    method loop
        { True } whileTrue: self!

    method with: value
        -- Deserves a better verb than close, should probably
        -- steal python's __enter__ and __exit__ style names.
        -- and protocol.
        { self value: value } finally: { value close }!

    method ascending
        { |a b| (self value: a) < (self value: b) }!

    method descending
        { |a b| (self value: a) > (self value: b) }!

    method on: condition do: block
        condition withHandler: block do: self!

    method catch: condition
        Catch block: self condition: condition!
end

class Catch { block condition }
    method value
        block
            on: condition
            do: { |ex| return ex }!
end

-- For testing Closure#with:
class _Closable { closed }
    method close
        closed = True!
end

class TestSelfRefInClosure { cookie }
    direct method test
        (self cookie: 132132132) test!
    method test
        { self cookie is cookie } value!
end

class TestClosure { assert }

    direct method runTests: assert
        (self assert: assert) runTests!

    method runTests
        self
            ; testApplication
            ; testOnPanic
            ; testFinally
            ; testWhileTrue
            ; testWhileFalse
            ; testWith
            ; testAscending
            ; testDescending
            ; testApply
            ; testSelfRefInClosure
            ; testArity
            ; testSignature
                .
        self!

    method testSignature
        assert forAll: [
            [{ 42 }, []],
            [{ || 42 }, []],
            [{ |x| x }, [Any]],
            [{ |x::Integer z y::Object| x + y }, [Integer, Any, Object]]
        ]
            that: { |case|
                    case first signature == case second }
            testing: "Closure#signature"!

    method testArity
        assert forAll: [
            [{ 42 }, 0],
            [{ || 42 }, 0],
            [{ |x| x }, 1],
            [{ |x y| x + y }, 2]
        ]
            that: { |case|
                    case first arity is case second }
            testing: "Closure#arity"!

    method testSelfRefInClosure
        assert true: { TestSelfRefInClosure test }
               testing: "reference to self inside closure"!

    method testApplication
        assert true: { 1 == { 1 } value }
               testing: "Closure#value"!

    method testOnPanic
        assert true: { { panic "Foo". False }
                         onPanic: { |p| True } }
               testing: "Closure#onPanic"!

    method testFinally
        assert true: { let flag = False.
                       { { panic "Foo". False }
                             finally: { flag = True } }
                       onPanic: { |p| flag } }
               testing: "Closure#finally"!

    method testWhileTrue
        let a = 0.
        assert that: { { a < 10 } whileTrue: { a = a + 1 }. a }
               is: 10
               testing: "Closure#whileTrue:".
        let b = 0.
        assert that: { { b = b + 1. b < 10 } whileTrue. b }
               is: 10
               testing: "Closure#whileTrue"!

    method testWhileFalse
        let a = 0.
        assert that: { { a == 10 } whileFalse: { a = a + 1 }. a }
               is: 10
               testing: "Closure#whileFalse:".
        let b = 0.
        assert that: { { b = b + 1. b == 10 } whileFalse. b }
               is: 10
               testing: "Closure#whileFalse"!

    method auxTextLoop
        let a = 0.
        { a = a + 1. a == 10 ifTrue: { return a } } loop!

    method testLoop
        let a = 0.
        assert that: { auxTestLoop }
               is: 10
               testing: "Closure#loop"!

    method testWith
        assert false: { (_Closable closed: False) closed }
               testing: "Closure#with: (sanity check)".
        assert that: { let obj = _Closable closed: False.
                       let res = { |arg| 42 } with: obj.
                       [obj closed, res] }
               equals: [True, 42]
               testing: "Closure#with: (normal)".
        assert that: { let obj = _Closable closed: False.
                       let res = { { |arg| panic "Bang" } with: obj }
                                     onPanic: { |p| 104 }.
                       [obj closed, res] }
               equals: [True, 104]
               testing: "Closure#with: (unwind)"!

    method testAscending
        assert that: { ["a", "aaaa", "aa", "", "aaa"]
                           sort: { |array| array size } ascending }
               equals: ["", "a", "aa", "aaa", "aaaa"]
               testing: "Closure#ascending"!

    method testDescending
        assert that: { ["a", "aaaa", "aa", "", "aaa"]
                           sort: { |array| array size } descending }
               equals: ["aaaa", "aaa", "aa", "a", ""]
               testing: "Closure#descending"!

    method testApply
        assert that: { { |x y| x + y } apply: [1, 2] }
               equals: 3
               testing: "Closure#apply:"!

end
