= Foolang =

_The Foo Programming Language_

Foolang is a Smalltalk-inspired language that tries
to take a lessons from Common Lisp, Erlang, Factor, and Rust
to heart.

WARNING: Foolang is still in early development. Everything
and anything in this document is subject to change.

include::hello-world.adoc[leveloffset=1]

== Goals ==

_Like all newborn languages, Foolang aspires to unrealistic
goals._

=== Pleasure to Write, Pleasure to Read

Main purpose of a programming language is expression and
communication of ideas. If it fails in this nothing else
matters.

To my mind this implies certain things:

- Syntax should be minimal, words and whitespace are
  generally preferable to punctuation.

- Ideally reading order matches the execution order.

- Expression of mathematical ideas ideally matches the
  mathematical idiom.

- The less names one needs to express the program clearly,
  the better. (Better a couple of names too many then
  too few, though.)

- While a good live development environment is a must, the
  code needs to remain readable outside such an environment.

- Documentation is an integral part of code.

=== Real Computers All The Way Down

[quote, Alan Kay, in Computerworld Australia July 2010]
____
To me, one of the nice things about the semantics of real objects is that
they are "real computers all the way down (RCATWD)" -- this always retains
the full ability to represent anything. The old way quickly gets to two
things that aren't computers -- data and procedures -- and all of a sudden
the ability to defer optimizations and particular decisions in favour of
behaviours has been lost.
____

It took me a long time to appreciate this properly.

Objects are entities which respond to messages, not data +
procedures.

Of course, Turing tells us the all computation is
equivalent, but if that was the _whole_ truth we'd still be
programming in binary.

It's not about power. It's about ease and it's about how the
language influences your thinking, and about the towers
you end up building.

=== Sufficient Performance

While the earlier Alan Kay quote talks about importance
of late binding and deferring optimizations, performance is
important too: if code isn't fast enough for the task
at hand then it's useless.

Performance is a property of an implementation, not
language, but since Foo is intended to be a
single-implementation language the distinction is moot.

Success criteria is matching speed of _unoptimized_ C or C++
for basic operations like recursive algorithms, numerics,
and instance variable access while not being completely
embarrassed by memory management overhead.

- Instance variable access should always be just a simple
  memory access.

- Sending a message to an instance of a known class should
  cost about as much as a simple function call.

- Sending a message to an instance implementing a known
  interface should cost about as much as C++ a virtual
  function call.

- Sending a message to an unknown instance should cost
  about as much as a CLOS method call.

NOTE: Matching speed of unoptimized C++ should be a matter
of a decent high-level IR and partial evaluation. Matching
speed of optimized C++ requires a good modern compiler
backend and appropriately tuned passes -- something we can
hopefully leave to LLVM and co.

=== A Great Environment

Smalltalk-style development environments remain largely
unmatched by other languages.

- Code formatter, inspector, debugger, and browser are basic
  tools of civilization.

- Notebooks are REPLs on steroids, and as such lovely--but
  they're exploration tools not the final product.

- Modifying live code should be a regular part of
  development cycle.

- Multiple views into the same codebase:

  * All/Selected methods of this class.
  * All methods with this selector.
  * All methods using this selector.
  * All methods referring to this class or global.
  * Current method followed by methods it invokes.
  * Etc...

- Bookkeeping minutiae such as _"Which file do I put this
  class in?"_ are better left to the system. Human concerns
  should be on the semantic level: _"Which module does
  this class belong to?"_

- Source code _does_ belong in files, not an image.

=== Safe Package System

Foolang has no _ambient authority_: the main program
receives a system object which provides access to the
command-line arguments, environment variables,
standard IO streams, files, memory, network,
shared objects, etc...

For other parts of the program to have access to these
they must be explicitly passed down.

Implementor of a package _cannot_ read files or connect
to the network behind your back because they do not have
access to it: there is no globally accessible Socket class
they can instantiate.

Even if the package wraps a piece of foreign code
which could in principle do anything, the package still
requires explicit access to the shared object.

=== Safe Threading ===

Foo takes the Erlang approach to concurrency: threads
are fully isolated from each other and communicate through
serialized messages.

- GC pauses are per thread, not global.
- Many forms of deadlocks are simply not present.
- Threads can be killed with impunity.

In addition to this, to address the needs of scientific
computation a set of built-in classes and methods to
provide data parallelism is planned, but the details
are very fuzzy as of yet.
