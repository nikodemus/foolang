# Tutorial

_Foolang &mdash; the Foo programming language_

If you haven't installed Foo yet, see <<install.adoc#top,
Installing Foo>> first.

include::hello-world.adoc[leveloffset=1]

### Running

Put the code above into a file named `hello.foo`, and run
it from terminal as:

----
foo hello.foo
----

If everything goes well that should print `"Hello World!"`
on the terminal and then exit.

### Messages

`object message` is the general pattern for messages that don't
take any arguments, called unary messages.

`object key1: arg1 key2: arg2 ...` is the general pattern
for messages with one or more arguments, called keyword
messages.

### System Object

In Foolang all operating system facilities for interacting
with the host system at large are accessed through the
<<glossary.adoc#system_object,system object>>.

In fancier terms, _there is no ambient authority_ in Foolang.

## Greeter

In addition to `@main` other things can appear at toplevel.
The most important are `@class` and `@method`.

Open a file called `greeter.foo` and insert the following
code.

.greeter.foo
----
@class Greeter { input, output }
----

This is a class definition. It specifies that there is a
class called `Greeter` which has instance variables called
input and output.

NOTE: All toplevel items in Foolang start with an @-sign.

Given this definition we can send the Greeter class the
message `input:output:` create an instance of it.

Add the following code:

.greeter.foo
----
@method Greeter name
   output println: "What is your name?"
   input readline

@method Greeter nickname
   output println: "What is your nickname?"
   input readline
----

This defines the methods `name` and `nickname` on instances
of Greeter.

- Instance variables of the class can be directly
  accessed by name.

- Return value is the value of the last expression
  evaluated, here the lines read from input.

Add the following code:

.greeter.foo
----
@method Greeter greet: name aka: nick
   output println: "Hello: {name}, also known as {nick uppercase}"
----

This defines a keyword method with two arguments. The name
of the method is `greet:aka:` and the arguments will be
bound to variables `name` and `nick`.

Double-quoted strings can contain `{...}` blocks which
refer to the lexical environment and are interpolated
into the string.

Add the following code:

.greeter.foo
----
@method Greeter run
    Do loop: {
      self greet: self name
           aka: self nickname
      output println: "Next!"
    }
----

The braces enclose a _block_. If you're familiar with
closures, that's what blocks are -- if you're not, don't
worry.

`Do` is a global object hosting a number of control flow
messages. Sending it the `loop:` message initiates an
infinite loop: it will execute the block passed to it ad
infinitum.

Here we also see `self`, which allows and object to send
messages to itself.

Unary messages have a higher precedence than keyword
messages:

----
self greet: self name
     aka: self nickname
----

is equivalent to

----
self greet: (self name)
     aka: (self nickname)
----

Newlines terminate expressions unless they occur in the
middle of a message: the specific rules are unimportant
right now but the behaviour is quite intuitive. If you
wish to put two expressions on the same line you can
use a comma to separate them:

----
self greet: self name
     aka: self nickname
output println: "Next!"
----

is equivalent to

----
self greet: self name aka: self nickname, output println: "Next!"
----

Similarly, if you wish to split a chain of unary messages
across multiple lines, you can use a backslash to delimit
the line:

----
foo bar quux
----

is equivalent to

----
foo bar \
  quux
----

Finally, add the following code:

----
@main: system
  Greeter input: system input
          output: system output
  -- run
----

Like before, `system` gives us access to the operating
system environment, so we pass `Greeter` the input and
output it needs.

The doubledash is a chaining operator:

- The message following it is sent to the result
  of the previous expression.

- It has a low precedence, so that instead of
  sending `run` to the output stream we send
  it to the newly constructed greeter.

- It is "in the middle of a message" so it can
  occur on a new line without terminating the
  previous expression.

Ie.

----
Greeter input: system input
        output: system output
-- run
----

is equivalent to

----
(Greeter input: system input output: system output) run
----

### Classes

`@class <ClassName> { <instanceVariable>, ... }` is the general pattern
for defining classes.

`<ClassName> <instanceVariable>: <value> ...` is the general pattern
for constructing instances of classes.

### Methods

`@method <ClassName> <message> ...` is the general pattern for defining unary
methods.

`@method <ClassName> <key>: <arg> ...` is the general pattern for
defining keyword methods.

### String Interpolation

`"This is an {interpolated} string."` is the general pattern
for interpolated strings. The value of the interpolated
expression is implicitly sent the message toString.

### Parameterless Blocks

`{ code here }` is the general pattern for a parameterless block.

### Separating and Chaining Expressions

Newlines separate expressions unless the newline occurs
in the middle of a message:
----
<expression>
<expression>
----

Comma can also be used to separate expressions:
----
<expression>, <expression>
----

Unary messages can be tied to the previous expression
across a newline by using a backslash:
----
<expression> \
  <unaryMessage>
----

Unary messages can be chained to the result of a keyword
message by using a doubledash, which can also be split
across a new line:

----
<object> <key>: <arg> -- <unaryMessage>
----

----
<object> <key>: <arg>
-- <unaryMessage>
----
