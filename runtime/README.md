# Foolang C Runtime

This is the support runtime code generated by Foolang's (next) C
backend.

## Goals & Limitations:

- Portability: OS-specific code is expected and acceptable but needs to
  be isolated into OS-specific files. CPU specific code is not. The
  self-hosting output from C backend and this runtime will be the future
  bootstrapping path for new platforms.
  
- Clarity and debuggability: since this code is expected to remain in
  place "forever", cleanliness and ease of working with it is at
  premium.
  
- Full featured: this will be the first incarnation of Foolang
  supporting the entire planned feature set, including N:M actor model
  with work stealing, and delimited multi-shot continuations.

- Decent performance: non-allocating loops with only known calls should
  have at most 50% overhead over C code with similar functionality.
  
## Executor Pool

Executor Pool is a global pool of Executors. It is created on Foolang
startup is read-only during system lifetime currently. Normally there is
one Executor per CPU core.

Future version of Foolang may support growing and shrinking the pool at
runtime, but that is an unnecessary complication at the moment.

Executor Pool has
- Size: the number of Executors.
- Executors: pointer to an array of Executors.

## Executors

Each Executor has a thread that runs the Executor Loop in a thread, and
a FIFO of Actors to run.

The Executor Loop dequeues an Actor from its FIFO, and runs for a
timeslice before putting if back in the queue and dequeing the next one.
If an Executor has no actors to run it will attempt to steal one from
another, or goes to sleep waiting for new Actors to be created it if
cannot.

Future version of Foolang will support more complex load balancing between
Executors.

An Executor has
- Id: position of this Executor in the Executor Pool's array.
- Lock: a mutex protecting access to this Executor's Queue.
- Queue: a FIFO of ready Actors.
- Waiting: a FIFO of waiting Actors.

### Scheduling an Actor

1. Executor locks itself

### Running an Actor

One tick of a timeslice consists of:
- Executor fetches the current continuation from top of the stack.
- Executor calls the current continuation with current stack pointer and
  the Actor object.
- The continuation returns the next stack pointer.

In addition 

Alternatively, the continuation can also yield to its yieldpoint, which
is set

## Actors

Actors are units of control flow and work, similar to threads or
processes.

Actors never share mutable memory with each other: they have their own
private stack, heap, and dynamic variable bindings.

Actors have following states:
- READY: Ready for execution by an Executor.
- RUNNING: Currently being exectuted by an Executor.
- WAITING: Waiting for something in order to become READY.
- DONE: Has completed all its work.

Actors have:
- Stack
- Stack pointer
- Base pointer
- Heap
- Yieldpoint (A pointer to a C jmp_buf.)

Base pointer is _only_ used from inside actor code. As far as the
runtime is concerned, it could point to the moon. Actually it is
set by the method prelude to point to the start of the arguments,
ie. (1 + nargs) * 2 words down from stack pointer. (1 for receiver.)

### Actor Stack

The from top down when READY or WAITING:

1. Current Continuation. (Function pointer.)
2. Frame layout word.
3. Variable amount of data, size and layout determined by the layout word.
4. Next Continuation.
5. Etc.

# SKETCH

## 
