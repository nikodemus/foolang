# Foolang C Runtime

This is the support runtime code generated by Foolang's (next) C backend.

## Goals & Limitations:

- Portability: OS-specific code is expected and acceptable but needs to be
  isolated into OS-specific files. CPU specific code is not. The self-hosting
  output from C backend and this runtime will be the future bootstrapping path
  for new platforms.
  
- Clarity and debuggability: since this code is expected to remain in place
  "forever", cleanliness and ease of working with it is at premium.
  
- Full featured: this will be the first incarnation of Foolang supporting the
  entire planned feature set, including N:M actor model with work stealing,
  and delimited multi-shot continuations.

- Decent performance: non-allocating loops with only known calls should have
  at most 50% overhead over C code with similar functionality.
  
## Executor Pool

Executor Pool is a global pool of Executors. It is created on Foolang startup
is read-only during system lifetime currently. Normally there is one Executor
per CPU core.

Future version of Foolang will likely support growing and shrinking the pool
at runtime, but that is an unnecessary complication at the moment.

Executor Pool has
- Size: the number of Executors.
- Executors: pointer to an array of Executors.

## Executors

Each Executor runs in a thread, and has a FIFO of Actors to run. An Executor
dequeues an Actor from its FIFO, and runs for a timeslice before putting if back
in the queue and dequeing the next one. If an Executor has no actors to run it
will attempt to steal one from another.

More complex load balancing between Executors will be added in a later version
of Foolang, as it is not critical right now.

An Executor has
- Id: position of this Executor in the Executor Pool's array.
- Lock: a mutex protecting access to this Executor's Queue.
- Queue: a FIFO of ready Actors.
- Waiting: a FIFO of waiting Actors.

### Scheduling an Actor

1. Executor locks itself

### Running an Actor

One tick of a timeslice consists of:
- Executor fetches the current continuation from top of the stack.
- Executor calls the current continuation with current stack pointer and the Actor object.
- The continuation returns the next stack pointer.

In addition 

Alternatively, the continuation can also yield to its yieldpoint, which is set

## Actors

Actors are units of control flow and work, similar to threads or processes.

Actors never share mutable memory with each other: they have their own private
stack, heap, and dynamic variable bindings.

Actors have following states:
- READY: Ready for execution by an Executor.
- RUNNING: Currently being exectuted by an Executor.
- WAITING: Waiting for something in order to become READY.
- DONE: Has completed all its work.

Actors have:
- Stack
- Stack pointer
- Heap
- Yieldpoint (A pointer to a C jmp_buf.)

### Actor Stack

The from top down when READY or WAITING:

1. Current Continuation. (Function pointer.)
2. Frame layout word.
3. Variable amount of data, size and layout determined by the layout word.
4. Next Continuation.
5. Etc.

