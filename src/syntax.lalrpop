use std::str::FromStr;
use crate::ast::{
  Identifier, Expr, Literal, Cascade, Method, Block, ClassDescription, Definition, Program,
  MethodDescription, ProgramElement
};
use crate::utils::{
  prepend, chop, chopchop,
};

grammar;

pub ProgramElement: ProgramElement = {
  Expression => ProgramElement::Expr(<>),
  Definition => ProgramElement::Definition(<>),
}

// FIXME: rename to module
pub Program: Program = {
  <e:Definition> <p:Program> => prepend(e, p),
  <e:Definition> => vec![e],
};

Definition: Definition = {
  Class => Definition::Class(<>),
  InstanceMethod => Definition::InstanceMethod(<>),
  ClassMethod => Definition::ClassMethod(<>)
};

pub Class: ClassDescription = {
  "@class" <id:Identifier> <s:SlotNames> => ClassDescription {
    name: id,
    slots: s,
  }
};

pub InstanceMethod: MethodDescription = {
  "@method" <class:Identifier> <method:Method> => MethodDescription {
    class: class,
    method: method,
  }
};

pub ClassMethod: MethodDescription = {
  "@class-method" <class:Identifier> <method:Method> => MethodDescription {
    class: class,
    method: method,
  }
};

pub Method: Method = {
  <p:MessagePattern> <b:MethodBody>
    => Method {
        selector: p.0, parameters: p.1,
        temporaries: b.0, docstring: b.1, statements: b.2
  },
  <p:MessagePattern>
    => Method {
        selector: p.0, parameters: p.1,
        temporaries: vec![], docstring: None, statements: vec![]
  },
};

MethodBody: (Vec<Identifier>, Option<String>, Vec<Expr>) = {
  <t:Temporaries> <d:DocString> <s:Statements> => (t, Some(d), s),
  <d:DocString> <s:Statements> => (vec![], Some(d), s),
  <t:Temporaries> <s:Statements> => (t, None, s),
  <t:Temporaries> <d:DocString> => (t, Some(d), vec![]),
  <t:Temporaries> => (t, None, vec![]),
  <d:DocString> => (vec![], Some(d), vec![]),
  <s:Statements> => (vec![], None, s),
};

MessagePattern: (Identifier, Vec<Identifier>) = {
  UnarySelector => (<>, vec![]),
  <a:BinarySelector> <b:Identifier> => (a, vec![b]),
  <a:KeywordPattern> => a,
};

KeywordPattern: (Identifier, Vec<Identifier>) = {
  <a:Keyword> <b:Identifier> <c:KeywordPattern>
    => (a.concat(c.0), prepend(b, c.1)),
  <a:Keyword> <b:Identifier>
    => (a, vec![b]),
};

SlotNames: Vec<Identifier> = {
  "[" "]" => vec![],
  "[" <i:Identifiers> "]" => i,
};

DocString: String  = {
  r#""([^"]|(""))*""# => chopchop(String::from(<>)),
};

pub Expression: Expr = {
   <i:Identifier> ":=" <e:Expression> => Expr::Assign(i, Box::new(e)),
   PrimaryExpression,
   MessageExpression,
   CascadedMessageExpression,
};

PrimaryExpression: Expr = {
  Identifier => Expr::Variable(<>),
  ConstantExpr,
  Block => Expr::Block(<>),
  "(" <e:Expression> ")" => e,
  "[" <e:DottedExpressions> "]" => Expr::ArrayCtor(e),
};

DottedExpressions: Vec<Expr> = {
  <e:Expression> "." <v:DottedExpressions> => prepend(e, v),
  <e:Expression> => vec![e],
};

Block: Block = {
   // FIXME: This causes a conflict with Variable and I'm not sure how to fix that -- but
   // since I'm planning to change to let-style anywhow I'm not going to worry about it now,
   // and I only needed temps for testing assignment anyhow...
   //  "{" <p:BlockParams> "|" <t:Identifiers> "|" <s:Statements> "}" => Block { parameters: p, temporaries: t, statements: s },
   "{" "|" <t:Identifiers> "|" <s:Statements> "}" => Block { parameters: vec![], temporaries: t, statements: s },
   "{" <p:BlockParams> "|" <s:Statements> "}" => Block { parameters: p, temporaries: vec![], statements: s },
   "{" <s:Statements> "}" => Block{ parameters: vec![], temporaries: vec![], statements: s },
   "{" "}" => Block { parameters: vec![], temporaries: vec![], statements: vec![] },
};

BlockParams: Vec<Identifier> = {
   <i:BlockParam> <is:BlockParams> => prepend(i, is),
   <i:BlockParam> => vec![i]
};

Statements: Vec<Expr> = {
  <s:Statement> "." <ss:Statements> => prepend(s, ss),
  <s:Statement> "." => vec![s],
  <s:Statement> => vec![s],
};

Statement: Expr = {
  "^" <e:Expression> => Expr::Return(Box::new(e)),
  Expression,
};

MessageExpression: Expr = {
  UnaryExpression,
  BinaryExpression,
  KeywordExpression,
};

UnaryExpression: Expr = {
  <o:UnaryObjectDescription> <m:UnarySelector> => Expr::Send(Box::new(o), m, vec![]),
};

UnaryObjectDescription: Expr = {
  PrimaryExpression,
  UnaryExpression,
};

BinaryObjectDescription: Expr = {
  UnaryObjectDescription,
  BinaryExpression,
};

UnarySelector: Identifier = {
  Identifier,
};

BinaryExpression: Expr = {
  <a:BinaryObjectDescription> <s:BinarySelector> <b:UnaryObjectDescription>
    => Expr::Send(Box::new(a), s, vec![b])
};

KeywordExpression: Expr = {
  <a:BinaryObjectDescription> <b:KeywordTail>
    => Expr::Send(Box::new(a), b.0, b.1),
};

// This is immediately destructured in KeywordExpression -- This
// exists as a separate thing only to make the typechecking nice for
// the grammar.
KeywordTail: (Identifier, Vec<Expr>) = {
  <k:Keyword> <arg:BinaryObjectDescription> <more:KeywordTail>
    => (k.concat(more.0), prepend(arg, more.1)),
  <k:Keyword> <arg:BinaryObjectDescription>
    => (k, vec![arg]),
};

CascadedMessageExpression: Expr = {
  <a:MessageExpression> <t:CascadedMessageTail>
    => Expr::Cascade(Box::new(a), t),
};

CascadedMessageTail: Vec<Cascade> = {
    ";" <a:CascadedMessage> <b:CascadedMessageTail> => prepend(a, b),
    ";" <a:CascadedMessage> => vec![a],
};

// This syntax feels restrictive: why not allow
//
// DB open: "localhost";
//    tables print;
//    users print;
//    + 1 / 2
//
// ?
CascadedMessage: Cascade = {
   <a:UnarySelector> => Cascade::Message(a, vec![]),
   <a:BinarySelector> <b:UnaryObjectDescription> => Cascade::Message(a, vec![b]),
   <a:KeywordTail> => Cascade::Message(a.0, a.1),
};

Temporaries: Vec<Identifier> = {
  "|" <a:Identifiers> "|" => a
};

Identifiers: Vec<Identifier> = {
   <i:Identifier> <is:Identifiers> => prepend(i, is),
   <i:Identifier> => vec![i]
};

Keyword: Identifier = {
  r"[_a-zA-Z][_a-zA-Z0-9]*:" => Identifier(String::from(<>))
};

BlockParam: Identifier = {
  r":[_a-zA-Z][_a-zA-Z0-9]*" => Identifier(chop(String::from(<>)))
};

Identifier: Identifier = {
  r"[_a-zA-Z][_a-zA-Z0-9]*" => Identifier(String::from(<>))
};

BinarySelector: Identifier = {
  "-" => Identifier(String::from(<>)),
  r"[+/\\*~<>=@%|&?!]{1,2}" => Identifier(String::from(<>)),
};

ConstantExpr: Expr = {
  Constant => Expr::Constant(<>)
};

// So, amusingly we have both Constant and Literal.
//
// Constant is for "naked" constants in source code,
// and literal is for those wrapped inside arrays.
//
// The only difference is #-prefixes for symbols and
// arrays.
Constant: Literal = {
  "#" <a:Array> => a,
  "#" <s:Symbol> => s,
  SimpleLiteral,
};

Literal: Literal = {
  Array,
  Symbol,
  SimpleLiteral,
};

SimpleLiteral: Literal = {
  Number,
  String,
  Character,
};

String: Literal  = {
  r"'([^']|(''))*'" => Literal::String(chopchop(String::from(<>))),
};

Character: Literal = {
  <s:r"\$."> => Literal::Character(chop(String::from(s))),
};

Symbol: Literal = {
  SymbolName => Literal::Symbol(<>),
};

SymbolName: String = {
  <s:Identifier> => s.0,
  <s:BinarySelector> => s.0,
  <s:Keyword> => s.0,
  // FIXME: This currently allows foo:::bar: to pass, which
  // it probably should not.
  r"[_a-zA-Z][_a-zA-Z0-9]*:[:_a-zA-Z0-9]*:" => String::from(<>),
};

Array: Literal = {
  "[" "]" => Literal::Array(vec![]),
  "[" <a:ArrayData> "]" => Literal::Array(a),
};

ArrayData: Vec<Literal> = {
  <e:Literal> <a:ArrayData> => prepend(e, a),
  <a:Literal> => vec![a],
};

Number: Literal = {
  r"-?[0-9]+\.[0-9]+" => Literal::Float(f64::from_str(<>).unwrap()),
  r"-?[0-9]+" => Literal::Integer(i64::from_str(<>).unwrap()),
};
